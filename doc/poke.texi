\input texinfo
@comment %**start of header
@setfilename poke.info
@include version.texi
@settitle The Poke Book
@afourpaper
@comment %**end of header

@copying
This manual describes GNU poke (version @value{VERSION},
@value{UPDATED}).

Copyright @copyright{} 2019, 2020 Jose E. Marchesi

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Editors
@direntry
* poke: (poke). Interactive editor for binary files.
@end direntry

@titlepage
@title The Poke Book
@subtitle for version @value{VERSION}, @value{UPDATED}
@author by Jose E. Marchesi
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top The Poke Book

@insertcopying
@end ifnottex

@c Introduction
@c
@c - Motivation, and history (first part of talk)
@c - The program
@c - Demo: poking a relocation
@c
@c Hacking poke
@c
@c Writing poke commands.

@menu
Introduction
* Motivation::			Why a binary editor?
* Nomenclature::		poke, Poke and pickles.

Using poke
* Invoking poke::		command line options.
* Commanding poke::		Interactive and non-interactive usage.

Dot-Commands
* load command::		Loading pickles.
* file command::		Opening and selecting IO spaces.
* close command::		Closing IO spaces.
* editor command::		Using an external editor for input.
* info command::		Getting information about open files, @i{etc}.
* set command::			Querying and setting global options.
* vm command::			Poke Virtual Machine services.
* exit command::		Exiting poke :(

Commands
* dump::			Binary dumps.

Configuration
* pokerc::			User's initialization file.
* Styling::			Changing the appearance of poke's output.

The Poke Language
* Integers::			Whole numbers.
* Offsets::			Memory sizes and offsets.
* Strings::			NULL-terminated strings.
* Arrays::			Homogeneous collections.
* Structs::			Heterogeneous collections.
* Types::			Declaring types.
* Assignments::			Changing the value of variables.
* Compound Statements::		Sequences of statements.
* Conditionals::		Conditional statements.
* Loops::			Statements to iterate on conditions.
* Expression Statements::	Using expressions for their side-effects.
* Functions::			Procedural abstraction.
* Endianness::			Byte ordering.
* Mapping::			Accessing IO spaces.
* Exception Handling::		Dealing with exceptional conditions.
* Printing::			Output in Poke programs.

Debugging Poke Programs
* __LINE__ and __FILE__::	Error locations in traces.

The Standard Library
* Standard Integral Types::	int, long and the like.
* Standard Offset Types::	off64 and the like.
* Conversion Functions::	catos, atoi, etc.
* String Functions::		Functions which deal with strings.
* Sorting Functions::		qsort.
* CRC Functions::               Cyclic Redundancy Checksums.
* Dates and Times::             Processing and displaying dates and times.

Hacking poke
* Writing Commands::		Extending poke with new commands.

Appendices
* GNU Free Documentation License:: Distribution terms for this document.

Indexes
* Concept Index::
@end menu

@node Motivation
@chapter Motivation

XXX

@node Nomenclature
@chapter Nomenclature
@cindex poke
@cindex Poke
@cindex pickle

GNU poke is a new program and it introduces many a new concept.  It is
a good idea to clarify how we call things in the poke community.
Unless everyone uses the same nomenclature to refer to pokeish
thingies, it is gonna get very confusing very soon!

First of all we have @command{poke}, the program.  Since ``poke'' is a
very common English word, when the context is not clear we either use
the full denomination @command{GNU poke}, or quote the word using some
other mean.

Then we have @dfn{Poke}, with upper case P, which is the name of the
domain-specific programming language implemented by @command{poke},
the program.

This distinction is important.  For example, when people talk about
``poke programmers'' they refer to the group of people hacking GNU
poke.  When they talk about ``Poke programmers'' they refer to the
people who write programs using the Poke programming language.

Finally, a @dfn{pickle} is a Poke source file containing definitions
of types, variables, functions, @i{etc}, that conceptually apply to some
definite domain.  For example, @file{elf.pk} is a pickle that provides
facilities to poke ELF object files.  Pickles are not necessarily
related to file formats: a set of functions to work with bit patterns,
for example, could be implemented in a pickle named
@file{bitpatterns.pk}.

We hope this helps to clarify things.

@node Invoking poke
@chapter Invoking poke
@cindex invoking
Synopsis:

@example
poke [@var{option}@dots{}] [@var{file}]
@end example

@noindent
The following options are available.

@table @samp
@item -l
@itemx --load=@var{file}
Load the given file as a Poke program.  Any number of @samp{-l}
options can be specified, and they are loaded in the given order.
@item -L
Load the given file as a Poke program and exit.  This is commonly used
along with a shebang to implement Poke scripts.
@item -c
@itemx --command=@var{cmd}
Execute the given command.  Any number of @samp{-c} options can be
specified, and they are executed in the given order.
@item -s
@itemx --script=@var{file}
Load @var{file} as a poke script.  Any number of @samp{-s} options may
be specified, and they are loaded in the given order.
@item --color=@var{how}
@cindex styled output
Whether to use styled output, and how.  Valid options for @var{how}
are @samp{yes}, @samp{no}, @samp{auto}, @samp{html} and @samp{test}.
@item --style=@var{file}
Use @var{file} as the CSS to use for styling poke, instead of the
default style.
@item -q
@itemx --no-init-file
Do not load the @file{~/.pokerc} init file.
@cindex @file{.pokerc}
@item --quiet
Be as terse as possible.
@item --help
Print a help message and exit.
@item --version
Show version and exit.
@end table

@node Commanding poke
@chapter Commanding poke

GNU poke is primarily an interactive editor that works in the command
line.  However, it is also possible to use it in a non-interactive
way.  This chapter documents both possibilities.

@menu
* The REPL::		Using poke interactively.
* Evaluation::		Evaluating Poke.
* Commands::		Commands and dot-commands.
* Scripts::		Loading commands from files.
* Shebang::		Executing Poke programs in the command line.
@end menu

@node The REPL
@section The REPL
@cindex REPL
If poke is invoked with an interactive TTY connected to the standard
input, it greets you with a welcome message, licensing
information and such, and finally a prompt that looks like:

@example
(poke)
@end example

At this point, the program is ready to be commanded.  You are
expected to introduce a line and press @key{enter}.  At that point
poke will examine the command, notify you if there is some error
condition, process the line and maybe displaying something in the
terminal.

@cindex readline
Repeatedly typing complex commands can be tiresome.
To help you, poke uses the readline library
@xref{Top,,,rluserman,GNU Readline Library}.
This provides shortcuts and simple keystrokes to repeat
previous commands with or without modification, fast selection of
filenames and entries from other multiple choice contexts, and
navigation within a command and among previous commands.
@cindex history, session history
When the REPL starts, the history of your previous sessions
are loaded from the file @file{.poke_history} located in your home
directory (if it exists).

There are several kinds of lines that can be provided in the REPL:

@itemize @bullet
@item A @dfn{dot-command} invocation, that starts with a dot character
(@command{.}).
@item A command invocation.
@item A Poke statement.
@item A Poke expression.
@end itemize

These are explained in the following sections.

@node Evaluation
@section Evaluation

Both Poke expressions and statements can be introduced at the REPL.
When a trailing semicolon is required, it can be omitted.

When an expression is evaluated, the result of the expression is
printed back to you.  For example:
@cindex expresssions
@example
(poke) 23
23
(poke) [1,2,3]
[1,2,3]
(poke) Packet @@ 0#B
Packet @{i=1179403647,j=65794L@}
@end example

@cindex statements
When a statement is executed in the REPL no result is printed, but of
course the statement can print on its own:

@example
(poke) defun do_foo = void: @{@}
(poke) do_foo
(poke) for (i in [1,2,3]) printf "elem %i32d\n", i;
elem 1
elem 2
elem 3
@end example

@cindex errors
If there is an error compiling the line, you are notified with a
nice error message, showing the location of the error.  For example:

@example
(poke) [1,2,3 + "foo"]
<stdin>:1:6: error: invalid operands in expression
[1,2,3 + "foo"];
     ^~~~~~~~~
@end example

@node Commands
@section Commands

There are two kinds of commands in poke: the @dfn{dot-commands}, which
are written in C and have their own conventions for handling
sub-commands and passing arguments and flags, and normal commands,
which are written in Poke.

@subsection Dot-Commands
@cindex dot-commands
Dot-commands are so called because their name start with the dot
character (@code{.}).  They can feature subcommands.  Example:

@example
(poke) .vm disassemble mapper int[] @@ 0#B
(poke) .vm disassemble writer int[] @@ 0#B
@end example

When there is no ambiguity, the command name and the subcommands can
be shortened to prefixes.  The commands above can also be written as:

@example
(poke) .vm dis m int[] @@ 0#B
(poke) .vm dis w int[] @@ 0#B
@end example

@cindex flags
Some commands also get flags, which are one-letter indicators that can
be appended to the command name (including subcommands) after a slash
character (@code{/}).  For example, the @command{.vm} disassembler
commands accept a @code{n} flag to indicate we want a native
disassemble.  We can pass it as follows:

@example
(poke) .vm disassemble mapper/n int[] @@ 0#B
(poke) .vm disassemble writer/n int[] @@ 0#B
@end example

If a dot-command accepts more than one argument, they are separated
using comma characters (@code{,}).  Spaces are generally ignored.

@subsection Commands
@cindex commands
Regular poke commands are written in Poke and use different
conventions.  The name of commands follow the same rules as normal
Poke identifiers, and do not start with a dot character.

An example is the @command{dump} command:

@example
(poke) dump
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0100 f700 0100 0000 0000 0000 0000 0000  ................
00000020: 0000 0000 0000 0000 8001 0000 0000 0000  ................
00000030: 0000 0000 4000 0000 0000 4000 0800 0700  ....@.....@.....
00000040: 1800 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 7900 0000 0000 0000 b701 0000 9a02 0000  y...............
00000060: 7b10 0000 0000 0000 1800 0000 0000 0000  @{...............
00000070: 0000 0000 0000 0000 7900 0000 0000 0000  ........y.......
@end example

@cindex arguments
After the name of the command, arguments can be specified by name,
like this:

@example
(poke) dump :from 0#B :size 8#B
(poke) dump :from 0#B :size 8#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4c46 0201 0100                      .ELF....
@end example

The @command{dump} command is discussed in greater detail
below (@pxref{dump}).
The order of arguments is irrelevant in principle:

@example
(poke) dump :from 0#B :size 8#B :ascii 0 :ruler 0
00000000: 7f45 4c46 0201 0100
(poke) dump :ruler 0 :from 0#B :size 8#B :ascii 0
00000000: 7f45 4c46 0201 0100
@end example

However, beware side effects while computing the values you pass as
the arguments!  The expressions themselves are evaluated from left to
right.

Which arguments are accepted, and their kind, depend on the specific
command.

Note that the idea is to restrict the number of dot-commands to the
absolutely minimum.  Most of the command-like functionality provided
in poke shall be implemented as regular commands.

@node Scripts
@section Scripts
@cindex scripts
Script files contain poke commands.
A poke command may be a dot command, a Poke statement or a Poke
expression.
Lines starting with @code{#} are comments will be ignored.   However a
comment must start at the beginning of a line.  Here is an example
of a script:

@example
# The following two lines are dot commands
.load my-pickle.pk
.set obase 16

# The following line is a Poke statement
dump :size 0x100#B :from 0x10#B

# The following line is a Poke expression statement without any side effect.
# Consequently it is valid, but rather useless.
4 == 4
@end example

A script file contains commands, not Poke code.  This means
it gets read line by line and commands cannot occupy
more than one line.  Hence the following is a valid script:

@example
deftype foo = struct @{int this; int that;@}
@end example

@noindent
but this is not valid as a script file (although it is a valid Poke command)
and will provoke an error:

@example
deftype foo = struct
@{
 int this;
 int that;
@}
@end example

Script files can be loaded at startup using the @code{-s} command
line option (@pxref{Invoking poke}).
The @file{~/.pokerc} startup file is also an example of a poke
script (@pxref{pokerc}).

@node Shebang
@section Shebang
@cindex shebang, @code{#!}
Following the example of Guile Scheme, the Poke syntax includes
support for multi-line comments using the @code{#!} and @code{!#}
delimiters.  This, along with the @code{-L} command line option,
allows you to write Poke scripts and execute them in the command line like
if they were normal programs.  Example of a script:

@example
#!/usr/bin/poke -L
!#

print "Hello world!\n";
@end example

@node load command
@chapter @code{.load}
@cindex @code{.load}

The @command{.load} command loads a file containing Poke code and
compiles and executes it.  These files usually have the extension
@file{.pk}.

If a relative path is provided, then @file{@var{prefix}/share/poke}
is tried first as a base directory to find the specified file.  If it
is not found, then the current directory is tried next.

If the environment variable @code{POKEDATADIR} is defined, it replaces
@file{@var{prefix}/share/poke}.  This is mainly intended to test a
poke program before it gets installed in its final location.

If an absolute path is provided, it is used as-is.

@node file command
@chapter @code{.file}
@cindex @code{.file}
@cindex opening files
@cindex IO space
The @command{.file} command opens a new IO space backed by a file, or
switches to a previously opened file.  The syntax is:

@example
.file @var{path}|@var{#tag}
@end example

@cindex tags, file ID tags
Where @var{path} is a path to a file to open (which can be relative to
poke's current working directory or absolute) and @var{tag} is a tag
of the form @code{#NUMBER} that identifies a previously open file.

Tilde expansion is performed in @var{path}, much like it's done in the
shell.  This means you can include special characters like @code{~}
(which will expand to your home directory) delimit the filename with
@code{"} in case it includes leading or trailing blank characters,
@i{etc}.

When a new file is opened, it becomes the current IO space.  On that
point on, every map executed in the REPL or while loading a Poke
program will operate on that IO space:

@example
(poke) .file foo.o
The current file is now `foo.o'.
@end example

@cindex tags, file ID tags
A list of open files, and their corresponding tags, can be obtained
using the @command{.info files} command.  Once a tag is known, you can
use it to switch back to that file:

@example
(poke) .file #1
The current file is now `foo.o'.
@end example

@node close command
@chapter @code{.close}
@cindex @code{.close}

@cindex IO space
The @command{.close} command closes the selected IO space.  The syntax
is:

@example
.close @var{#tag}
@end example

Where @var{#tag} is a tag identifying an open IO stream.

@node editor command
@chapter @code{.editor}
@cindex @code{.editor}
@cindex editor
The @command{.editor} command (usually abbreviated as @command{.edit})
invokes an external text editor on a temporary file.  You can then
put contents on that file, save it and exit the editor.  At that point
poke will read the file contents, turn them into a single line and
execute them in the repl.

The editor used is identified by the @code{EDITOR} environment
variable.

@node info command
@chapter @code{.info}
@cindex @code{.info}

The @command{.info} command provides information about several kinds
of entities.  The recognized sub commands are:

@table @command
@item .info files
Display a list of open files.

@example
(poke) .info files
  Id	Mode	Position	Filename
* #0	rw      0x00000000#b	foo.bson
  #1	r       0x00000000#b	foo.o
@end example

@cindex IO space
The file acting as the current IO space is marked with an asterisk
character @code{*} at the beginning of the file.  The mode in which
the file is open is also specified.  The @code{Id} field is the tag of
the file that can be passed to the @command{.file} command in order to
switch to it as the new current IO space:

@example
(poke) .file #1
The current file is now `foo.o'.
(poke) .info files
  Id	Mode	Position	Filename
  #0	rw      0x00000000#b	file://foo.bson
* #1	r       0x00000000#b	foo.o
@end example

@item .info variable
@cindex variables
Shows a list of defined variables along with their current values and
the location where the variables were defined.
@item .info function
Shows a list of defined functions along with their prototypes and the
location where the functions were defined.
@end table

@node set command
@chapter @code{.set}
@cindex @code{.set}

@cindex global settings
The @command{.set} command allows you to inspect and set the value of
global settings.  The syntax is:

@example
.set @var{setting} [@var{value}]
@end example

Where @var{setting} is an identifier identifying the setting to
inspect or modify.  If @var{value} is specified, then it is the new
value for the setting.  If @var{value} is not specified the current
value of the setting is displayed.

The following settings can be handled with @command{.set}:

@table @code
@item endian
@cindex endianness
Byte endianness that will be used when mapping the IO space.  Valid
values are @code{big}, @code{little} and @code{host}.  The default
endianness is big endian.
@item obase
@cindex base, of displayed values
Numeric base to be used when displaying values in the REPL and in
@code{printf} statements using the @code{%v} format tag.  Valid values
are @code{2}, @code{8}, @code{10} and @code{16}.  Default value is
@code{10}.
@item pretty-print
@cindex pretty printing
Flag indicating whether pretty-printers shall be used when printing
values in the REPL and in @code{printf} statements using the @code{%v}
format tag.  Valid values are @code{yes} and @code{no}.  Default value
is @code{no}.
@item error-on-warning
@cindex errors
@cindex warnings
Flag indicating whether handling compilation warnings as errors.
Default value is @code{no}.
@end table

@node vm command
@chapter @code{.vm}
@cindex @code{.vm}

@cindex virtual machine
The Poke Virtual Machine (PVM) executes the programs that are the
result of the compilation of what you write in the REPL or the pickles
you load.  The @command{.vm} command provides sub-commands to interact
with the PVM.

@menu
* @:.vm disassemble::		PVM and native disassembler.
@end menu

@node @:.vm disassemble
@section @code{.vm disassemble}
@cindex disassembler
The @command{.vm disassemble} command provides access to the PVM
disassembler.  It supports the following subcommands:

@table @command
@item .vm disassemble expression @var{expr}
Dumps the assembler corresponding to the Poke expression @var{expr}.
@item .vm disassemble function @var{function}
Dumps the assembler corresponding to the Poke function called
@var{function}.  The function shall be reachable from the top-level.
@item .vm disassemble mapper @var{expr}
If @var{expr} is a mapped value, dumps the assembler corresponding to
its mapper function.
@item .vm disassemble writer @var{expr}
If @var{expr} is a mapped value, dumps the assembler corresponding to
its writer function.
@end table

The disassembler will provide a PVM disassembly by default, but it can
be passed the flag @command{/n} to do a native disassembly instead in
whatever architecture running poke.

@node exit command
@chapter @code{.exit}
@cindex @code{.exit}
@cindex quitting
@cindex @code{exit}
The @code{.exit} command exits poke.  The syntax is:

@example
.exit [@var{status}]
@end example

@noindent
Poke will terminate, returning the exit status @var{status}.
If @var{status} is omitted, then the exit status zero will be returned.

@node dump
@chapter @command{dump}
@cindex @command{dump}

At the most basic level, memory can be examined byte by byte.
To do this, use the @command{dump} command.
This command has the following prototype:

@example
defun dump = (off64 from = pk_dump_offset,
              off64 size = pk_dump_size,
              off64 group_by = pk_dump_group_by,
              int cluster_by = pk_dump_cluster_by,
              int ruler = pk_dump_ruler,
              int ascii = pk_dump_ascii) void:
@end example

@noindent
All arguments are optional, which means the simplest use of the command is
to simply type @command{dump}:

@example
(poke) dump
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 9b07 5a61 4783 f306 4897 f37c fe39 4cd3  ..ZaG...H..|.9L.
00000010: b6a2 a578 8d82 7b7f 2076 374c 3eab 7150  ...x..@{. v7L>.qP
00000020: 31df 8ecb 3d33 ee12 429b 2e13 670d 948e  1...=3..B...g...
00000030: 86f1 2228 ae07 d95c 9884 cf0a d1a8 072e  .."(...\........
00000040: f93c 5368 9617 6c96 3d61 7b92 9038 a93b  .<Sh..l.=a@{..8.;
00000050: 3b0d f8c9 efbd a959 88d0 e523 fd3b b029  ;......Y...#.;.)
00000060: e2eb 51d5 cb5b 5ba9 b890 9d7a 2746 72ad  ..Q..[[....z'Fr.
00000070: 6cbd 6e27 1c7f a554 8d2e 77f9 315a 4415  l.n'...T..w.1ZD.
@end example


@noindent
The first row is the @dfn{ruler} which serves as a heading for each
subsequent row.   On the left hand side is the offset of the io space
under examination.   The centre block displays the hexadecimal
representation of each byte, and on the right hand side is their ascii
representation.   If a byte is not representable in ascii, then the
byte will be displayed as a dot.


@menu
* Information @command{dump} shows::         Changing what @command{dump} shows.
* Presentation options for @command{dump}::  Changing how @command{dump} shows it.
@end menu

@node Information @command{dump} shows
@section Information @command{dump} shows

By default @command{dump} displays 128 bytes of memory starting at offset 0#B.
You can change the quantity and starting offset by using the @code{size}
and @code{from} arguments.  For example:

@example
(poke) dump :from 0x10#B :size 0x40#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000010: b6a2 a578 8d82 7b7f 2076 374c 3eab 7150  ...x..@{. v7L>.qP
00000020: 31df 8ecb 3d33 ee12 429b 2e13 670d 948e  1...=3..B...g...
00000030: 86f1 2228 ae07 d95c 9884 cf0a d1a8 072e  .."(...\........
00000040: f93c 5368 9617 6c96 3d61 7b92 9038 a93b  .<Sh..l.=a@{..8.;
@end example

@noindent
Note that both the @code{size} and @code{from} arguments are offsets.
As such, both must be specified using @code{#} and an appropriate unit.
(@pxref{Offset Literals}).

The other arguments change the appearance of the dump.
If the @code{ruler} argument is zero, then the ruler will be omitted:

@example
(poke) dump :ruler 0 :size 0x40#B
00000000: b1fd 1608 2346 759c 46a6 aa94 6fcd 846a  ....#Fu.F...o..j
00000010: e39f 473f 3247 415f 174d a32b ed89 a435  ..G?2GA_.M.+...5
00000020: d2c6 2c52 bc82 e0a7 e767 31ea 84de 41e5  ..,R.....g1...A.
00000030: 2add 2869 e9c2 226b e222 8c74 4b94 af24  *.(i.."k.".tK..$
@end example

To omit the ascii
representation of the memory, call @command{dump} with the @code{ascii}
argument set to zero:

@example
(poke) dump :ruler 0 :size 0x40#B :ascii 0
00000000: 4393 85e7 0b0c 3921 5a26 39ec 2f5f 5f15
00000010: cc46 e6f3 d50f 6ae6 8988 d50e f8c4 d1c6
00000020: 5a2f 7c3e 490b 18d8 d867 4b6f 2549 1f6c
00000030: 34a9 a0d7 24d2 e9ac 9240 8247 10cb 4ba1
@end example

@node  Presentation options for @command{dump}
@section Presentation options for @command{dump}

By default, the hexadecimal display shows two bytes grouped together,
and then a space.   You can alter this behaviour using the @code{group_by}
parameter.

@example
(poke) dump :ascii 0 :size 0x40#B :group_by 4#B
00000000: 68f19a63 df2a8886 c466631c a7fdd5c7  h..c.*...fc.....
00000010: 3075746a 0adb03ca f5b1ff14 6166fa07  0utj........af..
00000020: 0dd3cfbd 8eff46a2 4152a81d 471beddf  ......F.AR..G...
00000030: a0501cae 8bfcec6f 7a4f5701 45ba9fc3  .P.....ozOW.E...
@end example

Another parameter is the @code{cluster_by} argument.
By setting @code{cluster_by} to @var{n}, this
causes @command{dump} to display an additional space after the @var{n}th
group has been displayed, and also in the corresponding position in
the ascii display:

@example
(poke) dump :size 0x40#B :group_by 2#B :cluster_by 4
76543210  0011 2233 4455 6677  8899 aabb ccdd eeff  01234567 89ABCDEF
00000000: 91b8 540d d4dc 49ae  3320 ba7d efd1 16ab  ..T...I. 3 .@}....
00000010: b1a8 5ea0 5846 8bea  f741 3f80 42bc 201f  ..^.XF.. .A?.B. .
00000020: 6e5e fa50 23fb f16a  d380 be8c fc98 d195  n^.P#..j ........
00000030: 7bbf fa3e 3fc2 43a4  2a1e 9763 2bd6 5d24  @{..>?.C. *..c+.]$
@end example

If you have a personal preference on how memory dumps should appear,
you can set the relevant @code{pk_dump_*} variables.   These
global variables serve as the defaults for @command{dump}, so this way, you
will not need to explicitly pass them when you call the function.

@node pokerc
@chapter @file{.pokerc}
@cindex @file{.pokerc}
Upon invocation poke will read and execute the commands of the file
@file{~/.pokerc} if it exists in your home directory.  This can
be disabled by passing @code{-q} or @code{--no-init-file} in the command
line.

Example of initialization file:

@example
# My poke configuration.
.set endian host
.set obase 16
.set pretty-print yes
pk_dump_cluster_by = 4
.load ~/.poke.d/mypickles.pk
@end example

@node Styling
@chapter Styling
@cindex styled output

XXX

@node Integers
@chapter Integers
@cindex integers

Most of the values manipulated in Poke programs are whole numbers,
also typically known as @dfn{integers} in computing parlance.  This is
because integers are pervasive in binary formats, often featuring
unusual characteristics in terms of size and/or alignment.  Single
bits denoting flags or packed small integers are good examples of
this.  In order to ease the manipulation of such entities, and unlike
most programming languages, Poke provides integer types of any number
of bits and a rich set of accompanying operators.

@menu
* Integer Literals::		Writing integers in different bases.
* Characters::			Another way to write small integers.
* Booleans::			Integers denoting truth values.
* Integer Types::		int<N> and uint<N>.
* Casting Integers::		Converting integers.
* Relational Operators::	Comparing integers.
* Arithmetic Operators::	Operating with integers.
* Bitwise Operators::		Getting and setting integer bits.
* Boolean Operators::		Equality and inequality.
* Integer Attributes::		Accessing properties of integer values.
@end menu

@node Integer Literals
@section Integer Literals
@cindex integer literals
Integers literals can be expressed in several numeration bases.

@cindex decimal
@emph{Decimal numbers} use the usual syntax @code{[1-9][0-9]*}.  For
example, @code{2345}.

@cindex octal
@emph{Octal numbers} are expressed using a prefix @code{0o} (or
@code{0O}) followed by one or more digits in the range @code{[0-7]}.
Examples are @code{0o0}, @code{0o100} and @code{0o777}.

@cindex hexadecimal
@emph{Hexadecimal numbers} are expressed using a prefix @code{0x} (or
@code{0X}) followed by one or more hexadecimal digits in the range
@code{[0-f]}.  Examples are @code{0x0} and @code{0xfe00ffff}.  Note
that both the @code{x} in the prefix and the letters in the
hexadecimal number are case insensitive.  Thus, @code{0XdeadBEEF} is a
valid (but ugly as hell) literal.

@cindex binary
@emph{Binary numbers} are expressed using a prefix @code{0b} (or
@code{0B}) followed by one or more binary digits in the range
@code{[0-1]}.  Examples of binary literals are @code{0b0} and
@code{0B010}.

Negative numbers, of any numeration base, are constructed using the
minus operator as explained below.  Therefore the minus symbol
@code{-} in negative numbers is not part of the literal themselves.

@subsection The digits separator @code{_}
@cindex digits separator
@cindex separator, digits separator
The character @code{_} can appear anywhere in a numeric literal
except as the first character.  It is ignored, and its purpose is to
make it easier for programmers to read them:

@example
0xf000_0000_0000_0000
0b0000_0001_0000_0001
@end example

@subsection Types of integer literals
@cindex integer literals
@cindex size of variables
@cindex bitsize
The type of a numeric literal is the smallest signed integer capable
of holding it, starting with 32 bits, in steps of powers of two and up
to 64 bits.@footnote{Rationale: the width of a C ``int'' is 32 bits in
most currently used architectures, and binary data formats are usually
modeled after C.}

So, for example, the value @code{2} has type @code{int<32>}, but the
value @code{0xffff_ffff} has type @code{int<64>}, because it is out of
the range of signed 32-bit numbers.

A set of suffixes can be used to construct integer literals of certain
types explicitly.  @code{L} or @code{l} is for 64-bit integers.
@code{H} or @code{h} is for 16-bit integers (also known as
@dfn{halves}), @code{B} or @code{b} is for 8-bit integers (also known
as @dfn{bytes}) and @code{n} or @code{N} is for 4-bit integers (also
known as @dfn{nibbles}).

Thus, @code{10L} is a 64-bit integer with value
@code{0x0000_0000_0000_000A}, @code{10H} is a 16-bit integer with
value @code{0x000A} and @code{10b} is a 8-bit integer with value
@code{0x0A}.

@cindex signedness
Similarly, the signed or unsigned attribute of an integer can be
explicitly specified using the suffix @code{u} or @code{U} (the
default are signed types).  For example @code{0xffff_ffffU} has type
@code{uint<32>} and @code{0ub} has type @code{uint<8>}.  It is possible
to combine width-indicating suffixes with signedness suffixes:
@code{10UL} denotes the same literal as @code{10LU}.

The above rules guarantee that it is always possible to determine the
width and signedness of an integer constant just by looking at it,
with no ambiguity.

@node Characters
@section Characters
@cindex characters
8-bit unsigned integers can use an alternative literal notation that
is useful when working with @emph{ASCII character codes}.  Printable
character codes can be denoted with @code{'c'}.

@cindex escape sequence
Non-printable characters can be expressed using escape-sequences.  The
allowed sequences are:

@table @code
@item \n
New-line character (ASCII 012).
@item \t
Tab character (ASCII 011).
@item \\
The backslash character.
@item \[0-9][0-9]?[0-9]?
Character whose ASCII code is the specified number, in octal.
@end table

Examples:

@example
'o'
'\n'
'\t'
'\\'
'\0'
@end example

The type of a character literal is always @code{char}, aka
@code{uint<8>}.

@node Booleans
@section Booleans
@cindex boolean values
Like in C, truth values in Poke are encoded using integers.  Zero
(@code{0}) denotes the logical value ``false'', and any integer other
than zero denotes the logical value ``true''.

@node Integer Types
@section Integer Types

Most general-purpose programming languages provide a small set of
integer types, each featuring a range corresponding to strategic
storage sizes: basically, signed and unsigned variants of 8, 16, 32,
64 bits.  As we have seen in the previous sections, suffixes like
@code{H} or @code{L} are used in Poke for that purpose.

However, in conventional programming languages when integers having an
``odd'' width (like 13 bits, for example) get into play for whatever
reason, the programmer is required to use the integer arithmetic
operators (and sometimes bit-wise operators) herself, in a clever way,
in order to achieve the desired results.

Poke, on the contrary, provides a rich set of integer types featuring
different widths, in both signed and unsigned variants.  The language
operators are aware of these types, and will do the right thing when
operating on integer values having different widths.

Unsigned integer types are specified using the type constructor
@code{uint<@var{n}>}, where @var{n} is the number of bits.  @var{n}
should be an integer literal in the range @code{[1,64]}.  Examples:

@example
uint<1>
uint<7>
uint<64>
@end example

Similarly, signed integer types are created using the type constructor
@var{int<@var{n}>}, where @var{n} is the number of bits.  @var{n}
should be an integer literal in the range @code{[1,64]}.  Examples:

@example
int<1>
int<8>
int<64>
@end example

Note that expressions are not allowed in the type integral constructor
parameters.  Not even constant expressions.  Thus, things like
@code{int<foo>} and @code{uint<2+3>} are not allowed.

@node Casting Integers
@section Casting Integers
@cindex casts
The right-associative unary operator cast @code{as} can be used to
derive a new integer value having a different type from an existing
value.

For example, this is how we would create a signed 12-bit integer value
holding the value 666:

@example
(poke) 666 as int<12>
(int<12>) 666
@end example

Note that the @code{666} literal is originally a 32-bit signed
integer.  The cast performs the conversion.

Casts between integer types are always allowed, and never fail.  If
the new type is narrower than the existing type, truncation may be
performed to accommodate the value in its new type.  For example, the
expression @code{0x8765_4321 as uint<16>} evaluates to @code{0x4321}.
If the new type is wider than the existing type, either zero-extension
or sign-extension is performed depending on the signedness of the
operand.

@cindex signedness
The semantics of the sign-extension operation depends on the
signedness of the value being converted, and on the currently
selected encoding for negative numbers.

When using two's complement encoding, converting a signed value will
always sign-extend regardless of the signedness of the target type.
Thus:

@example
(poke) -2H as uint<32>
0xfffffffeU
(poke) -2H as int<32>
0xfffffffe
@end example

Likewise, converting an unsigned value will always zero-extend
regardless of the signedness of the target type. Thus:

@example
(poke) 0xffffUH as uint<32>
0xffffU
(poke) 0xffffUH as int<32>
0xffff
@end example

@node Relational Operators
@section Relational Operators

@cindex comparison
The following binary relational operators are supported on integer
values, in descending precedence order:

@itemize
@item Equality @code{==} and inequality @code{!=}.
@item Less than @code{<} and less or equal than @code{<=}.
@item Greater than @code{>} and greater or equal than @code{>=}.
@end itemize

When applied to integer and character values, these operators
implement an arithmetic ordering.

These operators resolve in boolean values encoded as 32-bit integers:
@code{0} meaning false and @code{1} meaning true.

@node Arithmetic Operators
@section Arithmetic Operators
@cindex arithmetic
The following left-associative binary arithmetic operators are
supported, in descending precedence order:

@itemize
@item Multiplication @code{*}, integer division @code{/}, integer
ceil-division @code{/^} and modulus @code{%}.
@item Addition @code{+} and subtraction @code{-}.
@end itemize

@cindex signedness
@cindex sign promotion
In all the binary arithmetic operations automatic promotions
(coercions) are performed in the operands as needed.  The rules are:

@itemize @bullet
@item If one of the operands is unsigned and the other operand is
signed, the second is converted to an unsigned value.
@item If the size in bits of one of the operands is bigger than the
size of the other operand, the second is converted to the same number
of bits.
@end itemize

The following right-associative unary arithmetic operators are
supported:

@itemize
@item Unary minus @code{-} and unary plus @code{+}.
@cindex minus
@end itemize

@node Bitwise Operators
@section Bitwise Operators
@cindex bitwise operators
The following left-associative bitwise binary operators are supported,
in descending precedence order:

@itemize
@item Bitwise shift left @code{<<.} and bitwise shift right @code{.>>}.
@cindex shifting
@item Bitwise AND @code{&}.
@cindex AND
@item Bitwise exclusive OR @code{^}.
@cindex exclusive OR
@item Bitwise inclusive OR @code{|}.
@cindex inclusive OR
@cindex OR
@item Bitwise concatenation @code{::}.
@cindex concatenation, bitwise
@end itemize

Bitwise concatenation works with any integral type, of any bit length.

The following right-associative unary bitwise operators are supported:

@itemize
@item Bitwise complement @code{~}.
@cindex complement
@end itemize

@node Boolean Operators
@section Boolean Operators
@cindex boolean operators
The following left-associative, short-circuited binary logical
operators are supported, in descending precedence order:

@itemize
@item Logical AND: @code{&&}.
@item Inclusive OR: @code{||}.
@end itemize

The following right-associative unary logical operators are supported:

@itemize
@item Logical negation @code{!}.
@cindex negation
@end itemize

@node Integer Attributes
@section Integer Attributes
@cindex attributes, integer attributes

The following attributes are defined for integer values.

@table @code
@item size
Gives an offset with the storage occupied by the string.  This
includes the terminating null.  Examples:

@example
(poke) 10'size
0x20UL#b
(poke) 10N'size
0x4UL#b
(poke) (10 as int<1>)'size
0x1UL#b
@end example

@item signed
@cindex signedness
Gives 1 if the value is a signed integer, 0 otherwise.  Examples:

@example
(poke) 10'signed
1
(poke) 10UL'signed
0
@end example
@item mapped
Always 0 for integers.  (@pxref{Mapping}).
@end table


@node Offsets
@chapter Offsets
@cindex offset
@cindex united values

Poke uses united values to handle offsets and data sizes.  This is a
very central concept in poke.

@menu
* Why Offsets::			Byte-oriented or bit-oriented?
* Offset Literals::		Denoting offsets in Poke.
* Offset Types::		offset<...>.
* Casting Offsets::		Converting offsets.
* Offset Operations::		Operating with offsets.
* Offset Attributes::           Accessing properties of offset values.
@end menu

@node Why Offsets
@section Why Offsets

Early in the design of what is becoming GNU poke I was struck by a
problem that, to my surprise, would prove not easy to fix in a
satisfactory way: would I make a byte-oriented program, or a
bit-oriented program?  Considering that the program in question was
nothing less than an editor for binary data, this was no petty
dilemma.

Since the very beginning I had a pretty clear idea of what I wanted to
achieve: a binary editor that would be capable of editing user defined
data structures, besides bytes and bits.  I also knew I needed some
sort of domain specific language to describe these structures and
operate on them.  How that language would look like, and what kind of
abstractions it would provide, however, was not clear to me.  Not at
all.

So once I sketched an initial language design, barely something very
similar to C structs, I was determined to not continue with the poke
implementation until I had described as many as binary formats in my
language as possible.  That, I reckoned, was the only way to make sure
the implemented language would be expressive, complete and useful
enough to fulfill my requirements.

The first formats I implemented using my immature little language
included ELF, FLV, MP3, BSON@dots{} of them describing structures
based on whole bytes.  Even when they try to be compact, it is always
by packing bit-fields in elements that are, invariably, sized as a
multiple of bytes.  Consequently, the language I was evolving became
byte oriented as well.  No doubt also influenced by my C inheritance,
I would think of bit-fields either as a sort of second class citizen,
or as mere results of shifting and masking.

This worked well.  The language evolved to be able to express many
different aspects of these formats in a very nice way, like
variable-length data and holes in structures.  Consider the following
definition in what actually is @strong{not} valid today's Poke:

@example
deftype Data =
  struct
  @{
    byte magic;
    byte count;
    byte dstart;

    byte[count] data @@ dstart;
  @};
@end example

The data starts with a byte that is a magic number.  Then the size of
the data stored, in bytes, and then the data itself.  This data,
however, doesn't start right after @code{dstart}: it starts at
@code{dstart}, which is expressed as an offset, in bytes, since the
beginning of the Data.  I conceived struct field labels to be any
expression evaluating to an integer, which would be@dots{}, bytes
obviously.

@cindex deflate
Then, one day, it was the turn for IETF RFC1951, which is the
specification of the DEFLATE algorithm and associated file format.  Oh
dear.  Near the beginning of the spec document it can be read:

@quotation
This document does not address the issue of the order in which bits of
a byte are transmitted on a bit-sequential medium, since the final
data format described here is byte- rather than bit-oriented.
However, we describe the compressed block format in below, as a
sequence of data elements of various bit lengths, not a sequence of
bytes.
@end quotation

Then it goes on describing rules to pack the DEFLATE elements into
bytes.  I was appalled, and certainly sort of deflated as well.  The
purpose of my program was precisely to edit binary in terms of the
data elements described by a format.  And in this case, these data
elements came in all sort of bit lengths and alignments.  This can be
seen in the following RFC1951 excerpt, that describes the header of a
compressed block:

@quotation
Each block of compressed data begins with 3 header bits
containing the following data:
@example
first bit       BFINAL
next 2 bits     BTYPE
@end example

Note that the header bits do not necessarily begin on a byte boundary,
since a block does not necessarily occupy an integral number of bytes.
@end quotation

At this point I understood that my little language on the works would
be never capable to describe the DEFLATE structures naturally: C-like
bit-fields, masking and shifting, all based on byte-oriented
containers and boundaries, would never provide the slickness I wanted
for my editor.  I mean, just use C and get done with it.

This pissed me off.  Undoubtedly other formats and protocols would be
impacted in a similar way.  Even when most formats are byte oriented,
what am I supposed to tell to the people hacking bit-oriented stuff?
``Sorry pal, this is not supported, this program is not for you''?  No
way, I thought, not on my watch.

The obvious solution for the problem, is to be general.  In this case,
to express every offset and every memory size in bits instead of
bytes.  While this obviously gives the language maximum expressiveness
power, and is ideal for expressing the few bit-oriented formats, it
has the disadvantage of being very inconvenient for most situations.

To see how annoying this is, let's revisit the little Data element we
saw above.  In a bit-oriented description language, we would need to
write something like:

@example
deftype BitData =
  struct
  @{
    byte magic;
    byte count;
    byte dstart;

    byte[count] data @@ dstart * 8;
  @};
@end example

Yeah@dots{} exactly.  The @key{*} and @key{8}> keys in the keyboards of
the poke users would wear out very fast, not to mention their patience
as well.  Also, should I provide both @code{sizeof} and
@code{bitsizeof} operators?  Nasty.

I am very fond of the maxim ``Never write a program you would never
use yourself''@footnote{Actually it is Lord Vetinari's ``Never build a
dungeon you can't get out of.'' but the point is the same.}, so I
resigned myself to make GNU poke byte oriented, and to provide as many
facilities for operating on bit-fields as possible.

@noindent
Fortunately, I have smart friends@dots{}

@cindex rabbit herd
During one of the Rabbit Herd's Hacking
Weekends@footnote{@url{http://www.jemarch.net/rhhw}} I shared my
frustration and struggle with the other rabbits, and we came to
realize that offsets and data sizes in Poke should not be pure
magnitudes or mere integer values: they should be united.  They should
have units.

It makes full sense when you come to think about it.  For a program
like poke, it is only natural to talk about different memory units,
like bits, bytes, kilobytes, megabits, and so on.  Bits and bytes are
just too common units.  Apart from allowing me to express values in
different units, this approach also has other benefits as we will see
shortly.

I'm really grateful to Bruno Haible, Luca Saiu and Nacho Gonzalez for
putting me on the right track.

@node Offset Literals
@section Offset Literals

Poke provides a convenient syntax to provide united values, which are
called @dfn{offsets} (because in a binary editor you mostly use them
to denote offsets in the file you are editing):

@example
12#B
7#b
1024#KB
@end example

@cindex magnitude
@cindex kilobytes
The offsets above denote twelve bytes, seven bits and one thousand
twenty four kilobytes, respectively.  The unit can be separated from
the magnitude by blank characters, so you can write the following
instead if you are so inclined:

@example
12 #B
7 #b
(1024 * 1024) #Kb
@end example

Note how the magnitude part of an offset doesn't need to be constant.
If the variable @code{a} contains an integer, this is how you would
denote ``a bytes'':

@example
a#B
@end example

In the offset syntax units are specified as @code{#@var{foo}}, where
@var{FOO} is the name of the unit.  Poke provides the following list
of hard coded unit names:

@cindex units

@table @code
@item b
bits.
@item B
bytes.
@item Kb
@cindex kilobits
kilo bits (1024 bits.)
@item KB
@cindex kilobytes
Kilo bytes (1024 bytes.)
@item Mb
@cindex megabits
Mega bits.
@item MB
@cindex megabytes
Mega bytes.
@item Gb
@cindex gigabits
Giga bits.
@end table

However, it is also possible to express units in multiples of the base
unit, which is the bit.  Using this syntax, it becomes possible to
express offsets in any arbitrary unit, as disparate as it may seem:

@example
17#3
0#12
8#1
@end example

That's it, 17 units of 3 bits each, zero units of 12 bits each,
and eight units of 1 bit each.

But then, why stopping there?  Poking is all about defining data
structures and operating on them@dots{} so why not using these structures
as units as well?  Consider the following struct:

@example
deftype Packet = struct @{ int i; long j; @};
@end example

The size of a @code{Packet} is known at compile time (which is not
generally true for Poke structs).  Wouldn't it be nice to use it as a
unit in offsets?  Sure it is:

@example
23#Packet
@end example

The above is the size occupied by 23 packets.  Any type whose size is
known at compile time can be specified as an offset unit.

@cindex ELF
Expressing offsets as united values also relieves the programmer from
doing many explicit unit conversions: poke can do them for you.
Consider for example an ELF section header.  One of its fields is the
size of the described section, in bytes:

@example
deftype Elf64_Shdr =
  struct
  @{
   @dots{}
   offset<Elf64_Xword,B> sh_size;
   @dots{}
  @};
@end example

If a given section is to contain, say, relocations with addends,
we can set its size doing something like this:

@example
shdr.sh_size = 10#Elf64_Rela;
@end example

@noindent
Instead of doing the conversion to bytes explicitly.

@cindex magnitude
If the magnitude of an offset is 1 then it is allowed to omit it
entirely.  To denote one kilobyte, for example, we can write
@code{#KB}.

@node Offset Types
@section Offset Types

Offset types are denoted as @code{offset<@var{base_type},@var{unit}>},
where @var{base_type} is an integer type and @var{unit} the
specification of an unit.

The offset base type is the type of the magnitude part of the united
value.  It can be any integer type, signed or unsigned, of any size.

The unit specification should be one of the unit identifiers that are
allowed in offset literals (see above), a constant positive integer or
the name of a Poke type whose size is known as compile time.

@cindex kilobits
Let's see some examples.  A signed 32-bit offset expressed in bytes
has type @code{offset<int<32>,B>}.  An unsigned 12-bit offset
expressed in kilobits has type @code{offset<uint<12>,Kb>}.  The later
type can also be written using an explicit integer unit like in
@code{offset<uint<12>,1024>}.  Finally, a signed 64-bit offset in units
of ``packets'', where a packet is denoted with a Poke type
@code{Packet} has type @code{offset<uint<64>,Packet>}.

@node Casting Offsets
@section Casting Offsets
@cindex casts
The right-associative unary operator cast @code{as} can be used to
derive a new offset value having a different type from an existing
value.

For example, this is how we would create a signed 12-bit offset in
units bytes:

@example
(poke) 1024#b as offset<int<12>,B>
(int<12>) 128#B
@end example

@cindex magnitude
The same rules governing conversion of integers apply for the
magnitude part.  Depending on the unit, there can be truncation, like
in:

@example
(poke) 9#b as offset<int,B>
1#B
@end example

@node Offset Operations
@section Offset Operations
@cindex offset algebra
Poke supports a little algebra for offsets.

@subsection Addition and subtraction
@cindex addition
@cindex subtraction
The addition or subtraction of two offsets results in another offset.
Examples:

@example
(poke) 1#B + 1#b
9#b
(poke) 2#KB - 1024#B
1024#B
@end example

The unit of the result is the greatest common divisor of the units of
the operands.

@subsection Multiplication by a scalar
@cindex multiplication
Multiplying an offset by a magnitude gives you another offset.
Examples:

@example
(poke) 8#b * 2
16#b
(poke) 16#MB * 0
0#MB
@end example

The unit of the result is the same as the unit of the offset
operand.

Note that multiplying two offsets is not supported.  This makes sense,
since computer memory is linear, and therefore it wouldn't make any
sense to have units like @code{#B@sup{2}}.

@subsection Division
@cindex division
Dividing two offsets gives you a magnitude.  Examples:

@example
(poke) 16#b / 1#B
2
(poke) 1024#MB / 512#Mb
16
@end example

Dividing offsets is the Pokish way of converting memory magnitudes
between different units: just use units like you do when doing physics
or working with units in other contexts.

@cindex kilobits
For example, using the syntactic trick of omitting the magnitude (in
which case it is assumed to be 1) it is very natural to write
something like the following to convert from kilobits to bytes:

@example
(poke) 24 #Kb/#B
3072
@end example

There is also a ceil-division operator for offsets, with the same
semantics as the ceil-division for integers:

@example
(poke) 10#B /^ 3#B
4
@end example

@subsection Modulus
@cindex modulus
The modulus of two offsets gives you another offset with the expected
semantics.  Examples:

@example
(poke) 9#b % 1#B
1#b
(poke) 1#B % 9#b
8#b
@end example

The unit of the result is the greatest common divisor of the units of
the operands.

@node Offset Attributes
@section Offset Attributes
@cindex attributes, offset
The following attributes are defined for offset values.

@table @code
@item size
Gives an offset with the storage occupied by the offset.  Examples:

@example
(poke) 10#B'size
0x20UL#b
(poke) 10N#B'size
0x4UL#b
@end example
@item magnitude
Gives the magnitude part of the offset.  Examples:

@example
(poke) 10#B'magnitude
10
(poke) 2H#b'magnitude
2H
@end example
@item unit
Gives a number with the unit of the offset, expressed in bits.
Examples:

@example
(poke) 10#B'unit
8UL
(poke) 2H#b'unit
1UL
@end example
@item mapped
Always 0 for offsets.  (@pxref{Mapping}).
@end table


@node Strings
@chapter Strings
@cindex strings

Poke supports a notion of @dfn{strings} which is very similar to the C
programming language: a string value is a sequence of characters that
is terminated by the so-called @dfn{null character}.

The standard library provides functions which process strings.
@xref{String Functions}.

@menu
* String Literals::		Writing string values.
* String Types::		string.
* String Indexing::		Accessing the characters of a string.
* String Concatenation::        Building new strings.
* String Attributes::           Accessing properties of string values.
@end menu

@node String Literals
@section String Literals

NULL-terminated sequences of ASCII codes can be denoted using the
following syntax:

@example
"foo"
@end example

Poke string values are very similar to C strings.  They comprise a
sequence of 8-bit character codes, terminated by the value @code{0UB}.

The following escape sequences are supported inside string literals:

@table @code
@item \n
Denotes a new line character.
@item \t
Denotes an horizontal tab.
@item \\
Denotes a backlash @code{\} character.
@item \"
Denotes a double-quote @code{"} character.
@end table

@node String Types
@section String Types

Every string value in Poke is of type @code{string}.

@node String Indexing
@section String Indexing
@cindex indexing, into strings
Poke supports accessing the characters in a string using the array
indexing notation.  The indexes are in the @code{[0,@var{n}]} range,
where @var{n} is the length of the string minus one.  Note the length
doesn't include the null character, @i{i.e.} it is not possible to access
the terminating null.  Examples:

@example
(poke) "foo"[0]
0x66UB
(poke) "foo"[1]
0x6fUB
@end example

@cindex exceptions
If the passed index is less than zero or it is too big, an
@code{E_out_of_bounds} exception is raised:

@example
(poke) "foo"[-1]
unhandled out of bounds exception
(poke) "foo"[3]
unhandled out of bounds exception
@end example

@node String Concatenation
@section String Concatenation
@cindex concatenation, strings
Strings can be concatenated using the @code{+} operator.  This works
like this:

@example
(poke) "foo" + "bar"
"foobar"
@end example

Note how the null character terminating the first string is removed.
Therefore, the length of the concatenation of two given strings
of lengths @code{N} and @code{M} is always @code{N+M-1}.

Concatenation and indexing are useful together for building strings.
A string can be created empty, and additional characters added to it
by means of concatenation:

@example
(poke) defvar bytes = "";
(poke) bytes = bytes + 'x' as string;
@end example

Then, we can retrieve characters from the string we built using
indexing:

@example
(poke) bytes[0]
0x78UB
@end example

@node String Attributes
@section String Attributes
@cindex attributes, string attributes
The following attributes are defined for string values.

@table @code
@item length
Gives the number of characters composing the string, not counting the
terminating null.  Examples:

@example
(poke) "foo"length
3UL
(poke) ""'length
0UL
@end example

@item size
Gives an offset with the storage occupied by the string.  This
includes the terminating null.  Examples:

@example
(poke) "foo"'size
32UL#b
(poke) ""'size
8UL#b
@end example
@item mapped
Always 0 for strings.  (@pxref{Mapping}).
@end table

@node Arrays
@chapter Arrays
@cindex arrays

Arrays are homogeneous collections of values.

@menu
* Array Literals::		Writing array values.
* Array Types::			Bounded and unbounded arrays.
* Array Indexing::		Accessing values stored in arrays.
* Array Trimming::		Working with array pieces.
* Array Elements::		Checking for array elements.
* Array Attributes::		Accessing properties of array values.
@end menu

@node Array Literals
@section Array Literals

Array literals are constructed using the following syntax:

@example
[@var{exp},@var{exp}@dots{}]
@end example

Where @var{exp} is an arbitrary expression.

For example, @code{[1,2,3]} constructs an array of three signed 32-bit
integers.  Likewise, @code{['a','b','c']} constructs an array of three
unsigned 8-bit integers (characters).

The type of the array literal is inferred from the type of its
elements.  Accordingly, all the elements in an array literal must be
of the same type.  Examples of invalid array literals, that will raise
a compilation-time error if evaluated, are:

@example
[1,2u,3]
[1,0xffff_ffff,3]
['a',"b",'c']
@end example

Array literals must contain at least one element.  Accordingly,
@code{[]} is not a valid array literal.

@cindex matrices
This is how a @code{3x3} matrix could be constructed using an array of
arrays:

@example
[[1,2,3],[4,5,6],[7,8,9]]
@end example

It is possible to refer to specific elements when constructing array
literals.  For example, @code{[1,2,3,.[3] = 4]} denotes the same
array as @code{[1,2,3,4]}.

This allows creating arrays without having to specify all its
elements.  Unspecified elements have the next specified value.  For
example, @code{[.[2] = 2]} denotes the same array as
@code{[2,2,2]}.

Note that an array element can be referenced more than once.  When
that happens, the final value of the element is the last specified.
For example, @code{[1,2,3,.[1]=10]} denotes the array @code{[1,10,3]}.

@node Array Types
@section Array Types

There are three different kind of array types in Poke.

@dfn{Unbounded} arrays have no explicit boundaries.  Examples are
@code{int[]} or @code{Elf64_Shdr[]}.  Arrays can be @dfn{bounded by
number of elements} specifying a Poke expression that evaluates to an
integer value.  For example, @code{int[2]}.  Finally, arrays can be
@dfn{bounded by size} specifying a Poke expression that evaluates to
an offset value.  For example, @code{int[8#B]}.

@subsection Writing unbounded array literals
@cindex unbounded arrays
The type of an array literal is always bounded by number of elements.
For example, the type of @code{[1,2,3]} is @code{int[3]}.  If what we
want is an unbounded array literal we can obtain it with a case like
@code{[1,2,3] as int[]}.

@subsection Array boundaries and closures
@cindex closures
Poke arrays are rather peculiar.  One of their seemingly bizarre
characteristics is the fact that the expressions calculating their
boundaries (when they are bounded) evaluate in their own lexical
environment, which is captured.  In other words: the expressions
denoting the boundaries of Poke arrays conform closures.  Also, the
way they evaluate may be surprising.  This is no capricious.

When an array type is bounded, be it by number of elements or by size,
the expression indicating the boundary doesn't need to be constant and
it can involve variables.  For example, consider the following type
definition:

@example
defvar N = 2;
deftype List = int[N*2];
@end example

@noindent
Let's map a @code{List} at some offset:

@example
(poke) List @@ 0#B
[0x746f6f72,0x303a783a,0x723a303a,0x3a746f6f]
@end example

As expected, we get an array of four integers.  Very good,
obviously the boundary expression @code{N*2} got evaluated
when defining the type @code{List}, and the result of the
evaluation was @code{4}, right?.  Typical semantics like in my
garden variety programming language@dots{}?  Right?!?

Well, not really.  Let's modify the value of @code{N} and map
a @code{List} again@dots{}

@example
(poke) N = 1
(poke) List @@ 0#B
[0x746f6f72,0x303a783a]
@end example


Yes, The boundary of the array type changed@dots{} on, this is Poke,
was you @strong{really} expecting something typical? ;)

What happens is that at type definition time the lexical environment
is captured and a closure is created.  The body of the closure is the
expression.  Every time the type is referred, the closure is
re-evaluated and a new value is computed.

Consequently, if the value of a variable referred in the expression
changes, like in our example, the type itself gets updated
automagically.  Very nice but, why is Poke designed like this?  Just
to impress the cat?  Nope.

In binary formats, and also in protocols, the size of some given data
is often defined in terms of some other data that should be decoded
first.  Consider for example the following definition of a
@code{Packet}:

@example
deftype Packet =
  struct
  @{
    byte size;
    byte[size] payload;
  @};
@end example

Each packet contains a 8-bit integer specifying the size of the
payload transported in the packet.  The payload, a sequence of
@code{size} bytes, follows.

In struct types like the above, the boundaries of arrays depend on
fields that have been decoded before and that exist, like variables,
in the lexical scope captured by the struct type definition (yes,
these are also closures, but that's for another article.)  This
absolutely depends on having the array types evaluate their bounding
expressions when the type is used, and not at type definition time.


@noindent
To show this property in action, let's play a bit:

@example
(poke) defvar data = byte[4] @@ 0#B
(poke) data[0] = 2
(poke) data[1] = 3
(poke) data[2] = 4
(poke) data[3] = 5
(poke) dump
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff
00000000: 0203 0405 0000 0000 0000 0000 0000 0000
00000010: 0000 0000 0000 0000 0000 0000 0000 0000
(poke) defvar p1 = Packet @@ 0#B
(poke) defvar p2 = Packet @@ 1#B
(poke) p1
Packet @{size=0x2UB,payload=[0x3UB,0x4UB]@}
(poke) p2
Packet @{size=0x3UB,payload=[0x4UB,0x5UB,0x0UB]@}
@end example

Now, let's change the data and see how the sizes of the payloads
are adjusted accordingly:

@example
(poke) data[0] = 1
(poke) data[1] = 0
(poke) p1
Packet @{size=0x1UB,payload=[0x0UB]@}
(poke) p2
Packet @{size=0x0UB,payload=[]@}
@end example

So, as we have seen, Poke's way of handling boundaries in array types
allows data structures to adjust to the particular data they contain,
so usual in binary formats.  This is an important feature, that gives
Poke part of its feel and magic.

@node Array Indexing
@section Array Indexing
@cindex indexing, into arrays

Arrays are indexed using the usual notation, providing an index
enclosed between square brackets with @code{[} and @code{]}:

@example
(poke) [1,2,3][0]
1
(poke) [1,2,3][1]
2
@end example

The index should be an expression that evaluates to an integer value,
and it is promoted to an unsigned 64-bit integer when needed.

@cindex exceptions
The valid range for the index is @code{[0,@var{n}]} where @var{n} is
the number of elements stored in the array minus one.  If the passed
integer is out of that range, an @code{E_out_of_bounds} exception is
raised:

@example
(poke) [1,2,3][-1]
unhandled out of bounds exception
(poke) [1,2,3][3]
unhandled out of bounds exception
@end example

@node Array Trimming
@section Array Trimming

Indexing is used to fetch elements from arrays.  Another operation,
called @dfn{trimming}, allows you to extract a subset of the array, as
another array.

Trims use the following notation, where a range is specified between
square brackets.  Both sides of the range are included:

@example
(poke) [1,2,3][0:1]
[1,2]
(poke) [1,2,3][1:1]
[2]
(poke) [1,2,3][0:2]
[1,2,3]
@end example

If the minimum side of the range is omitted, it is assumed to be zero.
If the maximum side of the range is omitted, it is assumed to be the
length of the trimmed array minus one:

@example
(poke) [1,2,3][:1]
[1,2]
(poke) [1,2,3][1:]
[2,3]
(poke) [1,2,3][:]
[1,2,3]
@end example

The elements of the base array and the trimmed sub-array are copied by
shared value, exactly like when passing arguments to functions.  This
means that for simple types, copies of the elements are done:

@example
(poke) defvar a = [1,2,3]
(poke) defvar s = a[1:1]
(poke) s[0] = 66
(poke) a
[1,2,3]
@end example

However, for complex types like arrays and structs, the values are
shared:

@example
(poke) defvar a = Packet[] @@ 0#B
(poke) defvar s = a[1:1]
(poke) s[0].field = 66
(poke) a[1].field
66
@end example

@node Array Elements
@section Array Elements

The @code{in} operator can be used to determine whether a given
element is stored in an array.  Examples:

@example
(poke) 2 in [1,2,3]
1
(poke) 10#B in [2#b,10*8#b,3#b]
1
(poke) 30#B in [2#b,10*8#b,3#b]
0
@end example


@node Array Attributes
@section Array Attributes
@cindex attributes, array attributes
The following attributes are defined for array values.

@table @code
@item size
Gives an offset with the storage occupied by the complete array.
Example:

@example
(poke) [1,2,3]'size
96UL#b
@end example
@item length
Gives the number of elements stored in the array.  Example:

@example
(poke) [1,2,3]'length
3
@end example
@item mapped
Gives 1 if the array is mapped, 0 otherwise.  Examples:

@example
(poke) defvar a = [1,2,3]
(poke) defvar b = int[3] @@ 0#B
(poke) a'mapped
0
(poke) b'mapped
1
@end example
@end table

@node Structs
@chapter Structs
@cindex structs

Structs are the main abstraction that Poke provides to structure data.
They contain heterogeneous collections of values.

@menu
* Struct Literals::		Writing struct values.
* Struct Types::		Simple structs.
* Field Endianness::            Specifying the endianness of integral fields.
* Accessing Fields::            Getting and fetching the values of fields.
* Field Constraints::		Specifying data integrity.
* Field Labels::		Explicit offsets for fields.
* Pinned Structs::		Fix the offset of fields.
* Unions::			Dealing with conditional data.
* Declarations in Structs::	Declaring stuff within a struct.
* Methods::			Declaring functions within a struct.
* Struct Attributes::		Accessing properties of struct values.
@end menu

@node Struct Literals
@section Struct Literals

A struct literal is written like:

@example
struct @{ [[@var{field_name}=]@var{exp},]@dots{} @}
@end example

The contents of the struct literal is a possibly empty set of fields.
Each field has an optional name @var{field_name} and a value
@var{exp}.  The expression for the value can be of any type.

@c XXX document struct constructors once they are supported.

@node Struct Types
@section Struct Types

A simple struct type definition in Poke looks like:

@example
deftype Packet =
  struct
  @{
    byte magic;
    uint<16> length;
    byte[length] data;
  @}
@end example

The above defines a ``Packet'', which consists on a magic number
encoded in a byte, a length encoded in an unsigned 16-bit integer, and
an array of @code{length} bytes, which is the payload of the packet.

Each entry in the struct type above defines a @dfn{struct field}.

Each field has a type, which is mandatory, and a name, which is
optional.  Fields without names are not accessible (not even within
the struct itself) but they are handy for expressing padding.
Example:

@example
deftype Imm64 =
  struct
  @{
    uint<32> lo;
    uint<32>;
    uint<32> hi;
  @}
@end example

It is not allowed to have several fields with the same name in the
same struct.  The compiler will complain if it finds such an
occurrence.

@node Field Endianness
@section Field Endianness

By default fields are accessed in IO space using the current default
endianness.  However, it is possible to annotate integral fields with
an explicit endianness, like in:

@example
deftype Foo =
  struct
  @{
    little int a;
    big int b;
    int c;
  @};
@end example

In the example above, the field @code{a} will be stored using
little-endian, the field @code{b} will be stored using big-endian, and
the field @code{c} will be stored using whatever current endianness.

@node Accessing Fields
@section Accessing Fields

Poke uses the usual dot-notation to provide access to struct fields.
Examples:

@example
(poke) defvar s = struct @{ i = 10, l = 20L @}
(poke) s.i
10
(poke) s.l
20L
@end example

Writing to fields is achieved by having the field reference in the
left side of an assignment statement:

@example
(poke) s.i = 100
(poke) s.l = 200
(poke) s
struct @{i=100,l=200L@}
@end example

@node Field Constraints
@section Field Constraints
@cindex constraints
It is common for struct fields to be constrained to their values to
satisfy some conditions.  Obvious examples are magic numbers, and
specification-derived constraints.

In Poke you can specify a field's constraint using the following
syntax:

@example
@var{field_type} @var{field_name} : @var{expression} ;
@end example

Where @var{expression} is an arbitrary Poke expression, that should
evaluate to an integer value.  The result is interpreted as a boolean.
@cindex ELF
As an example, this is how the ELF magic number is checked for:

@example
deftype Ctf_Preamble =
  struct
  @{
    uint<16> ctp_magic : ctp_magic == CTF_MAGIC;
    byte ctp_version;
    byte ctp_flags;
  @};
@end example

The constraint expression will often include the field where it is
installed, but that's not mandatory.

Field constraints play an important role in mapping.  On one side,
a map will fail if there is some constraint that fails.  On the other,
they guide the mapping of unbounded arrays.  @xref{Mapping Arrays}.

Another common usage of constraint expressions is to alter the global
state after decoding a field.  For example, this is how mapping an ELF
header sets the current endianness, depending on the value of
@code{ei_data}:

@example
byte ei_data : ei_data == ELFDATA2LSB       \
               ? set_endian (ENDIAN_LITTLE) \
               : set_endian (BIG);
@end example

Note that @code{set_endian} always returns @code{1}.

@node Field Labels
@section Field Labels

In structs, each field is associated with an offset, which is relative
to the beginning of the struct.  This is the offset used when reading
and writing the field from/to the IO space when mapping.

The offset is reset to zero bits at the beginning of the struct type,
and it is increased by the size of the fields:

@example
struct
@{
                /* Offset: 0#b */
    uint<1> f1; /* Offset: 1#b */
    sint<7> f2; /* Offset: 1#B */
    int     f3; /* Offset: 5#B */
    Bar     f4; /* Offset: 23#B */
@}
@end example

It is possible to specify an alternative offset for a field using a
@dfn{field label}.

Consider for example an entry in an ELF symbol table.  Each entry has
a @code{st_info} field which is 64-bits long, that in turn can be
interpreted as two fields @code{st_bind} and @code{st_type}.

The obvious solution is to encode @code{st_info} as a sub-struct, like
this:

@example
struct
@{
  elf32_word st_name;
  struct
  @{
    uint<60> st_bind;
    uint<4> st_type;
  @} st_info;
@}
@end example

However, that makes it inconvenient to access the value of
@code{st_info} as an integral value, using the bit-concatenation
operator @code{symbol.st_info.st_bind::symbol.st_info.st_type}.  We
can use labels instead:

@example
struct
@{
  elf32_word st_name;
  elf64_word st_info;
  uint<60> st_bind @ 4#B;
  uint<4> st_type @ 4#B + 60#b;
@}
@end example

The resulting struct has fields @code{st_info}, @code{st_bind} and
@code{st_type}, with the last two overlapping the first.

@node Pinned Structs
@section Pinned Structs
@cindex pinned structs
Pinned structs is a convenient way to write struct types where the
offset of all its fields is zero.  They are equivalent to C unions.

For example, consider the @code{_u} field below in a CTF type
description:

@example
deftype Ctf_Stype_V1 =
  struct
  @{
    Ctf_Name ctt_name;
    Ctf_Info_V1 ctt_info;
    pinned struct
    @{
      uint32 _size;		/* Size of entire type in bytes.  */
      uint32 _type;		/* Reference to another type.  */
    @} _u;
  @};
@end example

@node Unions
@section Unions
@cindex unions
XXX

@node Declarations in Structs
@section Declarations in Structs

XXX

@node Methods
@section Methods

XXX

@node Struct Attributes
@section Struct Attributes
@cindex attributes, struct attributes
XXX

@node Types
@chapter Types
@cindex types

@menu
* deftype::			Naming types.
* The any Type::		Polymorphism.
* The isa Operator::		Testing for types of values.
@end menu

@node deftype
@section @code{deftype}
@cindex @code{deftype}
The @code{deftype} directive allows you to declare named types.  The
syntax is:

@example
deftype @var{name} = @var{type};
@end example

Where @var{name} is the name of the new type, and @var{type} is either
a type specifier or the name of some other type.

The supported type specifiers are:

@table @code
@item int<@var{n}>, uint<@var{n}>
Integral types. @xref{Integer Types}.
@item string
The string type.  @xref{String Types}.
@item @var{type}[@var{boundary}]
Array types.  @xref{Array Types}.
@item struct @{ @dots{} @}
Struct types.  @xref{Struct Types}.
@item (@var{type},@dots{})@var{type}:
Function types.  @xref{Function Types}.
@item any
The @code{any} type is used to implement polymorphism.  @xref{The any Type}.
@cindex any, the @code{any} type
@end table

@node The any Type
@section The @code{any} Type
@cindex any, the @code{any} type
@cindex polymorphism
Poke supports polymorphism with the @code{any} type.  This type is
used in contexts where a value of any type is allowed.  For example,
this is how you would declare a function that prints the size of any
given value:

@example
defun print_size = (any value) void:
@{
  printf "%v\n", any'size;
@}
@end example

The rules for handling @code{any} values are simple:
@itemize @minus
@item Everything coerces to @code{any}.
@item Nothing coerces from @code{any}.
@end itemize

This means that using any operator that require certain types with
@code{any} values will fail: you have to cast them first.  Example:

@example
(poke) defun foo = (any v) int: @{ return v as int; @}
@end example

Arrays of @code{any}, @code{any[]}, are also supported:

@node The isa Operator
@section The @code{isa} Operator
@cindex isa operator
The binary operator @code{isa} allows you to check for the type of a given
value:

@example
(poke) 10 isa int
1
(poke) "foo" isa string
1
(poke) (Packet @ 0#B) isa Packet
1
(poke) 2 as int<3> isa uint<4>
0
@end example


@node Assignments
@chapter Assignments
@cindex assignment
The assignment statement has the form:

@example
@var{lvalue} = @var{exp};
@end example

Where @var{lvalue} is either:

@itemize @bullet
@item A variable.
@item A field reference like @code{foo.bar}.
@item An index reference like @code{foo[30]}
@item A map of a simple type, like @code{int @@ 0#B}.
@end itemize

In all cases, the type of @var{exp} should match the type of the
referred entity.

Examples:

@example
(poke) foo = 10
(poke) packet.length = 4
(poke) packet.data = [1,2,3,4]
(poke) packet.data[2] = 666
(poke) int @ 23#B = 23
(poke) string @ str.offset = "foo"
@end example

@node Compound Statements
@chapter Compound Statements
@cindex compound statements
@cindex statements, compound statements
Compound statements have the form:

@example
@{ @var{stmt@dots{}} @}
@end example

Where @var{stmt@dots{}} is a list of statements, which can be themselves
compound statements.  Compound statements are primarily used to
sequence instructions like:

@example
@{
  do_a;
  do_b;
  do_c;
@}
@end example

A compound statement introduces a new lexical scope.  Declarations in
the compound statements are local to that statement.

Finally, compound statements can be empty: @code{@{ @}}.

@node Conditionals
@chapter Conditionals


Poke provides several conditional statements, which are discussed in
the sections below.

@menu
* if-else::			Simple conditionals.
@end menu

@node if-else
@section @code{if-else}
@cindex conditional statements
The @code{if-else} statement has the form:

@example
if @var{exp} @var{if_stmt} [else @var{else_stmt}]
@end example

Where @var{exp} is an expression that should evaluate to a boolean
value (@i{i.e.} to an integer), @var{if_stmt} is a sentence that will be
executed if @var{exp} holds true, and @var{else_stmt} is a sentence
that will be executed if @var{exp} holds false.  The @code{else} part
of the sentence is optional.


@node Loops
@chapter Loops
@cindex loops
@cindex flow control
Poke supports several iteration statements, which are discussed in the
sections below.

@menu
* while::		Iterate while a condition holds true.
* for-in::		Iterate over the elements of a container.
@end menu

@node while
@section @code{while}
@cindex @code{while}
The @code{while} statement has this form:

@example
while (@var{exp}) @var{stmt}
@end example

Where @var{exp} is an expression that should evaluate to a boolean
(@i{i.e.} to an integer) and @var{stmt} is an statement that will be
executed until @var{exp} holds false.

@cindex @code{break}
It is possible to leave the loop from within @var{stmt} using the
@code{break} statement.  Example:

@example
while (1)
@{
  [@dots{}]
  if (exit_loop)
    break;
@}
@end example

@node for-in
@section @code{for-in}
@cindex @code{for-in}
The @code{for-in} statement has this form:

@example
for (@var{formal} in @var{container} [where @var{exp}]) @var{stmt}
@end example

Where, in each iteration, the name @var{formal} will be associated
with consecutive values of @var{container}, which shall be an
expression evaluating to an array or a string.  @var{formal} is
available in @var{stmt}, which is the sentence executed in each
iteration.

If the @var{where} part is specified, then only iteration in which
@var{exp} holds true are processed.  @var{formal} can be referred in
@var{exp}.  Note that this doesn't mean the loop will stop after
processing the first ``not selected'' element.  See the following
example:

@example
(poke) for (c in [1,2,3,4] where c % 2) printf " %v", c
 1 3
@end example

@cindex @code{break}
It is possible to leave the loop from within @var{stmt} using the
@code{break} statement.


@node Expression Statements
@chapter Expression Statements

@cindex side effects
Poke is one of these languages where there is a clear separation
between @dfn{expressions} and @dfn{statements}.  However, it is often
useful to use an expression in the place of an statement, in order to
benefit from its side effects.

For that purpose Poke allows you to expressions as statements using
the following syntax:

@example
@var{exp};
@end example

The value computed by the expression will be discarded.

@node Functions
@chapter Functions
@cindex functions
@c XXX closures

@menu
* Function Declarations::	Writing functions.
* Optional Arguments::		Default values for arguments.
* Variadic Functions::		Functions taking any number of arguments.
* Calling Functions::		Invoking functions.
* Function Types::		Useful for defining interfaces.
@end menu

@node Function Declarations
@section Function Declarations
@cindex declarations, function declarations
A function is declared using the following syntax:
@cindex @code{defun}

@example
defun @var{name} = [(@var{formal},@dots{})] @var{ret_type}:
@{
   @dots{} body @dots{}
@}
@end example

Where @var{name} is the name of the function, which uses the same
namespace as variables and types and @var{ret_type} is the type of
the value returned by the function.  If the function returns no value
then it is @code{void}.

Each @var{formal} argument has the form:

@example
@var{type} @var{name} [= @var{exp}]
@end example

Where @var{type} is the type of the formal, @var{name} its name, and
@var{exp} is an optional expression that will be used to initialize
the argument in case it is not specified when the function is called.

The last formal argument can take the form @code{@var{name}@dots{}},
meaning the function is variadic.  @xref{Variadic Functions}.

If the function takes no arguments, it is possible to omit the list of
arguments entirely:

@example
defun hello = void: @{ print "Hello!\n"; @}
@end example

The @code{return} statement is used to return values in functions that
return a value.  Example:

@example
defun gcd = (uint<64> a, uint<64> b) uint<64>:
  @{
   if (b == 0)
     return a;
   else
     return gcd (b, a % b);
  @}
@end example

Note that reaching the end of a non-void function will trigger a
run-time error.

@node Optional Arguments
@section Optional Arguments
@cindex arguments
Optional function arguments are specified like:

@example
defun atoi = (string s, int b = 10) long: @{ @dots{} @}
@end example

Which means that if the base argument is not specified when passed to
@code{atoi} then it is initialized to 10.

Optional arguments should not appear before any non-optional argument
in function declarations.  The following is not valid Poke:

@example
defun foo = (int i = 10, int j) int: @{ return i + j; @}
@end example

Note that arguments declared before an optional argument can be used
in its initialization expression.  This is valid Poke:

@example
defun foo = (int n, int[n] array = init_array (n)) void: @{ @dots{} @}
@end example

@node Variadic Functions
@section Variadic Functions
@cindex variadic functions
Functions getting an arbitrary number of arguments are denoted like
this:

@example
defun printf (string fmt, args@dots{}) void: @{ @dots{} @}
@end example

The variadic argument shall be the last argument in the function, and
it is of type @code{any[]}.

@node Calling Functions
@section Calling Functions
@cindex calling, function calls
To call a function, write its name followed by the arguments in
parenthesis.  Examples:

@example
foo (1,2,3)
bar ()
@end example

If the function takes no arguments then it is not necessary to write
the empty list of arguments.  Therefore the following two calls are
equivalent:

@example
bar ()
bar
@end example

There is an alternate syntax that can only be used in an
expression-as-statement context.  This alternate syntax is:

@example
@var{function_name} :@var{arg1} @var{val1}@dots{}
@end example

Where @var{arg1} is the name of an argument and @var{val1} the value
to pass for that argument.  This is useful to use functions as
commands in the REPL:

@cindex dump
@example
(poke) dump :from 12#B :size 16#B :ascii 0
@end example

Note that the named arguments can appear in any order.  The following
two calls are equivalent:

@example
dump :from 12#B :size 16#B
dump :size 16#B :from 12#B
@end example

@node Function Types
@section Function Types
@cindex function types
@cindex types, function types
Function types are denoted like:

@example
(@var{type},@dots{})@var{ret_type}:
@end example

Where @var{type} are the types of the arguments and @var{ret_type} is
the type of the value returned by the function.

Optional arguments are marked with a @code{?} after the type.  For
example, the type of the @code{atoi} function with declaration:

@example
defun atoi = (string s, int b = 10) long: @{ @dots{} @}
@end example

is @code{(string,int?)long:}.

If the function has variadic arguments, the position of the variadic
argument in the function type specifier contains @code{@dots{}}.  For
example, the type of a @code{printf} function with declaration:

@example
defun printf (string fmt, args@dots{}) void: @{ @dots{} @}
@end example

is @code{(string,@dots{})void:}.

@node Endianness
@chapter Endianness
@cindex endianness

Byte endianness is an important aspect of encoding data.  As a good
binary editor poke provides support for both little and big endian,
and will soon acquire the ability to encode exotic endianness like PDP
endian.  Endianness control is integrated in the Poke language, and is
designed to be easily used in type descriptions.

@menu
* set endian::			dot-command to get and set the endianness.
* Endian in Fields::		setting the endianness of struct fields.
* Endian built-ins::		changing endianness programmatically.
@end menu

@node set endian
@section @code{.set endian}
@cindex endianness

GNU poke maintains a global variable that holds the current
endianness.  This is the endianness that will be used when mapping
integers whose types do not specify an explicit endianness.

Like other poke global state, this global variable can be
modified using the @command{.set} dot-command:

@example
.set endian little
.set endian big
.set endian host
@end example

@noindent
The current endianness can be obtained like this:

@example
(poke) .set endian
little
@end example

We can easily see how changing the current endianness indeed impacts
the way integers are mapped:

@example
(poke) dump :from 0#B :size 4#B :ruler 0 :ascii 0
00000000: 8845 4c46
(poke) .set endian little
(poke) int @@ 0#B
0x464c4588
(poke) .set endian big
(poke) int @@ 0#B
0x88454c46
@end example

@node Endian in Fields
@section Endian in Fields

It is possible to set the endianness of integral fields in struct type
descriptors.  @xref{Field Endianness}.

@node Endian built-ins
@section Endian built-ins

As handy as the @command {.set endian} dot-command may be, it is also
important to be able to change the current endianness programmatically
from a Poke program.  For that purpose, the PKL compiler provides a
couple of built-in functions: @code{get_endian} and @code{set_endian}.

Their definitions, along with the specific supported values, look
like:

@example
defvar ENDIAN_LITTLE = 0;
defvar ENDIAN_BIG = 1;

defun get_endian = int: @{ @dots{} @}
defun set_endian = (int endian) int: @{ @dots{} @}
@end example

Accessing the current endianness programmatically is especially useful
in situations where the data being poked features a different
structure, depending on the endianness.

@cindex eBPF
A good (or bad) example of this is the way registers are encoded in
eBPF instructions.  eBPF is the in-kernel virtual machine of Linux,
and features an ISA with ten general-purpose registers.  eBPF
instructions generally use two registers, namely the source register
and the destination register.  Each register is encoded using 4 bits,
and the fields encoding registers are consecutive in the instructions.

Typical.  However, for reasons we won't be discussing here the order
of the source and destination register fields is switched depending on
the endianness.

@noindent
In big-endian systems the order is:

@example
dst:4 src:4
@end example

@noindent
Whereas in little-endian systems the order is:

@example
src:4 dst:4
@end example

In Poke, the obvious way of representing data whose structure depends
on some condition is using an union.  In this case, it could read like
this:

@example
deftype BPF_Insn_Regs =
  union
  @{
    struct
    @{
      BPF_Reg src;
      BPF_Reg dst;
    @} le : get_endian == ENDIAN_LITTLE;

    struct
    @{
      BPF_Reg dst;
      BPF_Reg src;
    @} be;
  @};
@end example

Note the call to the @code{get_endian} function (which takes no
arguments and thus can be called Algol68-style, without specifying an
empty argument list) in the constraint of the union alternative.  This
way, the register fields will have the right order corresponding to
the current endianness.

Nifty.  However, there is an ever better way to denote the
structure of these fields.  This is it:

@example
deftype BPF_Insn_Regs =
  struct
  @{
    defvar little_p = (get_endian == ENDIAN_LITTLE);

    BPF_Reg src @@ !little_p * 4#b;
    BPF_Reg dst @@ little_p * 4#b;
  @};
@end example

This version, where the ordering of the fields is implemented using
field labels, is not only more compact, but also has the virtue of not
requiring additional "intermediate" fields like @code{le} and
@code{be} above.  It also shows how convenient can be to declare
variables inside structs.

@noindent
Let's see it in action:

@example
(poke) BPF_Insn_Regs @@ 1#B
BPF_Insn_Regs @{src=#<%r4>,dst=#<%r5>@}
(poke) .set endian big
(poke) BPF_Insn_Regs @@ 1#B
BPF_Insn_Regs @{src=#<%r5>,dst=#<%r4>@}
@end example

Changing the current endianness in constraint expressions is useful
when dealing with binary formats that specify the endianness of the
data that follows using some sort of tag.  This is the case of ELF,
for example.
@cindex ELF
The first few bytes in an ELF header conform what is known as the
@code{e_ident}.  One of these bytes is called @code{ei_data} and its
value specifies the endianness of the data stored in the ELF file.

@noindent
This is how we handle this in Poke:

@example
defun elf_endian = (int endian) byte:
 @{
   if (endian == ENDIAN_LITTLE)
     return ELFDATA2LSB;
   else
     return ELFDAT2MSB;
 @}

[@dots{}]

deftype Elf64_Ehdr =
  struct
  @{
    struct
    @{
      byte[4] ei_mag : ei_mag[0] == 0x7fUB
                       && ei_mag[1] == 'E'
                       && ei_mag[2] == 'L'
                       && ei_mag[3] == 'F';
      byte ei_class;
      byte ei_data : (ei_data != ELFDATANONE
                      && set_endian (elf_endian (ei_data)));
      byte ei_version;
      byte ei_osabi;
      byte ei_abiversion;
      byte[6] ei_pad;
      offset<byte,B> ei_nident;
    @} e_ident;

    [@dots{}]
  @};
@end example

Note how @code{set_endian} returns an integer value@dots{}  it is always
@code{1}. This is to facilitate its usage in fields constraint
expressions.

@node Mapping
@chapter Mapping
@cindex mapping
The purpose of poke is to edit @dfn{IO spaces}, which are the files or
devices, or memory areas being edited.  This is achieved by mapping
values.  Mapping is perhaps the most important concept in Poke.

@menu
* IO Spaces::			The underlying entities being edited.
* The Map Operator::		The @@ operator.
* Mapping Simple Types::	Mapping integers, offsets and strings.
* Mapping Structs::		Mapping collections of fields.
* Mapping Arrays::		Mapping sequences of things.
* Unmapping::			From mapped values to regular values.
@end menu

@node IO Spaces
@section IO Spaces
@cindex IO space

GNU poke supports the abstract notion of @dfn{IO space}, which is an
addressable space of Poke objects: integers, strings, arrays, structs,
@i{etc}.  This underlying storage for the IO spaces (which we call @dfn{IO
devices}) can be heterogeneous: from a file your file system to the
memory of some process.

@menu
* open::			Creating IO spaces.
* close::			Destroying IO spaces.
* get_ios::			Getting the current IO space.
* set_ios::			Setting the current IO space.
@end menu

@node open
@subsection @code{open}
@cindex opening files
@cindex IO space
The @code{open} builtin allows you to create new IO spaces, by opening an
IO device.  It has the following prototype:

@example
defun open = (string @var{handler}) int<32>: @{ @dots{} @}
@end example

Where @var{handler} is a string identifying the IO device that will
serve the IO space.  This handler can be:

@table @code
@item file://path/to/file
@itemx /path/to/file
An either absolute or relative path to a file.  Both syntaxes are allowed.
@item pid://[0-9]+
The process ID of some process.
@end table

The @code{open} builtin returns a signed 32-bit integer.  This number
will identify the just opened IOS until it gets closed.

If there is a problem opening the specified IO device then @code{open}
will raise an @code{E_no_ios} exception.

@node close
@subsection @code{close}
@cindex @code{close}

The @code{close} builtin allows you to destroy IO spaces, closing the
underlying IO device.  The prototype is:

@example
defun close = (int<32> @var{ios}) void: @{ @dots{} @}
@end example

Where @var{ios} is some previously created IO space.  All pending data
is written to the underlying IO device.

If the IO space specified to @code{close} doesn't exist then an
@code{E_no_ios} exception is raised.

@node get_ios
@subsection @code{get_ios}
@cindex @code{get_ios}

GNU poke maintains a @dfn{current IO space}, which is the last created
IO space (this includes IO spaces opened and selected using a
dot-command).  The builtin @code{get_ios} returns this space.  It has
the following prototype:

@example
defun get_ios = int<32>: @{ @dots{} @}
@end example

If there is no IO space, @code{get_ios} will raise the @code{E_no_ios}
exception.

@node set_ios
@subsection @code{set_ios}
@cindex @code{set_ios}

The @code{set_ios} builtin allows you to set a specific IO space as the
new current IO space.  It has the following prototype:

@example
defun set_ios = (int<32> @var{ios}) int<32>: @{ @dots{} @}
@end example

Where @var{ios} is the IO space that will become the current IO
space.  If the IO space specified to @code{set_ios} doesn't exist,
@code{E_no_ios} will be raised.

Note that @code{set_ios} always returns @code{1}.  This is to ease its
usage in struct fields constraint expressions.

@node The Map Operator
@section The Map Operator
@cindex mapping
Poke values reside in memory, and their in-memory representation is
not visible from Poke programs.  For example, @code{32} is a 32-bit
signed integer value, and it happens to not be boxed in the Poke
Virtual Machine.  Therefore, it occupies exactly 32-bit in the memory
of the machine running poke.  Other values, like arrays for example,
are boxed, and they need to store various meta-data.

Regardless of the internal representation, we say these values live
``in memory''.  Now, it is also possible to ``map'' a value to some
area in some underlying IO space.  This is done with the map operator
@code{@@}, which has two alternate syntax:

@example
@var{type} @@ @var{offset}
@var{type} @@ @var{ios} : @var{offset}
@end example

The ternary version creates a new value using the data located at the
offset @var{offset} in the specified IO space @var{ios}, which shall
be an expression evaluating to a signed 32-bit integer.

The binary version uses the current IO space.

If there is no IO space, or the specified IO space doesn't exist, an
@code{E_no_ios} exception is raised:

@example
(poke) int @@ 0#B
unhandled no IOS exception
@end example

The value created in a map can be either mapped or not mapped.
Mapping simple types produces not mapped values, whereas mapping
non-simple types create mapped values.

The value attributes @code{mapped} and @code{offset} can be used to
check whether a value is mapped or not, and in that case the offset
where it is mapped:

@example
(poke) defvar p = Packet @@ 0#B
(poke) p'mapped
0x1
(poke) p'offset
0x0UL#b
@end example

Using the @code{offset} attribute in a not mapped value results in the
@code{E_no_map} exception being raised:

@example
(poke) [1,2,3]'mapped
0x0
(poke) [1,2,3]'offset
unhandled no map exception
@end example

If the type specified in the map is not a simple type, like an array
or a struct, the resulting value is said to be mapped in the IO
space:

@example
(poke) deftype Packet = struct @{ int i; long l; @}
(poke) Packet @@ 0#B
Packet @{i=0x464c457f,l=0x10102L@}
(poke) uint<8>[2] @@ 0#B
[0x7fUB,0x45UB]
@end example

A very important idea on Poke mapping is that it should be possible to
manipulate mapped and non-mapped values in a transparent way.  For
example, consider the quick sort implementation in poke's standard
library.  The prototype is:

@example
defun qsort = (any[] array, Comparator cmp_f,
               long left = 0, long right = array'length - 1) void:
@end example

@noindent
@code{qsort} works with both mapped and not-mapped arrays:

@example
(poke) defvar a = [2,3,1]
(poke) defvar b = int[3] @@ 0#B
(poke) b
[1179403647,65794,0]
(poke) qsort (a, IntComparator)
(poke) a
[1,2,3]
(poke) qsort (b, IntComparator)
(poke) b
[0,33620224,1179403647]
(poke) dump :from b'offset :size b'size :ascii 0
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff
00000000: 0000 0000 0001 0102 7f45 4c46
@end example

Similarly, you can write functions that operate on abstract
entities and data structures such as ELF relocations and sections,
DWARF DIEs, @i{etc}, and the same code will work with non mapped and
mapped values.

@node Mapping Simple Types
@section Mapping Simple Types

Simple values (@i{i.e.} integers, offsets, strings) cannot be mapped.
Therefore, if the type specified in the map is a simple type, the
resulting value will be a regular non-mapped value.  Examples:

@example
(poke) uint<8> @@ 0#B
0x7fUB
(poke) string @@ 0#B
"ELF"
@end example

@node Mapping Structs
@section Mapping Structs

XXX

@node Mapping Arrays
@section Mapping Arrays

Arrays can be mapped in IO space in three different ways, depending on
the characteristics of the type provided to the mapping operator.

@subsection Array maps bounded by number of elements
When an array type bounded by number of elements is used in a mapping
operation, the resulting mapped array is also bounded by number of
elements.

For example, this is how we would map an array of four 32-bit signed
integers in the current IO space:

@example
(poke) int[4] @@ 0#B
[10,20,30,40]
@end example

Since you can also provide a dynamic array type to the map operator,
the number of elements doesn't need to be constant.  For example,
given the variable @code{nelems} has a value of @code{2}:

@example
(poke) defvar nelems = 2
(poke) int[nelems + 1] @@ 0#B
[100,222,333]
@end example

If an end-of-file condition happens while mapping the array, because
the number of elements specified in the array type, at the given
offset, exceeds the capacity of the underlying IO device, an exception
is raised and the mapping is not completed:

@example
(poke) int[99999999999] @@ 0#B
unhandled EOF exception
@end example

Likewise, if a constraint fails while performing the mapping (while
mapping an array of structs, for example) an exception is raised and
the map is aborted.

@subsection Array maps bounded by size

While dealing with binary formats, it often happens that the number of
entities in a collection is given by the space they occupy, rather
than the count itself.

For example, consider ELF sections holding relocations.  These
sections contain a collection of zero or more relocations. The layout
of each relocation is specified by the following type:

@example
deftype Elf64_Rela =
  struct
  @{
    offset<Elf64_Addr,B> r_offset;
    Elf64_Xword r_info;
    Elf64_Sxword r_addend;
  @};
@end example

The section is described by an entry in the ELF sections header table:

@example
deftype Elf64_Shdr =
  struct
  @{
    Elf_Word sh_name;
    Elf_Word sh_type;
    Elf64_Xword sh_flags;
    Elf64_Addr sh_addr;
    Elf64_Off sh_offset;
    offset<Elf64_Xword,B> sh_size;
    Elf_Word sh_link;
    Elf_Word sh_info;
    Elf64_Xword sh_addralign;
    offset<Elf64_Xword,b> sh_entsize;
  @};
@end example

The relevant elements of @code{Elf64_Shdr} are @code{sh_offset} and
@code{sh_size}, which indicate the offset of the beginning of the
section's contents, and its size, respectively.  At this point, if we
wanted to get an array with all the relocations in the section, we
could map an array bounded by number of elements like we saw in the
previous section, like this:

@example
(poke) Elf64_Rela[sh_size / 1#Elf64_Rela]
[@dots{} relocs @dots{}]
@end example

However, this approach adoleces from two problems.  First, it doesn't
work with any entity type.  For an offset like @code{1#Elf64_Rela} to
work, it is required to know the size of the type specified as the
unit at compile time.  In the particular case of @code{Elf64_Rela},
that condition is satisfied, but too often that's not the case.  For
example, think about a section containing @code{NULL} terminated
strings: you can't know the number of strings contained in the section
until you actually read it.

Another problem is when the data in the header is corrupt.  Using
the mapping bounded by number of elements, we wouldn't realize it.  It
would be good if the tool would tell us whether the specified size
actually holds an exact number of the requested elements.

A mapping bound by size is what we need.  Fortunately, as we saw when
discussing array types, Poke allows you to specify an offset instead of an
integral value, in the array type specification.  The right amount of
entities (in this case relocations) to strictly satisfy the provided
size will be mapped in the IO space.  So, in order to obtain an array
containing all the relocations in the section, we simply write:

@example
(poke) Elf64_Rela[ehdr.sh_size] @@ ehdr.sh_offset
[@dots{} relocs @dots{}]
@end example

The strictness mentioned above is important.  GNU poke will complain
(and abort the mapping) if it is not possible to map an exact number
of elements.  Thus the following mapping would not be successful:

@example
(poke) int[33#b] @@ 0#B
unhandled out of map bounds exception
@end example

Like in mappings bounded by number of elements, if a constraint fails
while performing the mapping, an exception is raised and the map is
aborted.

@subsection Unbounded array maps

We mentioned above that if an end-of-file condition happens while
performing a mapping (be it bounded by number of elements or bounded
by size) an EOF exception is raised, and the mapping operation is
aborted.

Unbounded array mappings are performed by using an unbounded array
type in the mapping operation, like in:

@example
@var{type}[] @@ 0#B
@end example

The above construction will map values of type @var{type} in the IO
space until there is an end-of-file condition, or a constraint fails,
whatever happens first.  When it is a constraint expression that
fails, that last element is not included in the mapped array.

Let's assume a binary file contains a series of blocks, located one
after the other, of a kind described by the following struct type:

@example
deftype Block =
  struct
  @{
     byte magic[2] : magic[0] == 'B' && magic[1] == 'K';
     @dots{} other data @dots{}
  @};
@end example

we can map the blocks using an unbounded array map:

@example
(poke) Block[] @@ 0#B
[ @dots{} blocks @dots{} ]
@end example

If the blocks extend up to the end of the IO space, that many blocks
will be mapped.  If there is some other content in the file following
the blocks, the constraint in the @code{magic} field will fail and
will delimit the map that way (provided the binary format is well
designed.)

@subsection Mapped bounds in bounded arrays

When an array map is bounded, be it by number of elements or by size,
the bounding value can be mapped itself.  To illustrate how this
works, let's go back to our ELF file and the section containing
relocations.  First, we map an @code{Elf64_Shdr} to get the section
header:

@example
(poke) defvar shdr = Elf64_Shdr @@ @var{offset}
(poke) shdr.sh_offset
120#B
(poke) shdr.sh_size
24#B
@end example

Now we map an array with the relocations themselves, using a map
bounded by size, as we learned in the last section:

@example
(poke) defvar relocs = ELF64_Rela[shdr.sh_size] @@ shdr.sh_offset
(poke) relocs'length
3
@end example

Now, observe that @code{shdr.sh_size} is mapped itself!  This means
that, should the section size be modified (to accommodate an extra
relocation, for example) the mapping of @code{relocs} will reflect
that automatically:

@example
(poke) shdr.sh_size = shdr.sh_size + 1#Elf64_Rela
(poke) relocs'length
4
@end example

This is certainly an useful idiom, that is often used while poking
around.  However, sometimes this is @emph{not} what we want.  If we
don't want the mapping bounds of @code{relocs} to be tied to
@code{shdr}, we can just use a temporary for the size:

@example
(poke) defvar s = shdr.sh_size
(poke) defvar relocs = Elf64_Rela[s] @@ shdr.sh_offset
@end example

Since simple values (such as the size above) are not mapped, this
trick works as intended.

@node Unmapping
@section Unmapping
@cindex unmap

The unary @code{unmap} operator has the form:

@example
unmap @var{value}
@end example

It gets any value and produces the same value, making it not mapped in
case it is a mapped value.

This is useful when we want to read a data structure from the IO space
(say, an array of integers) and then use it for storage without
changing the underlying IO space.  We would do something like:

@example
(poke) defvar a = unmap (int[1] @@ 10#B)
(poke) a[2] = 100
@end example

@node Exception Handling
@chapter Exception Handling
@cindex exceptions

Sometimes an error or some other unexpected situation arises.  Poke
provides an exceptions mechanism to deal with these situations.

@menu
* Exceptions::		List of supported exception types.
* try-catch::		Catching exceptions in programs.
* try-until::		Running code until some exception occurs.
* raise::		Raising exceptions in programs.
@end menu

@node Exceptions
@section Exceptions

Exceptions in Poke are just integers.  You can use values @code{255}
and higher for your own exceptions.

The range @code{0..254} is reserved for poke, and the following values
have specific meanings:

@table @code
@item E_generic
Generic error.
@item E_out_of_bounds
Out of bounds exception.  This can be raised when accessing
containers, like arrays and strings.
@item E_eof
End of file exception.  This can be raised when mapping in the IO
space.
@item E_elem
Invalid element exception.  This is can be raised when accessing union
fields that do not exist.
@item E_constraint
Constraint violation exception.  This is raised when a constraint
exception fails while mapping or constructing a struct.
@item E_conv
Conversion exception.  This can be raised while casting values.
@item E_map_bounds
Out of map bounds exception.  This can be raised while modifying a
mapped value in a way it would violate its declared boundary (like the
size of a mapped array.)
@item E_map
No map exception.  This is raised when trying to map a not mapped
value.
@item E_div_by_zero
Division by zero exception.
@item E_no_ios
No IOS exception.  This is raised when the IO space is accessed but
there is no IO space.
@item E_no_return
No return exception.  This is raised when the end of a void function
is reached.
@item E_io
Generic IO exception.
@end table

@node try-catch
@section @code{try-catch}
@cindex @code{try-catch}
The @code{try-catch} statement provides a way to catch exceptions and
handle them.

The simplest form of the statement is:

@example
try @var{stmt} catch @var{compound_stmt}
@end example

Where @var{stmt} is any statement and @var{compound_stmt} is a
compound statement.  @var{stmt} is executed.  If during its execution
an exception is raised, then @var{compound_stmt} gets executed.

The second form of the statement allows you to catch just one type of
exceptions:

@example
try @var{stmt} catch if @var{exp} @var{compound_stmt}
@end example

Where @var{exp} is an expression that should evaluate to an integer.
This integer is interpreted as an exception type.  The handler
@var{compound_stmt} will only be executed if that specific exception
is caught.  Any other exception will be re-raised.

The third form of the statement is the most generic:

@example
try @var{stmt} catch (Exception @var{formal}) @var{compound_stmt}
@end example

Where @var{formal} is a formal argument that contains the exception
type when @var{compound_stmt} is executed.

@node try-until
@section @code{try-until}
@cindex @code{try-until}
The @code{try-until} statement allows you to execute instructions until
some exception is caught.  The syntax is:

@example
try @var{stmt} until @var{exp}
@end example

Where @var{stmt} is the statement that will be executed repeatedly
until some exception is raised.  If the raised exception has type
@var{exp} then execution continues normally.  @var{exp} should be an
expression that evaluates to a signed integer.

This statement is particularly useful for mapping IO spaces until an
@code{eof} condition occurs.  For example, this is how we would
compute with every integer in the current IO space:

@example
defvar o = 0#B;
try
@{
  compute (int @ o);
  o = o + 1#B;
@} until E_eof;
@end example

@node raise
@section @code{raise}
@cindex @code{raise}
In previous sections we saw how exceptions are usually the
side-product of performing certain operations.  For example, a
division by zero.

However, it is also useful to explicitly raise exceptions.  The
@code{raise} statement can be used for that purpose.  Its syntax is:

@example
raise @var{exception};
@end example

Where @var{exception} is an integer.  This integer can be any number,
but most often is one of the @code{E_*} codes defined in Poke.

@node Printing
@chapter Printing

Poke programs can print text to the standard output in two ways:
simple unformatted output, and formatted output.

@menu
* print::			simple output.
* printf::			formatted output.
* Pretty Printers::		improve the legibility of your data structures.
@end menu

@node print
@section @code{print}
@cindex @code{print}
@cindex output

The @code{print} statement prints the given string to the standard
output.  @code{print} outputs text strings verbatim.  It can be
invoked using two alternative syntaxes, which are equivalent:

@example
print (@var{str});
print @var{str};
@end example

@code{print} is simple, but fast.  It is good to use it in simple
cases where the information to print out doesn't require any kind of
formatting and styling.

@node printf
@section @code{printf}
@cindex @code{printf}
@cindex formatted output

The @code{printf} statement gets a format string and, optionally, a
list of values to print.  It can be invoked using two alternative
syntaxes, which are equivalent:

@example
printf (@var{fmt}[, @var{value}@dots{}])
printf @var{fmt}[, @var{value}@dots{}]
@end example

The format string @var{fmt} is printed verbatim to the standard
output, but for @dfn{format tags} which start with @code{%}.  These
format tags are interpreted especially.
@cindex tags, format tags
Most of the format tags ``consume'' one of the specified values.
Every value in the list shall be described by a tag, or the compiler
will signal an error.  Likewise, values without a corresponding
describing tag is an error.  These tags are:

@table @code
@item %s
Print the argument as a string.
@item %i@var{bits}(d|x|o|b|c)
Print the argument as a signed integer of size @var{bits}.  The last
letter determines how the argument is printed.
@table @code
@item d
@cindex decimal
Print the integer in decimal.
@item x
@cindex hexadecimal
Print the integer in hexadecimal.
@item o
@cindex octal
Print the integer in octal.
@item b
@cindex binary
Print the integer in binary.
@item c
Print the integer as an ASCII character.  This only works with 8 bit
integers.
@end table
@item %u
Same as @code{%s}, but for unsigned integers.
@item %c
A shorter way to write @code{%u8c}.
@item %v
Print the value printed representation of the argument, which can be
of any type including complex types like arrays and structs.  This is
similar to the @code{write} operation available in many Lisp systems.

This tag is mainly intended to be used in pretty-printers.
@end table

@cindex styled output
The following format tags do not consume arguments.  They support
emitting styled text using the libtextstyle approach of having styling
classes that you can customize in a @file{.css} file.

@table @code
@item %<@var{classname}:
Start the styling class with name @var{classname}.  The class name
cannot be empty.
@item %>
End the last opened styling class.  All styling classes should be
ended before finishing the format string.
@end table

Note that styling classes can be nested, but all classes should be
ended before finishing the format string.

If you use a @var{name} class, you can define how to style it in the
@file{.css} file (poke installs and uses poke-default.css but you can
set the @code{POKE_STYLE} environment variable to point to another
css) like this:

@example
.NAME @{ text-decoration: blink; color : pink; @}
@end example

Examples:

@example
(poke) printf "This is a NAME: %<NAME:xxx%>"
This is a NAME: xxx
(poke) printf "Name: %<string:%s%> Age: %<integer:%i32d%>, "Jose", 39
Name: Jose Age: 39
@end example

@node Pretty Printers
@section Pretty Printers
@cindex pretty printing
XXX

@node __LINE__ and __FILE__
@chapter @code{__LINE__} and @code{__FILE__}
@cindex @code{__FILE__}
@cindex @code{__LINE__}
@cindex location
@cindex tracing
When printing traces it is often useful to include a description of
the location of the trace.  The poke compiler provides two builtins
for this purpose.

@table @code
@item __LINE__
@cindex line number
Expands to an unsigned 64-bit integer containing the current line of
the program being compiled.
@item __FILE__
@cindex file name
Expands to a string with the name of the file currently being compiled.  If the
program is read from the standard input (like in the REPL) then this
is @code{"<stdin>"}.
@end table

@node Standard Integral Types
@chapter Standard Integral Types
@cindex integral types
@cindex types, integral types
The Poke standard library provides the following standard integral
types.

@table @code
@item bit
1-bit unsigned integer.
@item nibble
4-bit unsigned integer.
@item uint8
@itemx byte
@itemx char
8-bit unsigned integer.
@item uint16
@itemx ushort
16-bit unsigned integer.
@item uint32
@itemx uint
32-bit unsigned integer.
@item uint64
@itemx ulong
64-bit unsigned integer.
@item int8
8-bit signed integer.
@item int16
@itemx short
16-bit signed integer.
@item int32
@item int
32-bit signed integer.
@item int64
@item long
64-bit signed integer.
@end table

@node Standard Offset Types
@chapter Standard Offset Types
@cindex offset types
@cindex types, offset types

The Poke standard library provides the following standard offset
types.

@table @code
@item off64
64-bit signed offset in bits.
@item uoff64
64-bit unsigned offset in bits.
@end table

@node Conversion Functions
@chapter Conversion Functions
@cindex conversion functions
The Poke standard library provides the following functions to do
useful conversions.

@menu
* catos::		converting characters arrays into string.
* atoi::		converting strings to integers.
@end menu

@node catos
@section @code{catos}
@cindex @code{catos}
@cindex converting, arrays to strings
It is often useful to convert arrays of characters into strings.  The
standard function @code{catos} provides the following interface:

@example
defun catos = (char[] @var{chars}) string: @{ @dots{} @}
@end example

It builds a string containing the characters in @var{chars}, and
returns it.  Examples:

@example
(poke) catos (['a','b','c'])
"abc"
(poke) catos (['\0'])
""
@end example

Note that if the passed array contains a @code{NULL} character
@code{'\0'} then no further characters are processed.  For example:

@example
(poke) catos (['f','o','o','\0','b','a','r'])
"foo"
@end example

@node atoi
@section @code{atoi}
@cindex @code{atoi}
@cindex converting, strings to integers
The standard function @code{atoi} provides the following interface:

@example
defun atoi = (string @var{str}, int @var{base} = 10) long: @{ @dots{} @}
@end example

It parses a signed integral number in the given @var{base} in the
string @var{str} and returns it as a signed 64-bit integer.

@cindex base, argument in @command{atoi}
The accepted values for @var{base} are @code{2}, @code{8}, @code{10}
(the default) and @code{16}.  If any other base is requested an
@code{E_generic} exception is raised.

Note that atoi allows for extra information to be stored in @var{str}
after the parsed integer.  Thus, this works:

@example
(poke) atoi ("10foo")
10L
@end example

@node String Functions
@chapter String Functions
@cindex string functions
The Poke standard library provides the following functions to do
work on strings:

@menu
* ltrim::		Remove leading whitespace.
* rtrim::		Remove trailing whitespace.
@end menu

@node ltrim
@section @code{ltrim}
@cindex @code{ltrim}
@cindex whitespace, trimming
The standard function @code{ltrim} provides the following interface:

@example
defun ltrim = (string s) string: @{ @dots{} @}
@end example

It returns a copy of the input string @code{s} with any leading whitespace removed.

@node rtrim
@section @code{rtrim}
@cindex @code{rtrim}
@cindex whitespace, trimming
The standard function @code{rtrim} provides the following interface:

@example
defun rtrim = (string s) string: @{ @dots{} @}
@end example

It returns a copy of the input string @code{s} with any trailing whitespace removed.

@node Sorting Functions
@chapter Sorting Functions
@cindex sorting
@menu
* qsort::		Sorting arrays with quicksort.
@end menu

@node qsort
@section @code{qsort}
@cindex @code{qsort}
@cindex quick sort
The standard function @code{qsort} has the following prototype:

@example
defun qsort = (any[] @var{array}, Comparator @var{cmp_f},
               long @var{left} = 0,
               long @var{right} = array'length - 1) void: @{ @dots{} @}
@end example

Where @var{array} is the array to sort, @var{cmp_f} is a comparator
function, @var{left} is the index of the first array element to
include in the sorting, and @var{right} is the index of the last array
element to include in the sorting.  Both @var{left} and @var{right}
are optional, and the default is to cover the whole array.

The comparator function @var{cmp_f} should have the following
prototype:

@example
deftype Comparator = (any,any):int;
@end example

@node CRC Functions
@chapter CRC Functions
@cindex CRC
@cindex checksum

Many file formats use checksums of one sort or another.
Therefore you may want to write such a checksum or verify
a checksum in a constrained field. @xref{Field Constraints}.

Some formats use simple additive checksums.  Another common checksum
is the Cyclic Redundancy Checksum (CRC).  The standard function
@code{crc32} calculates the 32 bit CRC defined by ISO-3309.

@example
defun crc32 = (byte[] @var{buf}) uint<32>: @{ @dots{} @}
@end example

@noindent
This function returns the 32 bit CRC for the data contained in the
array @var{buf}.

@node Dates and Times
@chapter Dates and Times
@cindex date
@cindex time
@cindex @code{POSIX_Time32}

Often a format encodes a date and time expressed as the number of seconds
since midnight, January@tie{}1st 1970@.   You could map these
simply as integers.  However, the standard library provides two
types @code{POSIX_Time32} and @code{POSIX_Time64} which include
pretty-printers (@pxref{Pretty Printers}) to
display the date in a human readable format.
The definition is:

@example
deftype POSIX_Time@var{size} = struct
@{
  uint<@var{size}>  seconds;

  defun _print = void:
  @{ @dots{} @}
@}
@end example

@noindent
where @var{size} is either 32 or 64@.
When pretty printing is enabled, a mapped value of these types will
display similar to

@example
#<2019-Dec-12 8:54:56>
@end example

@noindent
whereas when pretty printing is not enabled, this example would be displayed as:

@example
POSIX_Time32 @{seconds=1576140896U@}
@end example

@noindent
Note that timestamps of this type do not account for leap seconds and
are agnostic towards timezone.

@cindex @code{ptime}
Occasionally you might wish to print an unmapped timestamp value in a
human readable format.  To do this, you can use the @code{ptime} function,
which is defined as follows:

@example
defun ptime = (uint<64> seconds) void:
@{ @dots{} @}
@end example

@node Writing Commands
@chapter Writing Commands

XXX

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@cindex license, GNU Free Documentation License

@include fdl.texi

@node Concept Index
@unnumbered Concept Index

@printindex cp

@bye

@c  LocalWords:  texinfo setfilename texi settitle Pokist afourpaper
@c  LocalWords:  dircategory direntry titlepage vskip filll ifnottex
@c  LocalWords:  insertcopying vm pokerc Structs Endianness catos dfn
@c  LocalWords:  atoi qsort cindex pokeish bitpatterns noindent samp
@c  LocalWords:  itemx html init REPL TTY rluserman defun printf PVM
@c  LocalWords:  stdin subcommands disassembler ascii POKEDATADIR FLV
@c  LocalWords:  endian endianness obase expr Booleans uint Bitwise
@c  LocalWords:  emph signedness unary boolean ceil bitwise structs
@c  LocalWords:  BSON deftype struct dstart IETF BFINAL BTYPE BitData
@c  LocalWords:  sizeof kilobits Pokish B'size B'magnitude B'unit UB
@c  LocalWords:  b'magnitude b'unit fUB unhandled defvar CTF isa str
@c  LocalWords:  polymorphism lvalue stmt Variadic ret namespace gcd
@c  LocalWords:  variadic args PDP programmatically PKL eBPF dst src
@c  LocalWords:  BPF Insn Regs le ident ei ELFDATA LSB ELFDAT MSB ios
@c  LocalWords:  Ehdr ELFDATANONE osabi abiversion nident Unmapping
@c  LocalWords:  Comparator cmp relocations DIEs nelems
@c  LocalWords:  EOF Rela Addr Xword Sxword Shdr addr addralign fmt
@c  LocalWords:  entsize relocs adoleces libtextstyle classname css
@c  LocalWords:  ushort ulong uoff abc ltrim whitespace rtrim fdl
@c  LocalWords:  quicksort array'length comparator printindex
