\input texinfo
@comment %**start of header
@setfilename poke.info
@include version.texi
@settitle The Poke Book
@afourpaper
@comment %**end of header

@copying
This manual describes GNU poke (version @value{VERSION},
@value{UPDATED}).

Copyright @copyright{} 2019, 2020 Jose E. Marchesi

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Editors
@direntry
* poke: (poke). Interactive editor for binary files.
@end direntry

@titlepage
@title The Poke Book
@subtitle for version @value{VERSION}, @value{UPDATED}
@author by Jose E. Marchesi
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top The Poke Book

@insertcopying
@end ifnottex

@menu
* Introduction::		Introducing GNU poke.

Using poke
* Basic Editing::		Poking bits, bytes and simple data.
* Structuring Binary Data::	Poking your own abstractions.
* Debugging Poke Programs::	When something goes wrong.

Reference Material
* Dot-Commands::                Commanding the tool.
* Commands::			Commands for editing data.
* Configuration::		Tailoring the tool to your needs.
* The Poke Language::		All you wanted to know about Poke.
* The Standard Library::	Standard goodies for Poke programs.

Advanced Pokology
* Hacking Poke::		Extending poke.

Internals
* The Poke Virtual Machine::	The PVM and its mysteries.

* Table of ASCII Codes::	   The ASCII character set.
* GNU Free Documentation License:: Distribution terms for this document.

Indexes
* Concept Index::

@detailmenu
 --- The Detailed Node Listing ---
 ---------------------------------

Here are some other nodes which are really subnodes of the ones
already listed, mentioned here so you can get to them in one step:

Introduction
* Motivation::			Why a binary editor?
* Nomenclature::		poke, Poke and pickles.
* Invoking poke::		command line options.
* Commanding poke::		Interactive and non-interactive usage.

Basic Editing
* Binary Files::		Text vs. binary.
* Files as IO Spaces::		Poking files.
* Dumping File Contents::	A first look at a file's bytes.
* Poking Bytes::		Reading, manipulating and writing bytes.
* Values and Variables::        Values can be stored in variables.
* Poking Integers::		From bytes to integers.
* Buffers as IO Spaces::	Poking memory buffers.
* Poking ASCII Strings::	Readable sequences of bytes.
* Poking Arrays::		Groups of homogeneous values.

Structuring Binary Data
* Named Types::			The type abstraction.

Debugging Poke Programs
* __LINE__ and __FILE__::	Error locations in traces.

Dot-Commands
* load command::		Loading pickles.
* file command::		Opening and selecting file IO spaces.
* mem command::			Opening and selecting memory IO spaces.
* nbd command::			Opening and selecting NBD IO spaces.
* ios command::			Switching between IO spaces.
* close command::		Closing IO spaces.
* doc command::                 Online manual.
* editor command::		Using an external editor for input.
* info command::		Getting information about open files, @i{etc}.
* set command::			Querying and setting global options.
* vm command::			Poke Virtual Machine services.
* exit command::		Exiting poke :(

Commands
* dump::			Binary dumps.
* copy::			Copying data around.
* save::			Save data into a file.

Configuration
* pokerc::			User's initialization file.
* Styling::			Changing the appearance of poke's output.

The Poke Language
* Integers::			Whole numbers.
* Offsets::			Memory sizes and offsets.
* Strings::			NULL-terminated strings.
* Arrays::			Homogeneous collections.
* Structs::			Heterogeneous collections.
* Types::			Declaring types.
* Assignments::			Changing the value of variables.
* Compound Statements::		Sequences of statements.
* Conditionals::		Conditional statements and expressions.
* Loops::			Statements to iterate on conditions.
* Expression Statements::	Using expressions for their side-effects.
* Functions::			Procedural abstraction.
* Endianness::			Byte ordering.
* Mapping::			Accessing IO spaces.
* Exception Handling::		Dealing with exceptional conditions.
* Printing::			Output in Poke programs.
* Comments::			Documenting Poke programs.
* Modules::			Loading pickles from Poke programs.

The Standard Library
* Standard Integral Types::	int, long and the like.
* Standard Offset Types::	off64 and the like.
* Standard Units::		b, B, Kb and the like.
* Conversion Functions::	catos, atoi, @i{etc}.
* String Functions::		Functions which deal with strings.
* Sorting Functions::		qsort.
* CRC Functions::               Cyclic Redundancy Checksums.
* Dates and Times::             Processing and displaying dates and times.

Hacking poke
* Writing Commands::		Extending poke with new commands.

The Poke Virtual Machine
* PVM Instructions::		Virtual Machine instructions.
@end detailmenu
@end menu

@node Introduction
@chapter Introduction

@menu
* Motivation::			Why a binary editor?
* Nomenclature::		poke, Poke and pickles.
* Invoking poke::		command line options.
* Commanding poke::		Interactive and non-interactive usage.
@end menu

@node Motivation
@section Motivation

XXX

@node Nomenclature
@section Nomenclature
@cindex poke
@cindex Poke
@cindex pickle

GNU poke is a new program and it introduces many a new concept.  It is
a good idea to clarify how we call things in the poke community.
Unless everyone uses the same nomenclature to refer to pokish
thingies, it is gonna get very confusing very soon!

First of all we have @command{poke}, the program.  Since ``poke'' is a
very common English word, when the context is not clear we either use
the full denomination @command{GNU poke}, or quote the word using some
other mean.

Then we have @dfn{Poke}, with upper case P, which is the name of the
domain-specific programming language implemented by @command{poke},
the program.

This distinction is important.  For example, when people talk about
``poke programmers'' they refer to the group of people hacking GNU
poke.  When they talk about ``Poke programmers'' they refer to the
people who write programs using the Poke programming language.

Finally, a @dfn{pickle} is a Poke source file containing definitions
of types, variables, functions, @i{etc}, that conceptually apply to some
definite domain.  For example, @file{elf.pk} is a pickle that provides
facilities to poke ELF object files.  Pickles are not necessarily
related to file formats: a set of functions to work with bit patterns,
for example, could be implemented in a pickle named
@file{bitpatterns.pk}.

We hope this helps to clarify things.

@node Invoking poke
@section Invoking poke
@cindex invoking
Synopsis:

@example
poke [@var{option}@dots{}] [@var{file}]
@end example

@noindent
The following options are available.

@table @samp
@item -l
@itemx --load=@var{file}
Load the given file as a Poke program.  Any number of @samp{-l}
options can be specified, and they are loaded in the given order.
@item -L
Load the given file as a Poke program and exit.  This is commonly used
along with a shebang to implement Poke scripts.
@item -c
@itemx --command=@var{cmd}
Execute the given command.  Any number of @samp{-c} options can be
specified, and they are executed in the given order.
@item -s
@itemx --script=@var{file}
Load @var{file} as a poke script.  Any number of @samp{-s} options may
be specified, and they are loaded in the given order.
@item --color=@var{how}
@cindex styled output
Whether to use styled output, and how.  Valid options for @var{how}
are @samp{yes}, @samp{no}, @samp{auto}, @samp{html} and @samp{test}.
@item --style=@var{file}
Use @var{file} as the CSS to use for styling poke, instead of the
default style.
@item -q
@itemx --no-init-file
Do not load the @file{~/.pokerc} init file.
@cindex @file{.pokerc}
@item --quiet
Be as terse as possible.
@item --help
Print a help message and exit.
@item --version
Show version and exit.
@end table

@node Commanding poke
@section Commanding poke

GNU poke is primarily an interactive editor that works in the command
line.  However, it is also possible to use it in a non-interactive
way.  This chapter documents both possibilities.

@menu
* The REPL::                  Using poke interactively.
* Evaluation::		      Evaluating Poke.
* Commands and Dot-Commands:: Two kinds of commands.
* Scripts::		      Loading commands from files.
* Shebang::		      Executing Poke programs in the command line.
@end menu

@node The REPL
@subsection The REPL
@cindex REPL
If poke is invoked with an interactive TTY connected to the standard
input, it greets you with a welcome message, licensing
information and such, and finally a prompt that looks like:

@example
(poke)
@end example

At this point, the program is ready to be commanded.  You are
expected to introduce a line and press @key{enter}.  At that point
poke will examine the command, notify you if there is some error
condition, process the line and maybe displaying something in the
terminal.

@cindex readline
Repeatedly typing complex commands can be tiresome.
To help you, poke uses the readline library
@xref{Top,,,rluserman,GNU Readline Library}.
This provides shortcuts and simple keystrokes to repeat
previous commands with or without modification, fast selection of
file names and entries from other multiple choice contexts, and
navigation within a command and among previous commands.
@cindex history, session history
When the REPL starts, the history of your previous sessions
are loaded from the file @file{.poke_history} located in your home
directory (if it exists).

There are several kinds of lines that can be provided in the REPL:

@itemize @bullet
@item A @dfn{dot-command} invocation, that starts with a dot character
(@command{.}).
@item A command invocation.
@item A Poke statement.
@item A Poke expression.
@end itemize

These are explained in the following sections.

@node Evaluation
@subsection Evaluation

Both Poke expressions and statements can be introduced at the REPL.
When a trailing semicolon is required, it can be omitted.

When an expression is evaluated, the result of the expression is
printed back to you.  For example:
@cindex expressions
@example
(poke) 23
23
(poke) [1,2,3]
[1,2,3]
(poke) Packet @@ 0#B
Packet @{i=1179403647,j=65794L@}
@end example

@cindex statements
When a statement is executed in the REPL no result is printed, but of
course the statement can print on its own:

@example
(poke) defun do_foo = void: @{@}
(poke) do_foo
(poke) for (i in [1,2,3]) printf "elem %i32d\n", i;
elem 1
elem 2
elem 3
@end example

@cindex errors
If there is an error compiling the line, you are notified with a
nice error message, showing the location of the error.  For example:

@example
(poke) [1,2,3 + "foo"]
<stdin>:1:6: error: invalid operands in expression
[1,2,3 + "foo"];
     ^~~~~~~~~
@end example

@node Commands and Dot-Commands
@subsection Commands and Dot-Commands

There are two kinds of commands in poke: the @dfn{dot-commands}, which
are written in C and have their own conventions for handling
sub-commands and passing arguments and flags, and normal commands,
which are written in Poke.

@subsubsection Dot-Commands
@cindex dot-commands
Dot-commands are so called because their name start with the dot
character (@code{.}).  They can feature subcommands.  Example:

@example
(poke) .vm disassemble mapper int[] @@ 0#B
(poke) .vm disassemble writer int[] @@ 0#B
@end example

When there is no ambiguity, the command name and the subcommands can
be shortened to prefixes.  The commands above can also be written as:

@example
(poke) .vm dis m int[] @@ 0#B
(poke) .vm dis w int[] @@ 0#B
@end example

@cindex flags
Some commands also get flags, which are one-letter indicators that can
be appended to the command name (including subcommands) after a slash
character (@code{/}).  For example, the @command{.vm} disassembler
commands accept a @code{n} flag to indicate we want a native
disassemble.  We can pass it as follows:

@example
(poke) .vm disassemble mapper/n int[] @@ 0#B
(poke) .vm disassemble writer/n int[] @@ 0#B
@end example

If a dot-command accepts more than one argument, they are separated
using comma characters (@code{,}).  Spaces are generally ignored.

@subsubsection Commands
@cindex commands
Regular poke commands are written in Poke and use different
conventions.  The name of commands follow the same rules as normal
Poke identifiers, and do not start with a dot character.

An example is the @command{dump} command:

@example
(poke) dump
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0100 f700 0100 0000 0000 0000 0000 0000  ................
00000020: 0000 0000 0000 0000 8001 0000 0000 0000  ................
00000030: 0000 0000 4000 0000 0000 4000 0800 0700  ....@@.....@@.....
00000040: 1800 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 7900 0000 0000 0000 b701 0000 9a02 0000  y...............
00000060: 7b10 0000 0000 0000 1800 0000 0000 0000  @{...............
00000070: 0000 0000 0000 0000 7900 0000 0000 0000  ........y.......
@end example

@cindex arguments
After the name of the command, arguments can be specified by name,
like this:

@example
(poke) dump :from 0#B :size 8#B
(poke) dump :from 0#B :size 8#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4c46 0201 0100                      .ELF....
@end example

The @command{dump} command is discussed in greater detail
below (@pxref{dump}).
The order of arguments is irrelevant in principle:

@example
(poke) dump :from 0#B :size 8#B :ascii 0 :ruler 0
00000000: 7f45 4c46 0201 0100
(poke) dump :ruler 0 :from 0#B :size 8#B :ascii 0
00000000: 7f45 4c46 0201 0100
@end example

However, beware side effects while computing the values you pass as
the arguments!  The expressions themselves are evaluated from left to
right.

Which arguments are accepted, and their kind, depend on the specific
command.

Note that the idea is to restrict the number of dot-commands to the
absolutely minimum.  Most of the command-like functionality provided
in poke shall be implemented as regular commands.

@node Scripts
@subsection Scripts
@cindex scripts
Script files contain poke commands.
A poke command may be a dot command, a Poke statement or a Poke
expression.
Lines starting with @code{#} are comments will be ignored.   However a
comment must start at the beginning of a line.  Here is an example
of a script:

@example
# The following two lines are dot commands
.load my-pickle.pk
.set obase 16

# The following line is a Poke statement
dump :size 0x100#B :from 0x10#B

# The following line is a Poke expression statement without any side effect.
# Consequently it is valid, but rather useless.
4 == 4
@end example

A script file contains commands, not Poke code.  This means
it gets read line by line and commands cannot occupy
more than one line.  Hence the following is a valid script:

@example
deftype foo = struct @{int this; int that;@}
@end example

@noindent
but this is not valid as a script file (although it is a valid Poke command)
and will provoke an error:

@example
deftype foo = struct
@{
 int this;
 int that;
@}
@end example

Script files can be loaded at startup using the @code{-s} command
line option (@pxref{Invoking poke}).
The @file{~/.pokerc} startup file is also an example of a poke
script (@pxref{pokerc}).

@node Shebang
@subsection Shebang
@cindex shebang, @code{#!}
Following the example of Guile Scheme, the Poke syntax includes
support for multi-line comments using the @code{#!} and @code{!#}
delimiters.  This, along with the @code{-L} command line option,
allows you to write Poke scripts and execute them in the command line like
if they were normal programs.  Example of a script:

@example
#!/usr/bin/poke -L
!#

print "Hello world!\n";
@end example

If you want to pass additional flags to the poke command, you need to
use a slightly different kind of shebang:

@example
#!/usr/bin/env sh
exec poke -L "$0" "$@@"
!#

load elf;
printf ("%v\n", Elf4_Ehdr @@ 0#B);
@end example

@node Basic Editing
@chapter Basic Editing

In this chapter you will learn how to shuffle binary data around with
poke, in terms of fundamental predefined entities: bits, bytes,
integers, and the like.

@menu
* Binary Files::		Text vs. binary.
* Files as IO Spaces::		Poking files.
* Dumping File Contents::	A first look at a file's bytes.
* Poking Bytes::		Reading, manipulating and writing bytes.
* Values and Variables::        Values can be stored in variables.
* Poking Integers::		From bytes to integers.
* Buffers as IO Spaces::	Poking memory buffers.
* Poking ASCII Strings::	Readable sequences of bytes.
* Poking Arrays::		Groups of homogeneous values.
@end menu

@node Binary Files
@section Binary Files

GNU poke is an editor for @dfn{binary files}.  Right, so what is a
binary file?  Strictly speaking, every file in a computer's file
system is binary.  This is because, in a very fundamental level,
files are just sequences of bytes.

@cindex binary files
@cindex text files
Colloquially, however, it is very common to talk about ``binary
files'' as opposed to ``text files''.  In this informal meaning, a
text file is basically a file composed, mostly, of bytes (and byte
sequences) that can be translated into printable characters in some
character set, such as ASCII, EBCDIC or Unicode.  It follows that
binary files would then be files composed, mostly, of bytes not
intended to be interpreted as encoded characters.

Some text files contain non-printable characters, such as form feed
characters, and many binary files contain printable strings, such as a
string table in an ELF object file.  That is why we used the word
``mostly'' in the definitions above.  In practice, however, the
distinction is almost always clear and there is common consensus on
whether a given file format can be considered as binary format, or
not.

GNU poke can edit any file, and as we shall see, it provides some nice
features to manipulate sequences of bytes interpreted as character
strings.  However, it is called a ``binary editor'' because it is
especially designed to be useful editing binary files, in the sense of
the term defined above.

In this chapter, we will be using ELF object files as the experiment
subject in most of the examples.  ELF files are good for this purpose,
because they are eminently binary, highly structured, and still
strings play a role in them, encoding names of entities like sections
and symbols.  You don't need to have a perfect knowledge of the ELF
format in order to follow the examples, but being familiarized with
the concept of object file formats should surely help.

Obtaining a simple ELF object file is easy, if you have a C compiler
installed:

@example
$ echo 'int foo () @{ return 0; @}' | gcc -c -xc -o foo.o -
@end example

The command above compiles a very simple ELF object file that contains
the compiled form of a little dummy function.  This object file will
be our companion for a while, and will be the subject of much analysis
and abuse, as we poke it.

@node Files as IO Spaces
@section Files as IO Spaces

Now that we have a binary file (@file{foo.o}) it is time to open it
with poke.  There are two ways to do that.

One way is to pass the name of the file in the poke invocation.  The
program will start, open the file, and present you with the REPL, like
in:

@example
$ poke foo.o
[...]
(poke)
@end example

The other way is to fire up poke without arguments, and then use the
@command{.file} dot-command to open the file:

@example
$ poke
[...]
(poke) .file foo.o
The current IOS is now `./foo.o'.
@end example

@noindent
Note how poke replies to the dot-command, stating that the
@dfn{current IOS} is now the file we opened.

You may be wondering, what is this IOS thing?  It is an acronym for
Input/Output Space, often written IO Spaces. This is the denomination
used to refer to the entities being edited with poke.  In this case
the IO space being edited is a file, but we will see that is not
always the case: poke can also edit other entities such as memory
buffers and remote block-oriented devices over the network.  For now,
lets keep in mind that IOS, or IO space, refers to the file being
edited.

And why ``current''?  GNU poke is capable of editing several files
(more generally, several IO spaces) simultaneously.  At any time, one
of these files is the ``current one''.  In our case, the current IO
space is the file @file{foo.o}, since it is the only file poke knows
about:

@example
(poke) .info ios
  Id	Mode	Size		Name
* #0	rw	0x00000398#B	./foo.o
@end example

The command @command{.info ios} gives us information about all the IO
spaces that are currently open.  The first column tells us a @dfn{tag}
that identifies the IOS.  In this example, the tag corresponding to
@file{foo.o} is @code{#0}.  The second column tells us that
@file{foo.o} allows both reading and writing.  The third column tells
us the size of the file, in hexadecimal.

You may wonder what is that weird suffix @code{#B}.  It is an unit,
and tells us that the size @code{0x398} is measured in bytes, i.e. the
size of @file{foo.o} is @code{0x398} bytes (or, in decimal, @code{920}
bytes.)

Finally, the asterisk character at the left of the entry for
@file{foo.o} identifies it as the current IO space.  To see this more
clearly, lets open another file:

@example
(poke) .file bar.o
The current IOS is now `./bar.o'.
(poke) .info ios
  Id	Mode	Size		Name
* #1	rw	0x00000398#B	./bar.o
  #0	rw	0x00000398#B	./foo.o
@end example

Ah, there we have both @file{foo.o} and @file{bar.o}.  Now the current
IO space (the entry featuring the asterisk at the left) is the file
that we just opened, @file{bar.o}.  This is because poke always sets
the most recently open file as the current one.  We can switch back to
@file{foo.o} using yet another dot-command, @command{.ios}, which gets
an IO space tag as an argument:

@example
(poke) .ios #0
The current IOS is now `./foo.o'.
(poke) .info ios
  Id	Mode	Size		Name
  #1	rw	0x00000398#B	./bar.o
* #0	rw	0x00000398#B	./foo.o
@end example

@noindent
We are back to @file{foo.o}.  Since we are not really interested in
@file{bar.o}, lets close it:

@example
(poke) .close #1
(poke) .info ios
  Id	Mode	Size		Name
* #0	rw	0x00000398#B	./foo.o
@end example

@noindent
Awesome.  Now we can focus on @file{foo.o}'s contents...

@node Dumping File Contents
@section Dumping File Contents

Data stored in modern computers, in both volatile memory and
persistent files, is fundamentally a sequence of entities called
@dfn{bytes}.  The bytes can be addressed by its position in the
sequence, starting with zero:

@example
+--------+--------+--------+ ... +--------+
| byte 0 | byte 1 | byte 2 |     | byte N |
+--------+--------+--------+ ... +--------+
@end example

@noindent
Each byte has capacity to store a little unsigned integer in the range
@code{0..255}.  Therefore, the IO spaces that we edit with poke (like
the file @file{foo.o}) can be seen as a sequence of little numbers,
like depicted in the figure above.

GNU poke provides a command whose purpose is to display the values of
these bytes: @command{dump}@footnote{Note that this is not a
dot-command like @command{.file}, @command{.ios} or @command{.close}:
@command{dump} does not start with a dot!  We will see later how
dot-commands differ from ``normal commands'' like @command{dump}, but
for now, lets ignore the distinction.}  .  It is called like that
because it dumps ranges of bytes to the terminal, so the user can
inspect them.

So lets use our first poke command!  Fire up poke, open the file
@file{foo.o} as explained above, and execute the @command{dump}
command:

@example
(poke) dump
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0100 f700 0102 0000 0000 0000 0000 0000  ................
00000020: 0102 0000 0000 0000 9801 0000 0000 0000  ................
00000030: 0000 0000 4000 0000 0000 4000 0800 0700  ....@.....@.....
00000040: 2564 0a00 0000 0000 0000 0000 0000 0000  %d..............
00000050: b702 0000 0100 0000 1801 0000 0000 0000  ................
00000060: 0000 0000 0000 0000 8510 0000 ffff ffff  ................
00000070: b700 0000 0000 0000 9500 0000 0000 0000  ................
(poke)
@end example

@noindent
What are we looking at?

The first line of the output, starting with @code{76543210}, is a
@dfn{ruler}.  It is there to help us to visually determine the
location (or offset) of the data.

The rest of the lines show the values of the bytes that are stored in
the file, 16 bytes per line.  The first column in these data lines
shows the offset, in hexadecimal and measured in number of bytes, from
which the row of data starts.  For example, the offset of the first
byte shown in the third data line has offset 0x20 in the file, the
second byte has offset 0x21, and so on.  Note how the data rows show
the values of the individual bytes, in hexadecimal.  Generally
speaking, when dealing with bytes (and binary data in general) it is
useful to manipulate magnitudes in hexadecimal, or octal.  This is
because it is easy to group digits in these bases to little groups of
bits (four and three respectively) in the equivalent binary
representation.  In this case, each couple of hexadecimal digits
denote the value of a single byte@footnote{Do not be fooled by the
fact @command{dump} shows the hexadecimal digits in groups of four:
this is just a visual aid and, as we shall see, it is possible to
change the grouping by passing arguments to @command{dump}.}.  For
example, the value of the fist byte in the third data row is 0x01, the
value of the second bit 0x02, and so on.

Using the ruler and the column of offsets, locating bytes in the data
is very easy.  Lets say for example we are interested in the byte at
offset 0x68: we use the first column to quickly find the row starting
at 0x60, and the ruler to find the column marked with @code{88}.
Cross column and row and... voila!  The byte in question has the value
0x85.  The reverse process is just as easy.  What is the offset of the
first 0x40 in the file?  Try it!

The section at the right of the output is the ASCII output.  It shows
the row of bytes at the left interpreted as ASCII characters.
Non-printable characters are shown as @code{.} to avoid scrambling the
terminal, and no, there is no way to distinguish them from real ASCII
dot characters (@code{0x2e}) :P In this particular dump we can see
that near the beginning of the file there are three bytes whose value,
if interpreted as ASCII characters, conform the string ``ELF''.  As we
shall see, this is part of the ELF magic number.  Again, the ruler is
very useful to locate the byte corresponding to some character in the
ASCII section, or the other way around.  What is the value of the byte
corresponding to the @code{F} in @code{ELF}?  Try it!

@cindex commands, passing arguments
Something to notice in the @command{dump} output above is that these
are not, by any mean, the complete contents of the file @file{foo.o}.
The @command{.info ios} dot-command told us in the last section that
@file{foo.o} contains 920 bytes, of which the @command{dump} command
only showed us... @code{0x80} bytes, or @code{128} bytes in decimal.

@command{dump} is certainly capable of showing more (and less) than
@code{128} bytes.  We can ask @command{dump} to display some given
amount of data by specifying its size using a @dfn{command argument}.
For example:

@example
(poke) dump :size 64#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0100 f700 0102 0000 0000 0000 0000 0000  ................
00000020: 0102 0000 0000 0000 9801 0000 0000 0000  ................
00000030: 0000 0000 4000 0000 0000 4000 0800 0700  ....@.....@.....
@end example

The command above asks poke to ``dump 64 bytes''.  In this example
@code{:size} is the name of the argument, and @code{64#B} is the
argument's value.  Again, the suffix @code{#B} tells poke we want to
dump 64 bytes, not 64 kilobits or 64 potatoes.

Another interesting aspect of our first dump (ahem) is that the dumped
bytes start from the beginning of the file, i.e. the offset of the
first byte is 0x0.  Certainly there should be other areas of the file
with interesting contents for us to inspect.  To that purpose, we can
use yet another option, @code{:from}:

@example
(poke) dump :size 64#B :from 128#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000080: 1400 0000 0000 0000 0000 0000 0000 0000  ................
00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................
000000a0: 0000 0000 0300 0100 0000 0000 0000 0000  ................
000000b0: 0000 0000 0000 0000 0000 0000 0300 0300  ................
@end example

The command above asks poke to ``dump 64 bytes starting at 128 bytes
from the beginning of the file''.  Note how the first row of bytes
start at offset @code{0x80}, i.e. @code{128} in decimal.

@cindex commands, customizing
Passing options to commands is easy and natural, but we may find
ourselves passing the same values again and again to certain command
options.  For example, if the default size of @command{dump} of 128
bytes is not what you prefer, because you have a particularly tall
monitor, or you are one of these people using sub-atomic sized fonts,
it can be tiresome and error-prone to pass @command{:size} to
@command{dump} every time you use it.  Fortunately, the default size
can be customized by setting a @dfn{global variable}:

@example
(poke) pk_dump_size = 160#B
@end example

@noindent
This tells poke to set @code{160} bytes as the new value for the
@code{pk_dump_size} variable.  This is a global variable that the
@command{dump} command uses to determine how much data to show if the
user doesn't specify an explicit value with the @code{:size} option.
The default behavior of other commands can also be modified by
customization variables.

@cindex .pokerc
@cindex initialization file
And now that we are talking about that, it is also cumbersome to have
to set the default size used by @command{dump} every time we run
poke.  But no problem, just set the variable in a file called
@file{.pokerc} in your home directory, like this:

@example
pk_dump_size = 160#B
@end example

@noindent
Every time poke starts, it reads @file{~/.pokerc} and executes the
commands contained in it.  See @ref{pokerc}.

The @command{dump} command is very flexible, and accepts a lot of
options and customization variables that we won't be covering in this
chapter.  For a complete description of the command, see @ref{dump}.

@node Poking Bytes
@section Poking Bytes

Lets look again at the first bytes of the file @file{foo.o}:

@example
(poke) dump :size 64#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0100 f700 0102 0000 0000 0000 0000 0000  ................
00000020: 0102 0000 0000 0000 9801 0000 0000 0000  ................
00000030: 0000 0000 4000 0000 0000 4000 0800 0700  ....@.....@.....
@end example

At this point we know how to use the ruler to localize specific bytes
just by looking at the displayed data.  If we wanted to operate on the
values of some given bytes, we could look at the dump and type the
values in the REPL.  For example, if we wanted to add the values of
the bytes at offsets 0x2 and 0x4, we could look at the dump and then
type:

@example
(poke) 0x4c + 0x02
0x4e
@end example

GNU poke supports many operators that take integers as arguments, to
perform arithmetic, relational, logical and bit-wise operations on
them (@pxref{Integers}).  Since bytes are no more (and no less) than
little unsigned integers, we can use these operators to perform
calculations on bytes.

For example, this is how we would calculate whether the highest bit in
the second byte in @file{foo.o} is set:

@example
(poke) 0x45 & 0x80
0
@end example

@noindent
Note how booleans are encoded in Poke as integers, 0 meaning false,
any other value meaning true.

Looking at the output of @command{dump} and writing the desired byte
value in the prompt is cumbersome.  Fortunately, there is a much more
convenient way to access to the value of a byte, given its offset in
the file: it is called @dfn{mapping a byte value}.  This operation is
implemented by a binary operator, called the map operator.

This is how it works.  Assuming we were interested in the byte at
@code{64} bytes from the beginning of the file, this is how we would
refer to it (or ``map'' it):

@example
(poke) byte @@ 64#B
37UB
@end example

@noindent
This application of the map operator tells poke to map a byte at the
offset 64 bytes.  It can be read as ``byte at 64 bytes''.  Note how
poke replies with the value 37UB.  The suffix @code{UB} means
``unsigned byte'', and is an indication for the user about the nature
of the preceding number: it is unsigned, and it is a byte long.

As we can see in this example, poke uses decimal by default when
showing values in the REPL.  We already noted how it is usually better
to work in hexadecimal when dealing with byte values.  Fortunately, we
can change the numeration base used by poke when printing numbers,
using the @command{.set obase} (``set output base'') dot-command as
this:

@example
(poke) .set obase 16
@end example

@noindent
After this, we can map the byte again, this time getting the result
expressed in hexadecimal:

@example
(poke) byte @@ 64#B
0x25UB
@end example

@noindent
Again, you may find it useful to add the @code{.set obase 16} command
to your @file{.pokerc} file, if you want the customization to be
persistent between poke invocations.

Going back to the example of calculating whether the highest bit in
the second byte in @file{foo.o} is set, this is how we would do it
with a map:

@example
(poke) byte @@ 0x28#B = 0xff
@end example

@noindent
Which reads ``assign 0xff to the byte at offset 0x4a bytes''.  Dumping
again, we can verify that the byte actually changed:

@example
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0100 f700 0102 0000 0000 0000 0000 0000  ................
00000020: 0102 0000 0000 0000 ff01 0000 0000 0000  ................
00000030: 0000 0000 4000 0000 0000 4000 0800 0700  ....@.....@.....
@end example

@noindent
Does this mean that @file{foo.o} changed accordingly, in disk?  The
answer is yes.  poke always commits changes immediately to the file
being edited.  This, that is an useful feature, can also be a bit
tricky if you forget about it, leading data corruption, so please be
careful.

Incidentally, altering the byte at offset 0x28 most probably have
caused @file{foo.o} to stop being a valid ELF file, but since we are
just editing bytes (and not ELF structures) we actually don't care
much.

@node Values and Variables
@section Values and Variables

Up to now we have worked with byte values, either writing them in the
REPL or mapping them at the current IO space.  Often it is useful to
save values under meaningful names, and access to them by name.  In
poke we do that by storing the values in @dfn{variables}.

Before being used, variables shall be defined using the @code{defvar}
construction.  Lets get the byte at offset @code{64} bytes and save it
in a variable called @code{foo}:

@example
(poke) defvar foo = byte @@ 64#B
@end example

@noindent
This defines a new variable (@code{foo}) and initializes it to the
value of the byte at offset 64 bytes.  This results on @code{foo} to
hold the value 37.

Once defined, we can get the value of a variable by just giving its
name to poke:

@example
(poke) foo
37UB
@end example

@noindent
In general, a variable containing a byte value can be used in any
context where the contained value would be expected.  If we wanted to
check the highest bit in the byte value stored in @code{foo} we would
do:

@example
(poke) foo & 0x80
0x0
@end example

Assigning a value to a variable makes the value the new contents of
the variable.  For example, we can increase the value of @code{foo} by
one like this:

@example
(poke) foo = foo + 1
@end example

At this point, an important question is: when we change the value of
the variable @code{foo}, are we also changing the value of the byte
stored in @file{foo.o} at offset 64 bytes?  The answer is no.  This is
because when we do the mapping:

@example
(poke) defvar foo = byte @@ 64#B
@end example

@noindent
The value stored in @code{foo} is a @emph{copy} of the value returned
by the map operator @code{@@}.  You can imagine the variable as a
storage cell located somewhere in poke's memory.  After the assignment
above is executed there are two copies of the byte value 0x25: one in
@file{foo.o} at offset 64 bytes, and the other in the variable
@code{foo}.

It follows that if we wanted to increase the byte in the file, we
would need to do something like:

@example
(poke) defvar foo = byte @@ 64#B
(poke) foo = foo + 1
(poke) byte @@ 64#B = foo
@end example

@noindent
Or, more succinctly, omitting the usage of a variable:

@example
(poke) byte @@ 64#B = (byte @@ 64#B) + 1
@end example

@noindent
Note how we have to use parenthesis around the map at the right hand
side, because the map operator @code{@@} has less precedence than the
plus operator @code{+}.

@node Poking Integers
@section Poking Integers

Integers are probably the most important notion when working with
binary data.

@menu
* From Bytes to Integers::	Building numbers with bytes.
* Big and Little Endians::	Pick your egg.
* Negative Integers::		Why so positive?
* Weird Integers::		Incomplete bytes in numbers.
* Unaligned Integers::		IO spaces are bit-oriented.
* Integers of Different Sizes:: Promotion of integers in expressions.
@end menu

@node From Bytes to Integers
@subsection From Bytes to Integers

The bytes we have been working with are unsigned whole numbers (or
integers) in the range @code{0..255}.  We saw how poke sees the
contents of the files as a sequence of bytes, and that each byte can
be addressed using an offset.  Mapping bytes using the map operator
@code{@@} gives us these values, which are denoted in poke with
literals like @code{10UB} or @code{0x0aUB}.

This very limited range of values have consequences when it comes to
do arithmetic with bytes.  Suppose for example we wanted to calculate
the average of the first byte values stored in @file{foo.o}.  We could
do something like:

@example
(poke) defvar a = byte[3] @@ 0#B
(poke) a
[0x7fUB,0x45UB,0x4cUB]
(poke) (a[0] + a[1] + a[2]) / 3UB
5UB
@end example

@noindent
That is obviously the wrong answer.  What happened?  Let's do it step
by step.  First, we add the first two bytes:

@example
(poke) a[0] + a[1]
0xc4UB
@end example

@noindent
Which is all right.  0xc4 is 0x7f plus 0x45.  But, lets add now the
third byte:

@example
(poke) a[0] + a[1] + a[2]
0x10UB
@end example

@noindent
That's no good.  Adding the value of the third byte (0x4c) we
overflowed the range of valid values for a byte value.  The
calculation went banana at this point.

Another obvious problem is that we surely will want to store integers
bigger than 255 in our files.  Clearly we need a way to encode them
somehow, and since all we have in a file are bytes, the integers will
have to be composed of them.

Integers bigger than 255 can be encoded by interpreting consecutive
byte values in a certain way.  First, lets consider a single byte.  If
we print a byte value using binary rather than binary or hexadecimal,
we will observe that eight bits are what it takes to encode the
numbers between 0 and 0xff (255) using a @dfn{natural binary
encoding}:

@example
(poke) .set obase 2
(poke) 0UB
0b00000000UB
(poke) 0xFFUB
0b11111111UB
@end example

This is the reason why people say bytes are ``composed'' by eight
bits, or that the width of a byte is eight bits.  But this way of
talking doesn't really reflect the view that the operating system has
of devices like files or memory buffers: both disk and memory
controllers provide and consume bytes, i.e. little unsigned numbers in
the range @code{0..255}.  At that level, bytes are indivisible.  We
will see later that poke provides ways to work on the ``sub-byte''
level, but that is just really an artifact to make our life easier:
underneath, all that goes in and out are bytes.

Anyhow, if we were to ``concatenate'' the binary representation of two
consecutive bytes, we would end with a much bigger range of possible
numbers, in the range
@code{0b00000000_00000000..0b11111111_11111111}@footnote{poke allows
to insert underscore characters @code{_} anywhere in number literals.
The only purpose of these characters is to improve readability, and
they are totally ignored by poke, i.e. they do not alter the value of
the number.}, or @code{0x0000..0xffff} in hexadecimal.  poke provides
a bit-concatenation operator @code{::} that does exactly that:

@example
(poke) 0x1UB
0b00000001UB
(poke) 0x1UB :: 0x1UB
0b0000000100000001UH
@end example

@noindent
Note how the suffix of the resulting number is now @code{UH}.  This
indicates that the number is no longer a byte value: it is too big for
that.  The @code{H} in this new suffix means ``half'', and it is a
traditional way to call an integer that is encoded using two bytes, or
16 bits.

So, using our method of encoding bigger numbers concatenating bytes,
what would be the ``half'' integer composed by two bytes at the
beginning of @file{foo.o}?

@example
(poke) .set obase 16
(poke) (byte @@ 0#B)::(byte @@ 1#B)
0x7f45UH
@end example

Now, lets go back to the syntax we use to map a byte value.  In the
invocation of the map operator @code{byte @@ 0#B} the operator at the
left tells the operator what kind of value to map.  This is called a
@dfn{type specifier}; @code{byte} is the type specifier for a single
byte value, and @code{byte[3]} is the type specifier for a group of
three byte values arranged in an array.

As it happens, @code{byte} is a synonym for another slightly more
interesting type specifier: @code{uint<8>}.  You can probably infer
the meaning already: a byte is an unsigned integer of 8 bits width.
We can of course use this alternate specifier in a mapping operation,
achieving exactly the same result than if we were using @code{byte}:

@example
(poke) uint<8> @@ 0#B
0x7fUB
@end example

You may be wondering: is it possible to use a similar type specifier
for mapping bigger integers, like these ``halfs'' that are composed by
two bytes?  Yeah, it is indeed possible:

@example
(poke) uint<16> @@ 0#B
0x457fUH
@end example

@noindent
Mapping an unsigned integer of 16-bits at the offset 0 gives us an
unsigned ``half'' value, as expected.  But wait a minute, didn't you
notice something weird?@footnote{This is assuming you are running poke
in a x86 machine or other systems using little-endian.  Otherwise,
just continue reading the next section :)}

@example
(poke) (byte @@ 0#B)::(byte @@ 1#B)
0x7f45UH
(poke) uint<16> @@ 0#B
0x457fUH
@end example

@noindent
The bytes are reversed when we map an unsigned 16-bit integer, but not
when we concatenate the two mapped byte values at the beginning of the
file.  Apparently, the @code{uint<16>} mapping is wrong, because the
bytes are clearly arranged in the file the other way around:

@example
(poke) dump :from 0#B :size 16#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4c46 0201 0000 0000 0000 0000 0000  .ELF............
@end example

The solution for the mystery, which is probably one of the biggest
banes in the computing world, with a cost for the industry of who
knows how many millions of dollars every year, is explained in the
next section.

Before that, just note that you can build bigger and bigger arrays
concatenating more and more bytes.   Three bytes? sure:

@example
(poke) uint<24> @@ 0#B
(uint<24>) 0x4c457f
@end example

@noindent
Note that in this case poke uses a prefix instead of a suffix to
indicate that the given value is 24-bits long.  Four bytes?

@example
(poke) uint<32> @@ 0#B
0x464c457fU
@end example

Certain integer widths are so often used that easier-to-type synonyms
for their type specifiers are provided.  We already know @code{byte}
for @code{uint<8>}.  Similarly, @code{ushort} is a synonym for
@code{uint<16>}, @code{uint} is a synonym for @code{uint<32>} and
@code{ulong} is a synonym for @code{uint<64>}.  Try them!

GNU poke supports integers up to eight bytes, i.e. up to 64-bits.
This may change in the future, as we are planning to support
arbitrarily large integers.

@node Big and Little Endians
@subsection Big and Little Endians

@cindex big endian
@cindex little endian
@cindex endianness
When talking about whole numbers (integers) we should distinguish
between a value (such as 123) and its @dfn{written form}, such as
@code{123}.  The written form of a number is composed by digits,
arranged in certain order.  It turns out that the ordering of the
digits in the written form of a number is important, because depending
on its position each digit contributes with a different ``weight'' to
the resulting value.  This is regardless of the numerical base used.

For example, the value of the number 123 (whose written form is
@code{123}) is calculated as @code{1*10^2+2*10^1+3*10^0}.  If we swap
the last two digits in the written form of the number, we have
@code{1*10^2+3*10^1+2*10^0}, which results in a different value:
@code{132}.  When we consider other numerical bases, the bases in the
polynomial change accordingly, but the correspondence between written
form and value stands: for example, the value of 0x123 is calculated
as @code{1*16^2+2*16^1+3*16^0}.  The ``higher'' a digit is in the
polynomial, the @dfn{more significant} it is.  In the written number
@code{123}, for example, the digit 1 is the @dfn{most significant}
digit of the number, and the digit 3 is the @dfn{least significant}
digit.

This distinction between the written form of a number and its value is
important.  In the same way there are languages that are read
right-to-left and down-to-up, imagine there was a language in the
world in which the digits of numbers were arranged from right-to-left
instead of left-to-right.  In that context, the written representation
of 123 would be @code{321}, not @code{123}.  In other words: the least
significant digit would come first, not last, in the written form of
the number.

Since we are composing numbers with bytes, it makes sense to have each
byte to play the role of a digit in the written form of the bigger
number.  Since bytes can have values from 0 to 255, the base is 256.
But what is the ``written form'' for our byte-composed numbers?

In the last section we tried to compose bigger integers by
concatenating bytes together and interpreting the result.  In doing
so, we assumed (quite naturally) that in the written form of the
resulting integer the bytes are ordered in the same order than they
appear in the file, i.e. we assume that the written form of the number
@code{b1*256^2+b2*256^1+b3*256^0} would be @code{b1b2b3}, where
@code{b1}, @code{b2} and @code{b3} are bytes.  In other words, given a
written form @code{b1b2b3}, @code{b1} would be the most significant
byte (digit) and @code{b3} would be the least significant byte
(digit).  In our world of IO spaces, the ``written form'' is the
disposition of the bytes in the IO space (file, memory buffer, etc)
being edited.

This is what the bit-concatenation operator implements:

@example
(poke) dump :from 0#B :size 3#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4c                                  .EL
(poke) defvar b1 = byte @@ 0#B
(poke) defvar b2 = byte @@ 1#B
(poke) defvar b3 = byte @@ 2#B
(poke) b1::b2::b3
(uint<24>) 0x7f454c
@end example

However, much like in certain human languages the written form is read
from right to left, some computers also read numbers from right to
left in their ``written form''.  Actually, turns out that @emph{most}
modern computers do it like that.  This means that, in these
computers, given the written form @code{b1b2b3} (i.e. given a file
where @code{b1} comes first, followed by @code{b2} and then @code{b3})
the most significant byte is @code{b3} and the least significant byte
is @code{b1}.  Therefore, the value of the number would be
@code{b3*256^2+b2*256^1+b3*256^0}.

So, given the written form of a bigger number @code{b1b2b3} (i.e. some
ordering of bytes implied by the file they are stored in) there are at
least two ways to interpret them to calculate the value of the
number.  When the written form is read from left to right, we talk
about a @dfn{big endian} interpretation.  When the written form is
read from right to left, we talk about a @dfn{little endian}
representation.

Given the first three bytes in @code{foo.o}, we can determine the
value of the integer composed by these three bytes in both
interpretations:

@example
(poke) b1::b2::b3
(uint<24>) 0x7f454c
(poke) b3::b2::b1
(uint<24>) 0x4c457f
@end example

Remember how the type specifier @code{byte} is just a synonym of
@code{uint<8>}, and how we can use type specifiers like
@code{uint<24>} and @code{uint<32>} to map bigger integers?  When we
do that, like in:

@example
(poke) uint<24> @@ 0#B
(uint<24>) 0x7f454c
@end example

@noindent
poke should decide what kind of interpretation to use, i.e. how to
read the ``written form'' of the number.  As you can see from the
example, poke uses the left-to-right interpretation, or big-endian, by
default.  But you can change it using a new dot-command: @command{.set
endian}:

@example
(poke) .set endian little
(poke) uint<24> @@ 0#B
(uint<24>) 0x4c457f
@end example

The currently used interpretation (also called @dfn{endianness}) is
shown if you invoke the dot-command without an argument@footnote{This
also applies to the other @command{.set} commands}:

@example
(poke) .set endian
little
@end example

Different systems use different endianness.  Into a given system, it
is to be expected that most files will be encoded following the same
conventions.  Therefore poke provides you a way to set the endianness
to whatever endianness is in the system.  You do it this way:

@example
(poke) .set endian host
@end example

@node Negative Integers
@subsection Negative Integers

@subsubsection Negative Encodings

Up to this point we have worked with unsigned integers, i.e. whole
numbers which are zero or bigger than zero.  Much like it happened
with endianness, the interpretation of the value of several bytes as a
negative number depends on the specific interpretation.

@cindex negative encoding
@cindex one complement
@cindex two complement
In computing there are two main ways to interpret the values of a
group of bytes as a negative number: @dfn{one's complement} and
@dfn{two's complement}.
@c XXX: expand.

GNU poke supports both interpretations, and the interpretation that is
used depends on the global setting that can be changed using the
@command{.set nenc} dot-command.  The possible values are @code{2c}
for two's complement and @code{1c} for one's complement.

@example
(poke) .set nenc
2c
(poke) .set nenc 1c
@end example

@noindent
The default is two's complement, which is the negative encoding used
in the vast majority of modern computers and operating systems.

@subsubsection Signed Integers

Unsigned values are never negative.  For example:

@example
(poke) 0UB - 1UB
0xffUB
@end example

@noindent
Instead of getting a -1, we get the result of an unsigned underflow,
which is the biggest possible value for an unsigned integer of size 8
bits: 0xff.

When using type specifiers like @code{uint<8>} or @code{uint<16>} in a
map, we get unsigned values such as 0UB.  It follows that we need
other type specifiers to map signed values.  These look like
@code{int<8>} and @code{int<16>}.

For example, lets map a signed 16-bit value from @file{foo.o}:

@example
(poke) .set obase 10
(poke) int<16> @@ 0#B
28515H
@end example

@noindent
Note how the suffix of the value is now @code{H} and not @code{UH}.
This means that the value is signed!  But in this case it is still
positive, so lets try to get an actual negative value:

@example
(poke) defvar h = int<16> @@ 0#B
(poke) h - h - 1H
-1H
@end example

@subsubsection Mixing Signed and Unsigned Integers

Adding two signed integers gives you a signed integer:

@example
(poke) 1 + 2
3
@end example

@noindent
Likewise, adding two unsigned integers results in an unsigned integer:

@example
(poke) 1U + 2U
3U
@end example

@noindent
But, what happens if we mix signed and unsigned values in an
expression?  Is the result signed, or unsigned?  Lets find out:

@example
(poke) 1U + 2
3U
@end example

@noindent
Looks like combining an unsigned value with a signed value gives us an
unsigned value.  This actually applies to all the operators that work
on integer values: multiplication, division, exponentiation, etc.

@cindex casts
What actually happens is that the signed operand is converted to an
unsigned value before executing the expression.  You can also convert
signed values into unsigned values (and vice-versa) using @dfn{cast
constructions}:

@example
(poke) 2 as uint<32>
2U
@end example

@noindent
Therefore, the expression @code{1U + 2} is equivalent to @code{1U + 2
as uint<32>}:

@example
(poke) 1U + 2 as uint<32>
3U
@end example

You may be wondering: why not doing it the other way around?  Why not
converting the unsigned operand into a signed value and then operate?
The reason is that, given an integer size, the positive range that you
can store in it is bigger when interpreted as an unsigned integer than
when interpreted as a signed integer.  Therefore, converting signed
into unsigned before operating reduces the risk of positive overflow.
This of course assumes that we, as users, will be working with
positive numbers more often than with negative numbers, but that is a
reasonable assumption to do, as it is often the case!

@node Weird Integers
@subsection Weird Integers

Up to this point we have been playing with integers that are built
using a whole number of bytes.  However, we have seen that the type
specifier for an integer has the form @code{int<N>} or @code{uint<N>}
for signed and unsigned variants, where @code{N} is the width of the
integer, in bits.  We have used bit-sizes that are multiple of 8,
which is the size of a byte.  So, why is this so?  Why is @code{N} not
measured in bytes instead?

The reason is that poke is not limited to integers composed by a whole
number of bytes. You can actually have integers having @emph{any}
number of bits, between 1 and 64.  So yes, @code{int<3>} is a type
specifier for signed 3-bit integers, and @code{uint<17>} is a type
specifier for unsigned 7-bit integers.

We call integers like this @dfn{weird integers}.

The vast majority of programming languages do not provide any support
for weird integers.  In the few cases they do, it is often in a very
limited and specific way, like bitmap fields in C structs, that also
depends on the system where you compile and run your program.

In poke, on the contrary, weird numbers are first class citizens, and
they don't differ in any way from ``normal'' integers composed of a
whole number of bytes.

@subsubsection Incomplete Bytes

Let's consider first weird numbers that span for more than one byte.
For example, an unsigned integer of 12 bits.  Lets visualize the
written form of this number, i.e. the sequence of its constituent
bytes as they appear in the underlying IO space:

@example
  byte 0  |  byte 1
+---------+----+----+
|::::::::::::::|    |
+---------+----+----+
|   uint<12>   |
@end example

@noindent
All right, the first byte is used in its entirely, but only half of
the second byte is used to conform the value of the number.  The other
half of the second byte has no influence of the value of the 12 bits
number.

Now, we talk about the ``second half of the byte'', but what do that
means exactly?  We know that bytes in memory and files (bytes in IO
spaces) are indivisible at the system level: bytes are read and
written one at a time, as little integers in the range @code{0..255}.
However, we can create the useful fiction that each byte is composed
by @dfn{bits}, which are the digits in the binary representation of
the byte value.

So, we can look at a byte as composed by a group of eight bits, like
this:

@example
           byte
+-------------------------+
| b7 b6 b5 b4 b3 b2 b1 b0 |
+-------------------------+
@end example

@noindent
Note how we decided to number the bits in descending order from left
to right.  This is because these bits correspond to the base of the
polynomial equivalent to the binary value of the byte, i.e. the value
of the byte is
@code{b7*2^7+b6*2^6+b5*2^5+b4*2^4+b3*2^3+b2*2^2+b1*2^1+b0*2^0}.  In
other words: at the bit level poke always uses a big endian
interpretation, and the bit that ``comes first'' in this imaginary
stream of bits is the most significant bit in the binary
representation of the number.  Please note that this is just a
convention, set by the poke authors: the opposite could have been
chosen, but it would have been a bit confusing, as we would have to
picture binary numbers in reverse order!

With this new way of looking at bytes, we can now visualize what we
mean exactly with the ``first half'' and ``second half'' of the
trailing bit, in our 12 bits unsigned number:

@example
           byte 0         |           byte 1
+-------------------------+-------------+-------------+
| a7 a6 a5 a4 a3 a2 a1 a0   b7 b6 b5 b4 :             |
+-------------------------+-------------+-------------+
|                uint<12>               |
@end example

@noindent
Thus the first half of @code{byte 1} is the sequence of bits @code{b7
b6 b5 b4}.  The second half, which is not pictured since it doesn't
contribute to the value of the number, would be @code{b3 b2 b1 b0}.

So what would be the value of the 12-bit integer?  Exactly like with
non-weird numbers, this depends on the current selected endianness,
which determines the ordering of bytes.

If the current endianness is big, then @code{byte 0} provides the most
significant bits of the result number, and the used portion of
@code{byte 1} provides the least significant bits of the result
number:

@example
0b a7 a6 a5 a4 a3 a2 a1 a0 b7 b6 b5 b4
@end example

@noindent
However, if the current selected endianness is little, then the used
portion of @code{byte 1} provides the most significant bits of the
result number, and @code{byte 0} provides the least significant bits
of the result number:

@example
0b b7 b6 b5 b4 a7 a6 a5 a4 a3 a2 a1 a0
@end example

Lets see this in action.  Lets take a look to the value of the first
two bytes in @file{foo.o}, in binary:

@example
(poke) .set obase 2
(poke) byte @@ 0#B
0b01111111UB
(poke) byte @@ 1#B
0b01000101UB
@end example

@noindent
Looking at these bytes as sequences of bits, we have:

@example
        byte @@ 0#B       |        byte @@ 1#B
+-------------------------+-------------+-------------+
|  0  1  1  1  1  1  1  1    0  1  0  0 :  0  1  0  1
+-------------------------+-------------+-------------+
|                uint<12>               |
@end example

@noindent
Lets map our weird number at offset 0 bytes, using big endian:

@example
(poke) .set endian big
(poke) uint<12> @@ 0#B
(uint<12>) 0b011111110100
@end example

@noindent
That matches what we explained before: the most significant bits of
the unsigned 12 bits number come from the byte at offset 0,
i.e. @code{01111111}, whereas the least significant bits come from the
byte at offset 1, i.e. @code{0100}.

Now lets map it using little endian:

@example
(poke) uint<12> @@ 0#B
(uint<12>) 0b010001111111
@end example

@noindent
This time the most significant bits of the unsigned 12 bits number
come from the byte at offset 1, i.e. @code{0100}, whereas the least
significant bits come from the byte at offset 0, i.e. @code{01111111}.

An important thing to note is that non-weird numbers, i.e. numbers
built with a whole number of bytes, are basically a particular case of
weird numbers where the last byte in the written form (in the IO
space) provides all its bits.  The rules are exactly the same in all
cases, which makes it easy to obtain predictable and natural results
when building integers using poke.

@subsubsection Quantum Bytenics

The second kind of weird numbers are integers using less than 8 bits.
These ``sub-byte'' numbers do not use all the bytes of their
containing byte.  Consider for example the written form of an unsigned
integer of size 5 bits:

@example
    byte
+-----+----+
|:::::|    |
+-----+----+
uint<5>
@end example

@noindent
Now lets view the byte as a sequence of bits:

@example
             byte
+----------------+----------+
| b7 b6 b5 b4 b3 |          |
+----------------+----------+
|    uint<5>     |
@end example

@noindent
What is the value of this number?  Applying the general rules for
building integers from bytes, we can easily see that regardless of the
current endianness the value, in binary, is:

@example
0b b7 b6 b5 b4 b3
@end example

Lets see this in poke:

@example
(poke) .set obase 2
(poke) .set endian big
(poke) byte @@ 0#B
0b01111111UB
(poke) uint<5> @@ 0#B
(uint<5>) 0b01111
(poke) .set endian little
(poke) uint<5> @@ 0#B
(uint<5>) 0b01111
@end example

@subsubsection Signed Weird Numbers

In the section discussing negative integers, we saw how the different
between a signed number and an unsigned number is basically a
different interpretation of the most significant byte.  Exactly the
same applies to weird numbers.

Lets summon our unsigned 12-bit integer at the beginning of the file
@file{foo.o}:

@example
(poke) .set endian big
(poke) uint<12> @@ 0#B
(uint<12>) 0b011111110100
@end example

@noindent
The most significant byte of the resulting value (not of its written
form) indicates that this number would be positive if we were mapping
the corresponding signed value.  Lets see:

@example
(poke) int<12> @@ 0#B
(int<12>) 0b010001111111
(poke) .set obase 10
(poke) int<12> @@ 0#B
(int<12>) 1151
@end example

Lets make it a bit more interesting, and change the value of the first
byte in the file so we get a negative number:

@example
(poke) .set obase 2
(poke) byte @@ 0#B = 0b1111_1111
(poke) int<12> @@ 0#B
(int<12>) 0b111111110100
(poke) .set obase 10
(poke) int<12> @@ 0#B
(int<12>) -12
@end example

@noindent
Now, lets switch to little endian:

@example
(poke) .set endian little
(poke) .set obase 2
(poke) int<12> @@ 0#B
(int<12>) 0b010011111111
(poke) .set obase 10
(poke) int<12> @ 0#B
(int<12>) 1279
@end example

@node Unaligned Integers
@subsection Unaligned Integers

@cindex IO devices
@cindex IO spaces
We have mentioned above that the data stored in computers, that we
edit with poke, is arranged as a sequence of bytes.  The entities we
edit with poke (that we call @dfn{IO devices}) are presented to us as
IO spaces.  Up to now, we have accessed this IO space in terms of
bytes, in commands like @code{dump :from 32#B} and in expressions like
@code{2UB + byte @@ 0#B}.  We said that mapped integers are built from
bytes read from the IO space.

However, the IO space that poke offers to us is actually a space of
bits, not a space of bytes, and the poke values are mapped on this
space of bits.  The following figure shows this:

@example
poke values      |        uint<16> @@ 2#b         |
-----------      |                               |
IO space     |b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|
-----------  |               |               |               |
IO device    |     byte0     |     byte1     |     byte2     |
@end example

@noindent
The main consequence of this, that you can see in the figure above, is
that we can use offsets in mapping operations that are not
@dfn{aligned to bytes}.  You can specify an offset in bits, instead of
bytes, using the @code{#b} suffix instead of @code{#B}.  Little
@code{b} means bits, and big @code{B} means bytes.

Let's map an unaligned 16 bit unsigned integer in @file{foo.o}:

@example
(poke) dump :from 0#B :size 3#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4c                                  .EL
(poke) .set obase 2
(poke) byte @@ 0#B
0b01111111UB
(poke) byte @@ 1#B
0b01000101UB
(poke) byte @@ 2#B
0b01001100UB
(poke) .set endian big
(poke) uint<16> @@ 2#b
0b1111110100010101UH
@end example

Graphically:

@example
poke values      |        uint<16> @@ 2#b         |
-----------      |                               |
IO space     |0|1|1|1|1|1|1|1|0|1|0|0|0|1|0|1|0|1|0|0|1|1|0|0|
-----------  |               |               |               |
IO device    |     0x7f      |      0x45     |      0x4c     |
@end example

These three levels of abstractions make it very easy and natural to
work with unaligned data.  Imagine for example that you are poking
packages in a network protocol that is bit-oriented.  This means that
the packages will generally not be aligned to byte boundaries, but
still the payload stored in the packages contains integers of several
sizes.  poke allows you to directly map these integers as if they were
aligned to byte boundaries, and work with them.

However, when one tries to determine the correspondence between a
given poke value and the underlying bytes in the IO device, things can
get complicated.  This is particularly true when we map what we called
``weird numbers'', i.e. numbers with partial bytes.  As we saw, the
rules to build these numbers were expressed in terms of bytes.

In order to ease the visualization of the process used to build
integer values (especially if they are weird numbers, i.e. integers
with partial bytes) one can imagine an additional layer of ``virtual
bytes'' above the space of bits provided by the IO space.
Graphically:

@example
poke values       |        uint<16> @@ 2#b         |
-----------       |                               |
Virtual bytes     | virt. byte1   |  virt. byte2  |
-----------       |               |               |
IO space      |0|1|1|1|1|1|1|1|0|1|0|0|0|1|0|1|0|1|0|0|1|1|0|0|
-----------   |               |               |               |
IO device     |     0x7f      |      0x45     |      0x4c     |
@end example

It is very important to understand that the IO space is an abstraction
provided by poke.  The underlying file, or memory buffer, or whatever,
is actually a sequence of bytes; poke translates the operations on
integers, bits, bytes, etc into the corresponding byte operations,
which are far from trivial.  Fortunately, you can let poke to do that
dirty job for you, and abstract yourself from that complexity.

@node Integers of Different Sizes
@subsection Integers of Different Sizes

When integer values of different sizes are passed to an arithmetic or
relational operator, the ``smaller'' operand gets converted into the
size of the ``bigger'' operand.  For example:

@example
(poke) 1H + 2
3
@end example

@noindent
The operands are of size 16-bit and 32-bit respectively, and the
result is a 32-bit integer.  This is equivalent to:

@example
(poke) 1H as int<32> + 2
3
@end example

@node Buffers as IO Spaces
@section Buffers as IO Spaces

Files are not the only kind of entities that can be edited using
poke.  The bytes in memory buffers can be poked too!

@menu
* Creating Memory Buffers::	Allocating memory to poke.
* Copying Bytes::		Moving data between IO spaces.
* Saving Buffers in Files::	From memory to files.
@end menu

@node Creating Memory Buffers
@subsection Creating Memory Buffers

We have mentioned already that files are not the only entities that
can be edited using poke. Remember the dot-command @command{.file}
that opened a file as an IO space?

@example
(poke) .file foo.o
The current IOS is now `./foo.o'.
(poke) .info ios
  Id	Mode	Size		Name
* #0	rw	0x000004c8#B	./foo.o
@end example

@noindent
Memory buffers can be created using a similar dot-command,
@command{.mem}:

@example
(poke) .mem foo
The current IOS is now `*foo*'.
(poke) .info ios
(poke) .info ios
  Id    Mode    Size            Name
* #1            0x00001000#B    *foo*
  #0    rw      0x000004c8#B    ./foo.o
@end example

Note how the name of the buffer is built by prepending and appending
asterisks.  Therefore, the name of the buffer created by the command
@code{.mem foo} is @code{*foo*}.  Note also that the new buffer is
created with a size of 0x1000 bytes, or 4096 bytes.  The contents of
the buffer are zeroed:

@example
(poke) dump
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................
@end example

Memory buffer IO spaces grow automatically when a value is mapped
beyond their current size.  This is very useful when populating newly
created buffers.  However, for security reasons, there is a limit: the
IO spaces are only allow to grow 4096 bytes at a time.

When it comes to map values, there is absolutely no difference between
an IO space backed by a file and an IO space backed by a memory
buffer.  Exactly the same rules apply in both cases.

@node Copying Bytes
@subsection Copying Bytes

Memory buffer IO spaces are cheap, and they are often used as
``scratch'' areas.

Suppose for example we want to experiment with the ELF header of
@file{foo.o}.  We could open it in poke:

@example
(poke) .file foo.o
The current IOS is now `./foo.o'.
@end example

@noindent
The header of an ELF file is composed by the first 64 bytes in the
file:

@example
(poke) dump :size 64#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0100 3e00 0100 0000 0000 0000 0000 0000  ..>.............
00000020: 0000 0000 0000 0000 0802 0000 0000 0000  ................
00000030: 0000 0000 4000 0000 0000 4000 0b00 0a00  ....@.....@.....
@end example

We know that as soon as we poke something on an IO space, the
underlying file is immediately modified.  So if we start playing with
@file{foo.o}'s header, we may corrupt the file.  We could of course
make a copy of @file{foo.o} and work on the copy, but it is much
better to create a memory IO space and copy the ELF header there:

@example
(poke) .mem scratch
The current IOS is now `*scratch*'.
(poke) copy :from_ios 0 :from 0#B :size 64#B
(poke) dump :size 64#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0100 3e00 0100 0000 0000 0000 0000 0000  ..>.............
00000020: 0000 0000 0000 0000 0802 0000 0000 0000  ................
00000030: 0000 0000 4000 0000 0000 4000 0b00 0a00  ....@.....@.....
@end example

@noindent
The command @command{copy} above copies 64 bytes starting at byte 0
from the IO with id 0 (the file @file{foo.o}) to the current IO space
(the buffer @code{*scratch*}).

Once we are doing working with the copy of the ELF header, and
satisfied, we can copy it back to the file and close the memory IO
space:

@example
(poke) copy :from 0#B :size 64#B :to_ios 1
(poke) .close
The current IOS is now `./foo.o'.
@end example

@noindent
Note how the command arguments @code{:from_ios} and @code{:to_ios} are
assumed to be the current IO space if they are not explicitly
specified in the command invocation.  For detailed information on the
@command{copy} command, see @ref{copy}.

@node Saving Buffers in Files
@subsection Saving Buffers in Files

Another useful command when working with buffer IO spaces (and in
general, with any IO space) is @command{save}.  Lets say we want to
save a copy of the header of an ELF file in another file.  We could do
it the pokeish way:

@example
$ poke foo.o
[...]
(poke) save :from 0#B :size 64#B :file "header.dat"
@end example

@noindent
The command above saves the first 64 bytes in the current IO space
(which is backed by the file @file{foo.o}) into a new file
@file{header.dat} in the current working directory.

Lets now consider again the scenario where we are using a memory IO
space as a scratch area.  It is late in the night and we are tired, so
we would like to save the contents of the scratch buffer to a file, so
we can continue our work tomorrow.  This is how we would do that:

@example
(poke) .info ios
  Id    Mode    Size            Name
* #1            0x00001000#B    *scratch*
  #0    rw      0x000f4241#B    ./foo.o
(poke) save :from 0#B :size iosize (1) :file "scratch.dat"
@end example

@noindent
Here we used the built-in function @code{iosize}, that given an IO
space identifier returns its size.

@node Poking ASCII Strings
@section Poking ASCII Strings

poke provides useful abstractions to handle ASCII characters and
strings.  This section discusses these.

@menu
* Character Sets and Encodings::	ASCII, Unicode, ...
* From Bytes to Characters::		Working with ASCII codes
* ASCII Strings::			NULL-terminated strings.
* From Strings to Characters::		Indexing strings.
@end menu

@node Character Sets and Encodings
@subsection Character Sets and Encodings

@cindex character
@cindex character set
Computers understand text as a sequence of @dfn{codes}, which are
numbers identifying some particular @dfn{character}.  A character can
represent things like letters, digits, ideograms, word separators,
religious symbols, etc.  Collections of character codes are called
@dfn{character sets}.

@cindex ASCII
@cindex Latin-1
Some character sets try to cover one or a few similar written
languages.  This is the case of ASCII and ISO Latin-1, for example.
These character sets are small, i.e. just a few hundred codes.

@cindex Unicode
Other character sets are much more ambitious.  This is the case of
Unicode, that tries to cover the entire totality of human languages in
the globe, including the fictitious ones, like klingon.  Unicode is a
really big character set.

In order to store character codes in a computer's memory, or a file,
we need to @dfn{encode} each character code in one or more bytes.  The
number of bytes needed to encode a given character code depends on the
range of codes in the containing set.

ASCII, for example, defines 128 character codes: a single byte is
enough to encode every possible ASCII character.  It is very easy to
encode ASCII.

@cindex utf-8
Unicode, on the contrary, defines many thousand of character codes,
and has room for many more: we would need 31 bits in order to encode
any conceivable Unicode character code.  However, it would be wasteful
to use that many bits per character: most used character codes tend to
be in lower regions of the code space.  For example, the code
corresponding to the Latin letter @code{'a'} is a fairly small number,
whereas the codes corresponding to the Klingon alphabet are really big
numbers.  Consequently, some systems opt to just encode a subset of
Unicode, like the first 16 bits of the Unicode space, which is called
the Basic Multilingual Plane, and contains all the characters that
most people will ever need.  There are also variable-length encodings
of Unicode, that try to use as less bytes as possible to encode any
given code.  A particularly clever encoding of Unicode, designed by
Rob Pike, is backwards compatible with the ASCII encoding, i.e. it
encodes all the ASCII codes in one byte each, and the values of these
byte are the same than in ASCII.  This clever encoding is called
UTF-8.

@node From Bytes to Characters
@subsection From Bytes to Characters

@subsubsection Character Literals

poke has built-in support for ASCII, and its simple encoding: each
ASCII code is encoded using one byte.  Let's see:

@example
(poke) 'a'
0x61UB
@end example

@noindent
We presented poke with the character @code{a}, and it answered with
its corresponding code in the ASCII character set, which is 0x61.  In
fact, 'a' and 0x61UB are just two ways to write exactly the same byte
value in poke:

@example
(poke) 'a' == 0x61UB
1
(poke) 'a' + 1
0x62U
@end example

In order to make this more explicit, poke provides yet another synonym
for the type specifier @code{uint<8>}: @code{char}.

@subsubsection Classifying Characters

When working with characters it is very useful to have some
acquaintance of the ASCII character set, which is designed in a very
clever way with the goal of easing certain code calculations.  See
@ref{Table of ASCII Codes} for a table of ASCII codes in different
numeration bases.

Consider for example the problem of determining whether a byte we map
from an IO space is a digit.  Looking at the ASCI table, we observe
that digits all have consecutive codes, so we can do:

@example
(poke) defvar b = byte @@ 23#B
(poke) b >= '0' && b <= '9'
1
@end example

Now that we know that @code{b} is a digit, how could we calculate its
digit value?  If we look at the ASCII table again, we will find that
the character codes for digits are not only consecutive: they are also
ordered in ascending order @code{0}, @code{1}, ...  Therefore, we can
do:

@example
(poke) b
0x37UB
(poke) '0' - b
7UB
@end example

@noindent
@code{b} contains the ASCII code 0x37UB, which corresponds to the
character @code{7}, which is a digit.

How would we check whether @code{b} is a letter?  Looking at the ASCII
table, we find that lower-case letters are encoded consecutively, and
the same applies to upper-case letters.  This leads to repeat the
trick again:

@example
(poke) (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z')
0
@end example

@subsubsection Non-printable Characters

Not all ASCII code are printable using the glyph that are usually
supported in terminals.  If you look at the table in @ref{Table of
ASCII Codes}, you will find codes for characters described as ``start
of text'', ``vertical tab'', and so on.

These character codes, which are commonly known as @dfn{non-printable
characters}, can be represented in poke using its octal code:

@example
(poke) '\002'
0x2UB
@end example

@noindent
This is of course no different than using @code{2UB} directly, but in
some contexts the ``character like'' notation may be desirable, to
stress the fact that the byte value is used as an ASCII character.

@cindex escape sequence
Some of the non-printable characters also have alternative notations.
This includes new-line and horizontal tab:

@example
(poke) '\n'
0xaUB
(poke) '\t'
0x9UB
@end example

@noindent
These @code{\} constructions in character literals are called
@dfn{escape sequences}. See @ref{Characters} for a complete list of
allowed escapes in character literals.

@node ASCII Strings
@subsection ASCII Strings

@subsubsection String Values

Now that we know how to manipulate ASCII codes in poke, we may wonder
how can we combine them to conform words or, more generally,
@dfn{strings} of ASCII characters.

GNU poke has support for native ASCII string values.  The characters
conforming the string are written between @code{"} and @code{"}
characters, like in:

@example
(poke) "word"
"word"
@end example

@noindent
Note, and this is important, that string values are as atomic as
integer values: they are not really composite values.  The fact that
@code{"word"} contains an @code{r} at position 3 is like the fact that
the value @code{123} contains two tens.

Like in character literals, poke strings support several escape
sequences that help to denote non-printed characters, such as new
lines and horizontal tabs.  @xref{String Literals}.

@subsubsection Poking Strings

Lets start with a fresh memory buffer IOS @code{*scratch*}:

@example
(poke) .mem scratch
The current IOS is now `*scratch*'.
(poke) dump :size 48#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
@end example

@noindent
If we wanted to, somehow, store the word @code{word} in this IO space,
encoded in ASCII, we could proceed as:

@example
(poke) char @@ 0x12#B = 'w'
(poke) char @@ 0x13#B = 'o'
(poke) char @@ 0x14#B = 'r'
(poke) char @@ 0x15#B = 'd'
(poke) dump :size 48#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000010: 0000 776f 7264 0000 0000 0000 0000 0000  ..word..........
00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
@end example

@noindent
This worked.  The ASCII part of the @command{dump} output, which
interprets the bytes as ASCII, clearly shows the word @code{word} at
the offset where we poked the character values.  However, we can do
better: string values can be mapped themselves.

String values use the type specifier @code{string}.  As any other kind
of value in poke, they can be mapped from an IO space:

@example
(poke) string @@ 0x12#B
"word"
@end example

@noindent
Clearly that is the string resulting from the concatenation of the
character values that we poked before.

The question now is: how did poke know that the last character of the
string was the @code{d} at offset 0x15#B?  The fact the character code
0 (also known as the @dfn{NULL character}) at offset 0x16#B is
non-printable, doesn't imply it is not part of the ASCII character
set.  Clearly, we have to pick an ASCII code and reserve it to mark
the end of strings.  Like the C programming language, and countless
formats and systems do, poke uses the NULL character to delimit
strings.

Now consider this:

@example
(poke) "word"'length
4UL
(poke) "word"'size
40UL#b
@end example

@noindent
Using the @code{length} and @code{size} attributes, poke tells us that
the length of the string @code{"word"} is 4 characters, but the size
of the string value is 40 bits, or 5 bytes.  Why this discrepancy?
The @code{size} value attribute tells how much storage space a given
value required once mapped to an IO space, and in the case of strings
it should count the space occupied by the terminating NULL character.

Poking string values on the IO space is as straightforward as poking
integers:

@example
(poke) string @@ 0x22#B = "WORD"
(poke) dump :size 48#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000010: 0000 776f 7264 0000 0000 0000 0000 0000  ..word..........
00000020: 0000 574f 5244 0000 0000 0000 0000 0000  ..WORD..........
@end example

@subsubsection From Characters to Strings

Strings can be concatenated using the string-concatenation @code{+}
operators:

@example
(poke) "foo" + "bar"
"foobar"
@end example

@noindent
This operator requires two strings.  Therefore, if we wanted to append
a character to a string, we would get an error:

@example
(poke) "Putin" + 'a'
<stdin>:1:1: error: invalid operands in expression
"Putin" + 'a';
^~~~~~~~~~~~~
@end example

@noindent
It is possible to transform a character value (i.e. a byte value) into
a string composed by that character using a cast:

@example
(poke) 'a' as string
"a"
@end example

@noindent
Using that cast, we can now append:

@example
(poke) "Putin" + 'a' as string
"Putina"
@end example

@node From Strings to Characters
@subsection From Strings to Characters

Despite being atomic values, poke strings can be indexed in order to
retrieve individual characters:

@example
(poke) "word"[2]
0x72UB
@end example

@noindent
Note how the indexing is zero-based, i.e. the first position in the
string is referred as @code{[0]}, the second position with @code{[1]},
and so on.

If you specify a negative index, or an index that is too big, you will
get an error:
is raised:

@example
(poke) "word"[-1]
<stdin>:1:8: error: index is out of bounds of string
"word"[-1];
       ^
(poke) "word"[5]
<stdin>:1:8: error: index is out of bounds of string
"word"[5];
       ^
@end example

@c XXX
@c @section Printing
@c print and printf

@node Poking Arrays
@section Poking Arrays

Remember that string @code{EOF} near the beginning of @file{foo.o}?
Lets take a look again:

@example
(poke) dump :size 16#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
@end example

The bytes whose ASCII representation compose the string are at offsets
1, 2 and 3 bytes respectively.  In case we wanted to map them, we
could of course do something like this:

@example
(poke) byte @@ 1#B
0x45UB
(poke) byte @@ 2#B
0x4cUB
(poke) byte @@ 3#B
0x46UB
@end example

@noindent
As we learn in a previous section, we could even store them in
variables for later manipulation:

@example
(poke) defvar magic1 = byte @@ 1#B
(poke) defvar magic2 = byte @@ 2#B
(poke) defvar magic3 = byte @@ 3#B
@end example

However, there is a much better way to access consecutive groups of
bytes.  In this case, we are interested in the three bytes starting at
offset 1 byte.  We can get them using a single directive by issuing:

@example
(poke) byte[3] @@ 1#B
[0x45UB,0x4cUB,0x46UB]
@end example

@noindent
Which reads ``map three bytes starting at offset 1 byte''.  The result
value is a Poke @dfn{array}, of three elements.  The elements are the
individual byte values we asked for.  Note how the left operand to the
map operator @code{@@} specifies the kind of value we want to map: for
a single byte we use @code{byte} and for three bytes we use
@code{byte[3]}.

The array we get from the mapping operation contains the bytes exactly
in the same order than they appear in the file:

@example
(poke) dump :from 1#B :size 3#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000001: 454c 46                                  .ELF............
(poke) byte[3] @@ 1#B
[0x45UB,0x4cUB,0x46UB]
@end example

Arrays can also be written directly in the REPL. The array resulting
from the mapping above could have also be written directly as:

@example
(poke) [0x45UB, 0x4cUB, 0x46UB]
[0x45UB,0x4cUB,0x46UB]
@end example

Given an array value, its elements can be accessed by @dfn{indexing}.
The index is zero-based, i.e. the index @code{[0]} refers to the first
element of the array, @code{[1]} refers to the second, and so on.  Any
expression resulting in a number can be used as an index.

For example, this is how we can get the second byte of an array of
bytes:

@example
(poke) (byte[3] @@ 1#B)[1]
0x4cUB
@end example

@noindent
Storing the array in a variable allows us to index it several times
without having to write the mapping again and again:

@example
(poke) defvar magic = byte[3] @@ 1#B
(poke) magic[0]
0x45UB
(poke) magic[1]
0x4cUB
(poke) magic[2]
0x46UB
@end example

Now, what happens if you alter an element of the mapped array?  Say we
want to change @code{magic} to contain the characters for @code{EAF}
instead of @code{ELF}.  The ASCII code for the character @code{A} is
0x41, so we can issue:

@example
(poke) magic[1] = 0x41
@end example

Even better, poke allows us to use a different notation for byte
values: @code{'X'} which corresponds to the ASCII code of the
character @code{X}.  In this case:

@example
(poke) magic[1] = 'A'
@end example

@noindent
Obviously the value of the array stored in the variable changes:

@example
(poke) magic
[0x45UB,0x41UB,0x46UB]
@end example

@noindent
But what about the file?  Lets see:

@example
(poke) dump :size 16#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4146 0201 0100 0000 0000 0000 0000  .EAF............
@end example

@noindent
It also changed!  Why?  We saw that assigning a mapped single byte to
a variable actually assigned a copy of the byte, and therefore
altering the variable basically didn't cause an update of the file.
When we assign a mapped array to a variable, exactly the same happens:
a copy of the array is stored in the variable.  But still altering the
elements of the copied array alters the file contents.  The reason for
this is that Poke values are copied by @dfn{shared value}.  This
notion, which is used by many other programming languages, means that
when you copy a composite value (such as an array) the elements
contained in the resulting copy are the same than of the copied
entity.

Following this notion, will the following issue restore the original
values to the file?

@example
(poke) magic = ['E','L','F']
@end example

@noindent
The answer is no:

@example
(poke) dump :size 16#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4146 0201 0100 0000 0000 0000 0000  .EAF............
@end example

@noindent
The reason is that by assigning @code{['E','L','F']} to @code{magic},
we are replacing the original array (the mapped array) with a new one,
which is not mapped.  Therefore, any later modification of the
elements of the new array won't have any effect on @file{foo.o}:

@example
(poke) magic[1] = 'X'
(poke) dump :size 16#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 7f45 4146 0201 0100 0000 0000 0000 0000  .EAF............
@end example

@c XXX arrays of arrays
@c XXX array trimming
@c XXX 'length and 'size

@node Structuring Binary Data
@chapter Structuring Binary Data

In the previous chapter we learned how to manipulate pre-defined
entities like bytes, integers and strings.  One of the big points of
poke, however, is that it allows you to define your own entities.
This is achieved by defining data structures.

@menu
* Named Types::		The type abstraction.
@c * Poking Structs::
@end menu

@node Named Types
@section Named Types

@c XXX

@node Debugging Poke Programs
@chapter Debugging Poke Programs

@menu
* __LINE__ and __FILE__::	Error locations in traces.
@end menu

@node __LINE__ and __FILE__
@section @code{__LINE__} and @code{__FILE__}
@cindex @code{__FILE__}
@cindex @code{__LINE__}
@cindex location
@cindex tracing
When printing traces it is often useful to include a description of
the location of the trace.  The poke compiler provides two builtins
for this purpose.

@table @code
@item __LINE__
@cindex line number
Expands to an unsigned 64-bit integer containing the current line of
the program being compiled.
@item __FILE__
@cindex file name
Expands to a string with the name of the file currently being compiled.  If the
program is read from the standard input (like in the REPL) then this
is @code{"<stdin>"}.
@end table

@node Dot-Commands
@chapter Dot-Commands

@menu
* load command::		Loading pickles.
* file command::		Opening and selecting file IO spaces.
* mem command::			Opening and selecting memory IO spaces.
* nbd command::			Opening and selecting NBD IO spaces.
* ios command::			Switching between IO spaces.
* close command::		Closing IO spaces.
* doc command::                 Online manual.
* editor command::		Using an external editor for input.
* info command::		Getting information about open files, @i{etc}.
* set command::			Querying and setting global options.
* vm command::			Poke Virtual Machine services.
* exit command::		Exiting poke :(
@end menu

@node load command
@section @code{.load}
@cindex @code{.load}

The @command{.load} command loads a file containing Poke code and
compiles and executes it.  These files usually have the extension
@file{.pk}.

If a relative path is provided, then @file{@var{prefix}/share/poke}
is tried first as a base directory to find the specified file.  If it
is not found, then the current directory is tried next.

If the environment variable @code{POKEDATADIR} is defined, it replaces
@file{@var{prefix}/share/poke}.  This is mainly intended to test a
poke program before it gets installed in its final location.

If an absolute path is provided, it is used as-is.

@node file command
@section @code{.file}
@cindex @code{.file}
@cindex opening files
@cindex IO space
The @command{.file} command opens a new IO space backed by a file, or
switches to a previously opened file.  The syntax is:

@example
.file @var{path}
@end example

@cindex tags, file ID tags
Where @var{path} is a path to a file to open, which can be relative to
poke's current working directory or absolute.

Tilde expansion is performed in @var{path}, much like it's done in the
shell.  This means you can include special characters like @code{~}
(which will expand to your home directory) delimit the file name with
@code{"} in case it includes leading or trailing blank characters,
@i{etc}.

When a new file is opened it becomes the current IO space.  On that
point on, every map executed in the REPL or while loading a Poke
program will operate on that IO space:

@example
(poke) .file foo.o
The current file is now `foo.o'.
@end example

@node mem command
@section @code{.mem}
@cindex @code{.mem}
@cindex opening memory buffers
@cindex IO space
The @command{.mem} command opens a new IO space backed by a memory
buffer.  The syntax is:

@example
.mem @var{name}
@end example

@cindex tags, file ID tags
Where @var{name} is the name of the buffer to create.  Note that poke
adds prefix and trailing asterisk characters, to differentiate file
names from buffer names.

When a new memory buffer IOS is opened it becomes the current IO
space.  @xref{file command}.

@node nbd command
@section @code{.nbd}
@cindex @code{.nbd}
@cindex opening NBD buffers
@cindex IO space
The @command{.nbd} command opens a new IO space backed by an external
NBD server.  The syntax is:

@example
.nbd @var{uri}
@end example

@cindex tags, file ID tags
Where @var{uri} is the name of the newly created buffer, matching the
@url{https://github.com/NetworkBlockDevice/nbd/blob/master/doc/uri.md,
NBD URI specification}.

When a new NBD IOS is opened, it becomes the current IO
space.  @xref{file command}.

NBD support in GNU poke is optional, depending on whether poke was
compiled against @url{http://libguestfs.org/libnbd.3.html,, libnbd}.

For an example of connecting to the guest-visible content of a qcow2
image, with the default export name as exposed by using qemu as an NBD
server:

@example
$ qemu-nbd --socket=/tmp/mysock -f qcow2 image.qcow2
$ poke
(poke) .nbd nbd+unix:///socket=?/tmp/mysock
The current file is now `nbd+unix:///socket=?/tmp/mysock'.
@end example

@node ios command
@section @code{.ios}
@cindex @code{.ios}

@cindex tags, file ID tags
A list of open files, and their corresponding tags, can be obtained
using the @command{.info ios} command.  Once a tag is known, you can
use the @command{.ios} command to switch back to that file:

@example
(poke) .ios #1
The current IOS is now `foo.o'.
@end example

@node close command
@section @code{.close}
@cindex @code{.close}

@cindex IO space
The @command{.close} command closes the selected IO space.  The syntax
is:

@example
.close @var{#tag}
@end example

Where @var{#tag} is a tag identifying an open IO stream.

@node doc command
@section @code{.doc}
@cindex @code{.doc}
@cindex doc
The @command{.doc} command is used to display this manual in poke's REPL.
The syntax is:

@example
.doc [@var{node}]
@end example

@noindent
where @var{node} is an optional parameter which indicates the chapter
or section at which the manual should be opened.
This command uses the info program (@ref{Top,,, info, The GNU Texinfo Manual})
to interactively present the manual.
Hence, it will fail if info is not installed.
If poke is not running interactively then @command{.doc} does nothing.


@node editor command
@section @code{.editor}
@cindex @code{.editor}
@cindex editor
The @command{.editor} command (usually abbreviated as @command{.edit})
invokes an external text editor on a temporary file.  You can then
put contents on that file, save it and exit the editor.  At that point
poke will read the file contents, turn them into a single line and
execute them in the repl.
If poke is not running interactively, then @command{.editor} does nothing.

The editor used is identified by the @code{EDITOR} environment
variable.

@node info command
@section @code{.info}
@cindex @code{.info}

The @command{.info} command provides information about several kinds
of entities.  The recognized sub commands are:

@table @command
@item .info ios
Display a list of open files.

@example
(poke) .info ios
Id	Mode	Size		Name
* #0	rw	0x00000022#B	foo.bson
#1	r	0x0000df78#B	foo.o
@end example

@cindex IO space
The file acting as the current IO space is marked with an asterisk
character @code{*} at the beginning of the file.  The mode in which
the file is open is also specified.  The @code{Id} field is the tag of
the file that can be passed to the @command{.file} command in order to
switch to it as the new current IO space:

@example
(poke) .ios #1
The current file is now `foo.o'.
(poke) .info ios
  Id	Mode	Size		Name
  #0	rw      0x00000022#B	foo.bson
* #1	r       0x0000df78#B	foo.o
@end example

@item .info variable
@cindex variables
Shows a list of defined variables along with their current values and
the location where the variables were defined.
@item .info function
Shows a list of defined functions along with their prototypes and the
location where the functions were defined.
@end table

@node set command
@section @code{.set}
@cindex @code{.set}

@cindex global settings
The @command{.set} command allows you to inspect and set the value of
global settings.  The syntax is:

@example
.set @var{setting} [@var{value}]
@end example

Where @var{setting} is an identifier identifying the setting to
inspect or modify.  If @var{value} is specified, then it is the new
value for the setting.  If @var{value} is not specified the current
value of the setting is displayed.

The following settings can be handled with @command{.set}:

@table @code
@item endian
@cindex endianness
Byte endianness that will be used when mapping the IO space.  Valid
values are @code{big}, @code{little} and @code{host}.  The default
endianness is big endian.
@item obase
@cindex base, of displayed values
Numeric base to be used when displaying values in the REPL and in
@code{printf} statements using the @code{%v} format tag.  Valid values
are @code{2}, @code{8}, @code{10} and @code{16}.  Default value is
@code{10}.
@item pretty-print
@cindex pretty printing
Flag indicating whether pretty-printers shall be used when printing
values in the REPL and in @code{printf} statements using the @code{%v}
format tag.  Valid values are @code{yes} and @code{no}.  Default value
is @code{no}.
@item error-on-warning
@cindex errors
@cindex warnings
Flag indicating whether handling compilation warnings as errors.
Default value is @code{no}.
@item omode
@cindex mode, of displayed values
It defines the way the binary struct data is displayed. In @code{flat} mode
data is not formatted in any special way. In @code{tree} mode the struct data
is displayed in a hierarchical (tree) mode.
@item odepth
@cindex depth, of displayed struct fields
In @code{tree} and @code{flat} mode the struct fields are recursively displayed
up to the @code{depth}-th level. The default value @code{0} means no limit.
@item oindent
@cindex indent, as number of spaces
Number defining the number of spaces used for indentation for each level. Only
values >=1 and <= 10 are valid. Default value is '2'.
@item oacutoff
@cindex array cutoff
When displaying an array as struct field, display only the elements up to the
@code{cutoff} index and display @code{...} after that. Value of @code{0}
means no limit. This cutoff value is not used when directly displaying arrays
content.
@item omaps
@cindex maps, of displayed values
Flag indicating whether including mapping information when printing
out mapped values.
@end table

@node vm command
@section @code{.vm}
@cindex @code{.vm}

@cindex virtual machine
The Poke Virtual Machine (PVM) executes the programs that are the
result of the compilation of what you write in the REPL or the pickles
you load.  The @command{.vm} command provides sub-commands to interact
with the PVM.

@menu
* @:.vm disassemble::		PVM and native disassembler.
@end menu

@node @:.vm disassemble
@subsection @code{.vm disassemble}
@cindex disassembler
The @command{.vm disassemble} command provides access to the PVM
disassembler.  It supports the following subcommands:

@table @command
@item .vm disassemble expression @var{expr}
Dumps the assembler corresponding to the Poke expression @var{expr}.
@item .vm disassemble function @var{function}
Dumps the assembler corresponding to the Poke function called
@var{function}.  The function shall be reachable from the top-level.
@item .vm disassemble mapper @var{expr}
If @var{expr} is a mapped value, dumps the assembler corresponding to
its mapper function.
@item .vm disassemble writer @var{expr}
If @var{expr} is a mapped value, dumps the assembler corresponding to
its writer function.
@end table

The disassembler will provide a PVM disassembly by default, but it can
be passed the flag @command{/n} to do a native disassembly instead in
whatever architecture running poke.

@node exit command
@section @code{.exit}
@cindex @code{.exit}
@cindex quitting
@cindex @code{exit}
The @code{.exit} command exits poke.  The syntax is:

@example
.exit [@var{status}]
@end example

@noindent
Poke will terminate, returning the exit status @var{status}.
If @var{status} is omitted, then the exit status zero will be returned.

@node Commands
@chapter Commands

@menu
* dump::			Binary dumps.
* copy::			Copying data around.
* save::			Save data into a file.
@end menu

@node dump
@section @command{dump}
@cindex @command{dump}

At the most basic level, memory can be examined byte by byte.
To do this, use the @command{dump} command.
This command has the following prototype:

@example
defun dump = (off64 from = pk_dump_offset,
              off64 size = pk_dump_size,
              off64 group_by = pk_dump_group_by,
              int cluster_by = pk_dump_cluster_by,
              int ruler = pk_dump_ruler,
              int ascii = pk_dump_ascii) void:
@end example

@noindent
All arguments are optional, which means the simplest use of the command is
to simply type @command{dump}:

@example
(poke) dump
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000000: 9b07 5a61 4783 f306 4897 f37c fe39 4cd3  ..ZaG...H..|.9L.
00000010: b6a2 a578 8d82 7b7f 2076 374c 3eab 7150  ...x..@{. v7L>.qP
00000020: 31df 8ecb 3d33 ee12 429b 2e13 670d 948e  1...=3..B...g...
00000030: 86f1 2228 ae07 d95c 9884 cf0a d1a8 072e  .."(...\........
00000040: f93c 5368 9617 6c96 3d61 7b92 9038 a93b  .<Sh..l.=a@{..8.;
00000050: 3b0d f8c9 efbd a959 88d0 e523 fd3b b029  ;......Y...#.;.)
00000060: e2eb 51d5 cb5b 5ba9 b890 9d7a 2746 72ad  ..Q..[[....z'Fr.
00000070: 6cbd 6e27 1c7f a554 8d2e 77f9 315a 4415  l.n'...T..w.1ZD.
@end example


@noindent
The first row is the @dfn{ruler} which serves as a heading for each
subsequent row.   On the left hand side is the offset of the io space
under examination.   The centre block displays the hexadecimal
representation of each byte, and on the right hand side is their ascii
representation.   If a byte is not representable in ascii, then the
byte will be displayed as a dot.

By default the @command{dump} command reads from the currently
selected IO space.  However, it is possible to specify an explicit IO
space using the @code{ios} option:

@example
(poke) defvar myfile = open ("/path/to/file")
(poke) dump :ios myfile
@end example

@menu
* Information @command{dump} shows::         Changing what @command{dump} shows.
* Presentation options for @command{dump}::  Changing how @command{dump} shows it.
@end menu

@node Information @command{dump} shows
@subsection Information @command{dump} shows

By default @command{dump} displays 128 bytes of memory starting at offset 0#B.
You can change the quantity and starting offset by using the @code{size}
and @code{from} arguments.  For example:

@example
(poke) dump :from 0x10#B :size 0x40#B
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff  0123456789ABCDEF
00000010: b6a2 a578 8d82 7b7f 2076 374c 3eab 7150  ...x..@{. v7L>.qP
00000020: 31df 8ecb 3d33 ee12 429b 2e13 670d 948e  1...=3..B...g...
00000030: 86f1 2228 ae07 d95c 9884 cf0a d1a8 072e  .."(...\........
00000040: f93c 5368 9617 6c96 3d61 7b92 9038 a93b  .<Sh..l.=a@{..8.;
@end example

@noindent
Note that both the @code{size} and @code{from} arguments are offsets.
As such, both must be specified using @code{#} and an appropriate unit.
(@pxref{Offset Literals}).

The other arguments change the appearance of the dump.
If the @code{ruler} argument is zero, then the ruler will be omitted:

@example
(poke) dump :ruler 0 :size 0x40#B
00000000: b1fd 1608 2346 759c 46a6 aa94 6fcd 846a  ....#Fu.F...o..j
00000010: e39f 473f 3247 415f 174d a32b ed89 a435  ..G?2GA_.M.+...5
00000020: d2c6 2c52 bc82 e0a7 e767 31ea 84de 41e5  ..,R.....g1...A.
00000030: 2add 2869 e9c2 226b e222 8c74 4b94 af24  *.(i.."k.".tK..$
@end example

To omit the ascii
representation of the memory, call @command{dump} with the @code{ascii}
argument set to zero:

@example
(poke) dump :ruler 0 :size 0x40#B :ascii 0
00000000: 4393 85e7 0b0c 3921 5a26 39ec 2f5f 5f15
00000010: cc46 e6f3 d50f 6ae6 8988 d50e f8c4 d1c6
00000020: 5a2f 7c3e 490b 18d8 d867 4b6f 2549 1f6c
00000030: 34a9 a0d7 24d2 e9ac 9240 8247 10cb 4ba1
@end example

@node  Presentation options for @command{dump}
@subsection Presentation options for @command{dump}

By default, the hexadecimal display shows two bytes grouped together,
and then a space.   You can alter this behaviour using the @code{group_by}
parameter.

@example
(poke) dump :ascii 0 :size 0x40#B :group_by 4#B
00000000: 68f19a63 df2a8886 c466631c a7fdd5c7  h..c.*...fc.....
00000010: 3075746a 0adb03ca f5b1ff14 6166fa07  0utj........af..
00000020: 0dd3cfbd 8eff46a2 4152a81d 471beddf  ......F.AR..G...
00000030: a0501cae 8bfcec6f 7a4f5701 45ba9fc3  .P.....ozOW.E...
@end example

Another parameter is the @code{cluster_by} argument.
By setting @code{cluster_by} to @var{n}, this
causes @command{dump} to display an additional space after the @var{n}th
group has been displayed, and also in the corresponding position in
the ascii display:

@example
(poke) dump :size 0x40#B :group_by 2#B :cluster_by 4
76543210  0011 2233 4455 6677  8899 aabb ccdd eeff  01234567 89ABCDEF
00000000: 91b8 540d d4dc 49ae  3320 ba7d efd1 16ab  ..T...I. 3 .@}....
00000010: b1a8 5ea0 5846 8bea  f741 3f80 42bc 201f  ..^.XF.. .A?.B. .
00000020: 6e5e fa50 23fb f16a  d380 be8c fc98 d195  n^.P#..j ........
00000030: 7bbf fa3e 3fc2 43a4  2a1e 9763 2bd6 5d24  @{..>?.C. *..c+.]$
@end example

If you have a personal preference on how memory dumps should appear,
you can set the relevant @code{pk_dump_*} variables.   These
global variables serve as the defaults for @command{dump}, so this way, you
will not need to explicitly pass them when you call the function.

@node copy
@section @command{copy}
@cindex @command{copy}

The command @command{copy} allows to copy regions of data inside an IO
space, or between different IO spaces.

This command has the following prototype:

@example
defun copy = (int from_ios = get_ios,
              int to_ios = get_ios,
              off64 from = 0#B,
              off64 to = 0#B,
              off64 size = 0#B) void:
@end example

@noindent
All arguments are optional.  When invoked with no arguments,
@command{copy} does nothing.

The arguments @code{from} and @code{size} determine the region to
copy.  By default, this region is taken from the current IO space, but
this can be overwritten using the optional @code{from_ios} argument.

The argument @code{to} tells @command{copy} where to copy the stuff.
Again, this offset is applied to the current IO space by default, but
this can be overwritten using the @code{to_ios} argument.

Note that it is allowed for the source and destination ranges to
overlap.

@node save
@section @command{save}
@cindex @command{save}

Use the @command{save} command in order to write a region from an IO
space into a file in your file system.

This command has the following prototype:

@example
defun save = (int ios = get_ios,
              string file = "",
              off64 from = 0#B,
              off64 size = 0#B,
              int append = 0) void:
@end example

@noindent
All arguments are optional.  When invoked with no arguments,
@command{save} does nothing.

The arguments @code{from} and @code{size} are used to determine the
region of the IO space to save.  This is how you would extract and
save the contents of an ELF section to a file @file{out.text}:

@example
(poke) defvar s = elf_section_by_name (Elf64_Ehdr @@ 0#B, ".text")
(poke) save :file "out.text" :from s.sh_offset :size s.sh_size
@end example

@noindent
Both @code{from} and @code{size} are arbitrary offsets.  You should
keep in mind however that files are byte oriented.  Therefore saving,
say, nine bits to a file will actually write two bytes.

By default @command{save} will extract the data from the @dfn{current
IO space}.  However, it is possible to specify an alternative IOS by
using the @code{ios} argument.

By default @command{save} will truncate the output file, if it exists,
before starting writing.  If the argument @command{append} is
set as true, however, it will append to the existing contents of the
file.  In this case, the file should exist.

@node Configuration
@chapter Configuration

@menu
* pokerc::			User's initialization file.
* Styling::			Changing the appearance of poke's output.
@end menu

@node pokerc
@section @file{.pokerc}
@cindex @file{.pokerc}
Upon invocation poke will read and execute the commands of the file
@file{~/.pokerc} if it exists in your home directory.  This can
be disabled by passing @code{-q} or @code{--no-init-file} in the command
line.

Example of initialization file:

@example
# My poke configuration.
.set endian host
.set obase 16
.set pretty-print yes
pk_dump_cluster_by = 4
.load ~/.poke.d/mypickles.pk
@end example

@node Styling
@section Styling
@cindex styled output

XXX

@node The Poke Language
@chapter The Poke Language

@menu
* Integers::			Whole numbers.
* Offsets::			Memory sizes and offsets.
* Strings::			NULL-terminated strings.
* Arrays::			Homogeneous collections.
* Structs::			Heterogeneous collections.
* Types::			Declaring types.
* Assignments::			Changing the value of variables.
* Compound Statements::		Sequences of statements.
* Conditionals::		Conditional statements and expressions.
* Loops::			Statements to iterate on conditions.
* Expression Statements::	Using expressions for their side-effects.
* Functions::			Procedural abstraction.
* Endianness::			Byte ordering.
* Mapping::			Accessing IO spaces.
* Exception Handling::		Dealing with exceptional conditions.
* Printing::			Output in Poke programs.
* Comments::			Documenting Poke programs.
* Modules::			Loading pickles from Poke programs.
@end menu

@node Integers
@section Integers
@cindex integers

Most of the values manipulated in Poke programs are whole numbers,
also typically known as @dfn{integers} in computing parlance.  This is
because integers are pervasive in binary formats, often featuring
unusual characteristics in terms of size and/or alignment.  Single
bits denoting flags or packed small integers are good examples of
this.  In order to ease the manipulation of such entities, and unlike
most programming languages, Poke provides integer types of any number
of bits and a rich set of accompanying operators.

@menu
* Integer Literals::		Writing integers in different bases.
* Characters::			Another way to write small integers.
* Booleans::			Integers denoting truth values.
* Integer Types::		int<N> and uint<N>.
* Casting Integers::		Converting integers.
* Relational Operators::	Comparing integers.
* Arithmetic Operators::	Operating with integers.
* Bitwise Operators::		Getting and setting integer bits.
* Boolean Operators::		Equality and inequality.
* Integer Attributes::		Accessing properties of integer values.
@end menu

@node Integer Literals
@subsection Integer Literals
@cindex integer literals
Integers literals can be expressed in several numeration bases.

@cindex decimal
@emph{Decimal numbers} use the usual syntax @code{[1-9][0-9]*}.  For
example, @code{2345}.

@cindex octal
@emph{Octal numbers} are expressed using a prefix @code{0o} (or
@code{0O}) followed by one or more digits in the range @code{[0-7]}.
Examples are @code{0o0}, @code{0o100} and @code{0o777}.

@cindex hexadecimal
@emph{Hexadecimal numbers} are expressed using a prefix @code{0x} (or
@code{0X}) followed by one or more hexadecimal digits in the range
@code{[0-f]}.  Examples are @code{0x0} and @code{0xfe00ffff}.  Note
that both the @code{x} in the prefix and the letters in the
hexadecimal number are case insensitive.  Thus, @code{0XdeadBEEF} is a
valid (but ugly as hell) literal.

@cindex binary
@emph{Binary numbers} are expressed using a prefix @code{0b} (or
@code{0B}) followed by one or more binary digits in the range
@code{[0-1]}.  Examples of binary literals are @code{0b0} and
@code{0B010}.

Negative numbers, of any numeration base, are constructed using the
minus operator as explained below.  Therefore the minus symbol
@code{-} in negative numbers is not part of the literal themselves.

@subsubsection The digits separator @code{_}
@cindex digits separator
@cindex separator, digits separator
The character @code{_} can appear anywhere in a numeric literal
except as the first character.  It is ignored, and its purpose is to
make it easier for programmers to read them:

@example
0xf000_0000_0000_0000
0b0000_0001_0000_0001
@end example

@subsubsection Types of integer literals
@cindex integer literals
@cindex size of variables
@cindex bitsize
The type of a numeric literal is the smallest signed integer capable
of holding it, starting with 32 bits, in steps of powers of two and up
to 64 bits.@footnote{Rationale: the width of a C ``int'' is 32 bits in
most currently used architectures, and binary data formats are usually
modelled after C.}

So, for example, the value @code{2} has type @code{int<32>}, but the
value @code{0xffff_ffff} has type @code{int<64>}, because it is out of
the range of signed 32-bit numbers.

A set of suffixes can be used to construct integer literals of certain
types explicitly.  @code{L} or @code{l} is for 64-bit integers.
@code{H} or @code{h} is for 16-bit integers (also known as
@dfn{halves}), @code{B} or @code{b} is for 8-bit integers (also known
as @dfn{bytes}) and @code{n} or @code{N} is for 4-bit integers (also
known as @dfn{nibbles}).

Thus, @code{10L} is a 64-bit integer with value
@code{0x0000_0000_0000_000A}, @code{10H} is a 16-bit integer with
value @code{0x000A} and @code{10b} is a 8-bit integer with value
@code{0x0A}.

@cindex signedness
Similarly, the signed or unsigned attribute of an integer can be
explicitly specified using the suffix @code{u} or @code{U} (the
default are signed types).  For example @code{0xffff_ffffU} has type
@code{uint<32>} and @code{0ub} has type @code{uint<8>}.  It is possible
to combine width-indicating suffixes with signedness suffixes:
@code{10UL} denotes the same literal as @code{10LU}.

The above rules guarantee that it is always possible to determine the
width and signedness of an integer constant just by looking at it,
with no ambiguity.

@node Characters
@subsection Characters
@cindex characters
8-bit unsigned integers can use an alternative literal notation that
is useful when working with @emph{ASCII character codes}.  Printable
character codes can be denoted with @code{'c'}.

@cindex escape sequence
Non-printable characters can be expressed using escape-sequences.  The
allowed sequences are:

@table @code
@item \n
New-line character (ASCII 012).
@item \t
Tab character (ASCII 011).
@item \\
The backslash character.
@item \[0-9][0-9]?[0-9]?
Character whose ASCII code is the specified number, in octal.
@end table

Examples:

@example
'o'
'\n'
'\t'
'\\'
'\0'
@end example

The type of a character literal is always @code{char}, aka
@code{uint<8>}.

@node Booleans
@subsection Booleans
@cindex boolean values
Like in C, truth values in Poke are encoded using integers.  Zero
(@code{0}) denotes the logical value ``false'', and any integer other
than zero denotes the logical value ``true''.

@node Integer Types
@subsection Integer Types

Most general-purpose programming languages provide a small set of
integer types, each featuring a range corresponding to strategic
storage sizes: basically, signed and unsigned variants of 8, 16, 32,
64 bits.  As we have seen in the previous sections, suffixes like
@code{H} or @code{L} are used in Poke for that purpose.

However, in conventional programming languages when integers having an
``odd'' width (like 13 bits, for example) get into play for whatever
reason, the programmer is required to use the integer arithmetic
operators (and sometimes bit-wise operators) herself, in a clever way,
in order to achieve the desired results.

Poke, on the contrary, provides a rich set of integer types featuring
different widths, in both signed and unsigned variants.  The language
operators are aware of these types, and will do the right thing when
operating on integer values having different widths.

Unsigned integer types are specified using the type constructor
@code{uint<@var{n}>}, where @var{n} is the number of bits.  @var{n}
should be an integer literal in the range @code{[1,64]}.  Examples:

@example
uint<1>
uint<7>
uint<64>
@end example

Similarly, signed integer types are created using the type constructor
@var{int<@var{n}>}, where @var{n} is the number of bits.  @var{n}
should be an integer literal in the range @code{[1,64]}.  Examples:

@example
int<1>
int<8>
int<64>
@end example

Note that expressions are not allowed in the type integral constructor
parameters.  Not even constant expressions.  Thus, things like
@code{int<foo>} and @code{uint<2+3>} are not allowed.

@node Casting Integers
@subsection Casting Integers
@cindex casts
The right-associative unary operator cast @code{as} can be used to
derive a new integer value having a different type from an existing
value.

For example, this is how we would create a signed 12-bit integer value
holding the value 666:

@example
(poke) 666 as int<12>
(int<12>) 666
@end example

Note that the @code{666} literal is originally a 32-bit signed
integer.  The cast performs the conversion.

Casts between integer types are always allowed, and never fail.  If
the new type is narrower than the existing type, truncation may be
performed to accommodate the value in its new type.  For example, the
expression @code{0x8765_4321 as uint<16>} evaluates to @code{0x4321}.
If the new type is wider than the existing type, either zero-extension
or sign-extension is performed depending on the signedness of the
operand.

@cindex signedness
The semantics of the sign-extension operation depends on the
signedness of the value being converted, and on the currently
selected encoding for negative numbers.

When using two's complement encoding, converting a signed value will
always sign-extend regardless of the signedness of the target type.
Thus:

@example
(poke) -2H as uint<32>
0xfffffffeU
(poke) -2H as int<32>
0xfffffffe
@end example

Likewise, converting an unsigned value will always zero-extend
regardless of the signedness of the target type. Thus:

@example
(poke) 0xffffUH as uint<32>
0xffffU
(poke) 0xffffUH as int<32>
0xffff
@end example

@node Relational Operators
@subsection Relational Operators

@cindex comparison
The following binary relational operators are supported on integer
values, in descending precedence order:

@itemize
@item Equality @code{==} and inequality @code{!=}.
@item Less than @code{<} and less or equal than @code{<=}.
@item Greater than @code{>} and greater or equal than @code{>=}.
@end itemize

When applied to integer and character values, these operators
implement an arithmetic ordering.

These operators resolve in boolean values encoded as 32-bit integers:
@code{0} meaning false and @code{1} meaning true.

@node Arithmetic Operators
@subsection Arithmetic Operators
@cindex arithmetic
The following left-associative binary arithmetic operators are
supported, in descending precedence order:

@itemize
@item Exponentiation @code{**}, multiplication @code{*}, integer division @code{/}, integer
ceil-division @code{/^} and modulus @code{%}.
@item Addition @code{+} and subtraction @code{-}.
@end itemize

@cindex signedness
@cindex sign promotion
In all the binary arithmetic operations automatic promotions
(coercions) are performed in the operands as needed.  The rules are:

@itemize @bullet
@item If one of the operands is unsigned and the other operand is
signed, the second is converted to an unsigned value.
@item If the size in bits of one of the operands is bigger than the
size of the other operand, the second is converted to the same number
of bits.
@end itemize

The following right-associative unary arithmetic operators are
supported:

@itemize
@item Unary minus @code{-} and unary plus @code{+}.
@cindex minus
@end itemize

@node Bitwise Operators
@subsection Bitwise Operators
@cindex bitwise operators
The following left-associative bitwise binary operators are supported,
in descending precedence order:

@itemize
@item Bitwise shift left @code{<<.} and bitwise shift right @code{.>>}.
@cindex shifting
@item Bitwise AND @code{&}.
@cindex AND
@item Bitwise exclusive OR @code{^}.
@cindex exclusive OR
@item Bitwise inclusive OR @code{|}.
@cindex inclusive OR
@cindex OR
@item Bitwise concatenation @code{::}.
@cindex concatenation, bitwise
@end itemize

Both @code{<<.} and @code{.>>} operators perform logical shifting.
Unlike in many other programming languages, arithmetic right-shifting
operators are not provided.  This means that right shifting always
inserts zeroes at the most-significant side of the value operand,
whereas left shifting always inserts zeroes at the least-significant
side of the value operand.  Left shifting by a number of bits equal or
bigger than the value operand is an error, and will trigger either a
compile-time error or a run-time @code{E_out_of_bounds} exception.

Bitwise concatenation works with any integral type, of any bit length.

The following right-associative unary bitwise operators are supported:

@itemize
@item Bitwise complement @code{~}.
@cindex complement
@end itemize

@node Boolean Operators
@subsection Boolean Operators
@cindex boolean operators
The following left-associative, short-circuited binary logical
operators are supported, in descending precedence order:

@itemize
@item Logical AND: @code{&&}.
@item Inclusive OR: @code{||}.
@end itemize

The following right-associative unary logical operators are supported:

@itemize
@item Logical negation @code{!}.
@cindex negation
@end itemize

@node Integer Attributes
@subsection Integer Attributes
@cindex attributes, integer attributes

The following attributes are defined for integer values.

@table @code
@item size
Gives an offset with the storage occupied by the string.  This
includes the terminating null.  Examples:

@example
(poke) 10'size
0x20UL#b
(poke) 10N'size
0x4UL#b
(poke) (10 as int<1>)'size
0x1UL#b
@end example

@item signed
@cindex signedness
Gives 1 if the value is a signed integer, 0 otherwise.  Examples:

@example
(poke) 10'signed
1
(poke) 10UL'signed
0
@end example
@item mapped
Always 0 for integers.  (@pxref{Mapping}).
@end table


@node Offsets
@section Offsets
@cindex offset
@cindex united values

Poke uses united values to handle offsets and data sizes.  This is a
very central concept in poke.

@menu
* Why Offsets::			Byte-oriented or bit-oriented?
* Offset Literals::		Denoting offsets in Poke.
* Offset Units::		Pears and potatoes.
* Offset Types::		offset<...>.
* Casting Offsets::		Converting offsets.
* Offset Operations::		Operating with offsets.
* Offset Attributes::           Accessing properties of offset values.
@end menu

@node Why Offsets
@subsection Why Offsets

Early in the design of what is becoming GNU poke I was struck by a
problem that, to my surprise, would prove not easy to fix in a
satisfactory way: would I make a byte-oriented program, or a
bit-oriented program?  Considering that the program in question was
nothing less than an editor for binary data, this was no petty
dilemma.

Since the very beginning I had a pretty clear idea of what I wanted to
achieve: a binary editor that would be capable of editing user defined
data structures, besides bytes and bits.  I also knew I needed some
sort of domain specific language to describe these structures and
operate on them.  How that language would look like, and what kind of
abstractions it would provide, however, was not clear to me.  Not at
all.

So once I sketched an initial language design, barely something very
similar to C structs, I was determined to not continue with the poke
implementation until I had described as many as binary formats in my
language as possible.  That, I reckoned, was the only way to make sure
the implemented language would be expressive, complete and useful
enough to fulfil my requirements.

The first formats I implemented using my immature little language
included ELF, FLV, MP3, BSON@dots{} of them describing structures
based on whole bytes.  Even when they try to be compact, it is always
by packing bit-fields in elements that are, invariably, sized as a
multiple of bytes.  Consequently, the language I was evolving became
byte oriented as well.  No doubt also influenced by my C inheritance,
I would think of bit-fields either as a sort of second class citizen,
or as mere results of shifting and masking.

This worked well.  The language evolved to be able to express many
different aspects of these formats in a very nice way, like
variable-length data and holes in structures.  Consider the following
definition in what actually is @strong{not} valid today's Poke:

@example
deftype Data =
  struct
  @{
    byte magic;
    byte count;
    byte dstart;

    byte[count] data @@ dstart;
  @};
@end example

The data starts with a byte that is a magic number.  Then the size of
the data stored, in bytes, and then the data itself.  This data,
however, doesn't start right after @code{dstart}: it starts at
@code{dstart}, which is expressed as an offset, in bytes, since the
beginning of the Data.  I conceived struct field labels to be any
expression evaluating to an integer, which would be@dots{}, bytes
obviously.

@cindex deflate
Then, one day, it was the turn for IETF RFC1951, which is the
specification of the DEFLATE algorithm and associated file format.  Oh
dear.  Near the beginning of the spec document it can be read:

@quotation
This document does not address the issue of the order in which bits of
a byte are transmitted on a bit-sequential medium, since the final
data format described here is byte- rather than bit-oriented.
However, we describe the compressed block format in below, as a
sequence of data elements of various bit lengths, not a sequence of
bytes.
@end quotation

Then it goes on describing rules to pack the DEFLATE elements into
bytes.  I was appalled, and certainly sort of deflated as well.  The
purpose of my program was precisely to edit binary in terms of the
data elements described by a format.  And in this case, these data
elements came in all sort of bit lengths and alignments.  This can be
seen in the following RFC1951 excerpt, that describes the header of a
compressed block:

@quotation
Each block of compressed data begins with 3 header bits
containing the following data:
@example
first bit       BFINAL
next 2 bits     BTYPE
@end example

Note that the header bits do not necessarily begin on a byte boundary,
since a block does not necessarily occupy an integral number of bytes.
@end quotation

At this point I understood that my little language on the works would
be never capable to describe the DEFLATE structures naturally: C-like
bit-fields, masking and shifting, all based on byte-oriented
containers and boundaries, would never provide the slickness I wanted
for my editor.  I mean, just use C and get done with it.

This pissed me off.  Undoubtedly other formats and protocols would be
impacted in a similar way.  Even when most formats are byte oriented,
what am I supposed to tell to the people hacking bit-oriented stuff?
``Sorry pal, this is not supported, this program is not for you''?  No
way, I thought, not on my watch.

The obvious solution for the problem, is to be general.  In this case,
to express every offset and every memory size in bits instead of
bytes.  While this obviously gives the language maximum expressiveness
power, and is ideal for expressing the few bit-oriented formats, it
has the disadvantage of being very inconvenient for most situations.

To see how annoying this is, let's revisit the little Data element we
saw above.  In a bit-oriented description language, we would need to
write something like:

@example
deftype BitData =
  struct
  @{
    byte magic;
    byte count;
    byte dstart;

    byte[count] data @@ dstart * 8;
  @};
@end example

Yeah@dots{} exactly.  The @key{*} and @key{8}> keys in the keyboards of
the poke users would wear out very fast, not to mention their patience
as well.  Also, should I provide both @code{sizeof} and
@code{bitsizeof} operators?  Nasty.

I am very fond of the maxim ``Never write a program you would never
use yourself''@footnote{Actually it is Lord Vetinari's ``Never build a
dungeon you can't get out of.'' but the point is the same.}, so I
resigned myself to make GNU poke byte oriented, and to provide as many
facilities for operating on bit-fields as possible.

@noindent
Fortunately, I have smart friends@dots{}

@cindex rabbit herd
During one of the Rabbit Herd's Hacking
Weekends@footnote{@url{http://www.jemarch.net/rhhw}} I shared my
frustration and struggle with the other rabbits, and we came to
realize that offsets and data sizes in Poke should not be pure
magnitudes or mere integer values: they should be united.  They should
have units.

It makes full sense when you come to think about it.  For a program
like poke, it is only natural to talk about different memory units,
like bits, bytes, kilobytes, megabits, and so on.  Bits and bytes are
just too common units.  Apart from allowing me to express values in
different units, this approach also has other benefits as we will see
shortly.

I'm really grateful to Bruno Haible, Luca Saiu and Nacho Gonzalez for
putting me on the right track.

@node Offset Literals
@subsection Offset Literals

Poke provides a convenient syntax to provide united values, which are
called @dfn{offsets} (because in a binary editor you mostly use them
to denote offsets in the file you are editing):

@example
12#B
7#b
1024#KB
@end example

@cindex magnitude
@cindex kilobytes
The offsets above denote twelve bytes, seven bits and one thousand
twenty four kilobytes, respectively.  The unit can be separated from
the magnitude by blank characters, so you can write the following
instead if you are so inclined:

@example
12 #B
7 #b
(1024 * 1024) #Kb
@end example

Note how the magnitude part of an offset doesn't need to be constant.
If the variable @code{a} contains an integer, this is how you would
denote ``a bytes'':

@example
a#B
@end example

In the offset syntax units are specified as @code{#@var{unit}}, where
@var{unit} is the specification of an unit.  See the next section for
details.

@node Offset Units
@subsection Offset Units

There are several ways to express the unit of an offset, which is
always interpreted as a multiple of the basic unit, which is the bit
(one bit).

@subsubsection Named Units

The first way is to refer to an unit by name.  For example, @code{2#B}
for two bytes.  Units are defined using the @code{defunit}
construction:

@example
defunit @var{name} = @var{constant_expression};
@end example

Where @var{name} is the name of the unit, and
@var{constant_expression} is a constant expression that should
evaluate to an integral value.  The resulting value is always coerced
into an unsigned 64-bit integer.

Note that unit names live in a different namespace than variables and
types.  However, when a given name is both a type name and an unit
name in an unit context, the named unit takes precedence:

@example
(poke) deftype xx = int
(poke) defunit xx = 2
(poke) 1#xx
1#2
@end example

Many useful units are defined in the standard library.  @xref{Standard
Units}.

@subsubsection Arbitrary Units

It is also possible to express units in multiples of the base unit,
which is the bit.  Using this syntax, it becomes possible to express
offsets in any arbitrary unit, as disparate as it may seem:

@example
17#3
0#12
8#1
@end example

That's it: 17 units of 3 bits each, zero units of 12 bits each,
and eight units of 1 bit each.  Note that the unit should be greater
than 0.

@subsubsection Types as Units

But then, why stop there?  Poking is all about defining data
structures and operating on them@dots{} so why not use these structures
as units as well?  Consider the following struct:

@example
deftype Packet = struct @{ int i; long j; @};
@end example

The size of a @code{Packet} is known at compile time (which is not
generally true for Poke structs).  Wouldn't it be nice to use it as a
unit in offsets?  Sure it is:

@example
23#Packet
@end example

The above is the size occupied by 23 packets.  Any type whose size is
known at compile time can be specified as an offset unit.

@cindex ELF
Expressing offsets as united values also relieves the programmer from
doing many explicit unit conversions: poke can do them for you.
Consider for example an ELF section header.  One of its fields is the
size of the described section, in bytes:

@example
deftype Elf64_Shdr =
  struct
  @{
   @dots{}
   offset<Elf64_Xword,B> sh_size;
   @dots{}
  @};
@end example

If a given section is to contain, say, relocations with addends,
we can set its size doing something like this:

@example
shdr.sh_size = 10#Elf64_Rela;
@end example

@noindent
Instead of doing the conversion to bytes explicitly.

@cindex magnitude
If the magnitude of an offset is 1 then it is allowed to omit it
entirely.  To denote one kilobyte, for example, we can write
@code{#KB}.

@node Offset Types
@subsection Offset Types

Offset types are denoted as @code{offset<@var{base_type},@var{unit}>},
where @var{base_type} is an integer type and @var{unit} the
specification of an unit.

The offset base type is the type of the magnitude part of the united
value.  It can be any integer type, signed or unsigned, of any size.

The unit specification should be one of the unit identifiers that are
allowed in offset literals (see above), a constant positive integer or
the name of a Poke type whose size is known at compile time.

@cindex kilobits
Let's see some examples.  A signed 32-bit offset expressed in bytes
has type @code{offset<int<32>,B>}.  An unsigned 12-bit offset
expressed in kilobits has type @code{offset<uint<12>,Kb>}.  The latter
type can also be written using an explicit integer unit like in
@code{offset<uint<12>,1024>}.  Finally, a signed 64-bit offset in units
of ``packets'', where a packet is denoted with a Poke type
@code{Packet} has type @code{offset<uint<64>,Packet>}.

@node Casting Offsets
@subsection Casting Offsets
@cindex casts
The right-associative unary operator cast @code{as} can be used to
derive a new offset value having a different type from an existing
value.

For example, this is how we would create a signed 12-bit offset in
units bytes:

@example
(poke) 1024#b as offset<int<12>,B>
(int<12>) 128#B
@end example

@cindex magnitude
The same rules governing conversion of integers apply for the
magnitude part.  Depending on the unit, there can be truncation, like
in:

@example
(poke) 9#b as offset<int,B>
1#B
@end example

@node Offset Operations
@subsection Offset Operations
@cindex offset algebra
Poke supports a little algebra for offsets.

@subsubsection Addition and subtraction
@cindex addition
@cindex subtraction
The addition or subtraction of two offsets results in another offset.
Examples:

@example
(poke) 1#B + 1#b
9#b
(poke) 2#KB - 1024#B
1024#B
@end example

The unit of the result is the greatest common divisor of the units of
the operands.

@subsubsection Multiplication by a scalar
@cindex multiplication
Multiplying an offset by a magnitude gives you another offset.
Examples:

@example
(poke) 8#b * 2
16#b
(poke) 16#MB * 0
0#MB
@end example

The unit of the result is the same as the unit of the offset
operand.

Note that multiplying two offsets is not supported.  This makes sense,
since computer memory is linear, and therefore it wouldn't make any
sense to have units like @code{#B@sup{2}}.

@subsubsection Division
@cindex division
Dividing two offsets gives you a magnitude.  Examples:

@example
(poke) 16#b / 1#B
2
(poke) 1024#MB / 512#Mb
16
@end example

Dividing offsets is the Pokish way of converting memory magnitudes
between different units: just use units like you do when doing physics
or working with units in other contexts.

@cindex kilobits
For example, using the syntactic trick of omitting the magnitude (in
which case it is assumed to be 1) it is very natural to write
something like the following to convert from kilobits to bytes:

@example
(poke) 24 #Kb/#B
3072
@end example

There is also a ceil-division operator for offsets, with the same
semantics as the ceil-division for integers:

@example
(poke) 10#B /^ 3#B
4
@end example

@subsubsection Modulus
@cindex modulus
The modulus of two offsets gives you another offset with the expected
semantics.  Examples:

@example
(poke) 9#b % 1#B
1#b
(poke) 1#B % 9#b
8#b
@end example

The unit of the result is the greatest common divisor of the units of
the operands.

@node Offset Attributes
@subsection Offset Attributes
@cindex attributes, offset
The following attributes are defined for offset values.

@table @code
@item size
Gives an offset with the storage occupied by the offset.  Examples:

@example
(poke) 10#B'size
0x20UL#b
(poke) 10N#B'size
0x4UL#b
@end example
@item magnitude
Gives the magnitude part of the offset.  Examples:

@example
(poke) 10#B'magnitude
10
(poke) 2H#b'magnitude
2H
@end example
@item unit
Gives a number with the unit of the offset, expressed in bits.
Examples:

@example
(poke) 10#B'unit
8UL
(poke) 2H#b'unit
1UL
@end example
@item mapped
Always 0 for offsets.  (@pxref{Mapping}).
@end table


@node Strings
@section Strings
@cindex strings

Poke supports a notion of @dfn{strings} which is very similar to the C
programming language: a string value is a sequence of characters that
is terminated by the so-called @dfn{null character}.

The standard library provides functions which process strings.
@xref{String Functions}.

@menu
* String Literals::		Writing string values.
* String Types::		string.
* String Indexing::		Accessing the characters of a string.
* String Concatenation::        Building new strings.
* String Attributes::           Accessing properties of string values.
@end menu

@node String Literals
@subsection String Literals

NULL-terminated sequences of ASCII codes can be denoted using the
following syntax:

@example
"foo"
@end example

Poke string values are very similar to C strings.  They comprise a
sequence of 8-bit character codes, terminated by the value @code{0UB}.

The following escape sequences are supported inside string literals:

@table @code
@item \n
Denotes a new line character.
@item \t
Denotes an horizontal tab.
@item \\
Denotes a backlash @code{\} character.
@item \"
Denotes a double-quote @code{"} character.
@end table

@node String Types
@subsection String Types

Every string value in Poke is of type @code{string}.

@node String Indexing
@subsection String Indexing
@cindex indexing, into strings
Poke supports accessing the characters in a string using the array
indexing notation.  The indexes are in the @code{[0,@var{n}]} range,
where @var{n} is the length of the string minus one.  Note the length
doesn't include the null character, @i{i.e.} it is not possible to access
the terminating null.  Examples:

@example
(poke) "foo"[0]
0x66UB
(poke) "foo"[1]
0x6fUB
@end example

@cindex exceptions
If the passed index is less than zero or it is too big, an
@code{E_out_of_bounds} exception is raised:

@example
(poke) "foo"[-1]
unhandled out of bounds exception
(poke) "foo"[3]
unhandled out of bounds exception
@end example

@node String Concatenation
@subsection String Concatenation
@cindex concatenation, strings
Strings can be concatenated using the @code{+} operator.  This works
like this:

@example
(poke) "foo" + "bar"
"foobar"
@end example

Note how the null character terminating the first string is removed.
Therefore, the length of the concatenation of two given strings
of lengths @code{N} and @code{M} is always @code{N+M-1}.

Concatenation and indexing are useful together for building strings.
A string can be created empty, and additional characters added to it
by means of concatenation:

@example
(poke) defvar bytes = "";
(poke) bytes = bytes + 'x' as string;
@end example

Then, we can retrieve characters from the string we built using
indexing:

@example
(poke) bytes[0]
0x78UB
@end example

Additionally, the @code{*} operator allows to ``multiply'' a string by
concatenating it with itself a given number of times.  This works like
this:

@example
(poke) "foo" * 3
"foofoofoo"
(poke) "foo" * 0
""
@end example

This is useful for building strings whose length is not known at
compile time.  For example:

@example
defun make_empty_string = (int length) string:
@{
   return " " * length;
@}
@end example

@node String Attributes
@subsection String Attributes
@cindex attributes, string attributes
The following attributes are defined for string values.

@table @code
@item length
Gives the number of characters composing the string, not counting the
terminating null.  Examples:

@example
(poke) "foo"length
3UL
(poke) ""'length
0UL
@end example

@item size
Gives an offset with the storage occupied by the string.  This
includes the terminating null.  Examples:

@example
(poke) "foo"'size
32UL#b
(poke) ""'size
8UL#b
@end example
@item mapped
Always 0 for strings.  (@pxref{Mapping}).
@end table

@node Arrays
@section Arrays
@cindex arrays

Arrays are homogeneous collections of values.

@menu
* Array Literals::		Writing array values.
* Array Types::			Bounded and unbounded arrays.
* Array Comparison::		Comparing array values.
* Array Indexing::		Accessing values stored in arrays.
* Array Trimming::		Working with array pieces.
* Array Elements::		Checking for array elements.
* Array Attributes::		Accessing properties of array values.
@end menu

@node Array Literals
@subsection Array Literals

Array literals are constructed using the following syntax:

@example
[@var{exp},@var{exp}@dots{}]
@end example

Where @var{exp} is an arbitrary expression.

For example, @code{[1,2,3]} constructs an array of three signed 32-bit
integers.  Likewise, @code{['a','b','c']} constructs an array of three
unsigned 8-bit integers (characters).  For convenience, a trailing
comma is accepted but not required.

The type of the array literal is inferred from the type of its
elements.  Accordingly, all the elements in an array literal must be
of the same type.  Examples of invalid array literals, that will raise
a compilation-time error if evaluated, are:

@example
[1,2u,3]
[1,0xffff_ffff,3]
['a',"b",'c']
@end example

Array literals must contain at least one element.  Accordingly,
@code{[]} is not a valid array literal.

@cindex matrices
This is how a @code{3x3} matrix could be constructed using an array of
arrays:

@example
[[1,2,3],[4,5,6],[7,8,9],]
@end example

It is possible to refer to specific elements when constructing array
literals.  For example, @code{[1,2,3,.[3] = 4]} denotes the same
array as @code{[1,2,3,4]}.

This allows creating arrays without having to specify all its
elements; every unspecified element takes the value of the first
specified element to its right.  For example, @code{[.[2] = 2]}
denotes the same array as @code{[2,2,2]}.

Note that an array element can be referenced more than once.  When
that happens, the final value of the element is the last specified.
For example, @code{[1,2,3,.[1]=10]} denotes the array @code{[1,10,3]}.

@node Array Types
@subsection Array Types

There are three different kind of array types in Poke.

@dfn{Unbounded} arrays have no explicit boundaries.  Examples are
@code{int[]} or @code{Elf64_Shdr[]}.  Arrays can be @dfn{bounded by
number of elements} specifying a Poke expression that evaluates to an
integer value.  For example, @code{int[2]}.  Finally, arrays can be
@dfn{bounded by size} specifying a Poke expression that evaluates to
an offset value.  For example, @code{int[8#B]}.

@subsubsection Writing unbounded array literals
@cindex unbounded arrays
The type of an array literal is always bounded by number of elements.
For example, the type of @code{[1,2,3]} is @code{int[3]}.  If what we
want is an unbounded array literal we can obtain it with a case like
@code{[1,2,3] as int[]}.

@subsubsection Array boundaries and closures
@cindex closures
Poke arrays are rather peculiar.  One of their seemingly bizarre
characteristics is the fact that the expressions calculating their
boundaries (when they are bounded) evaluate in their own lexical
environment, which is captured.  In other words: the expressions
denoting the boundaries of Poke arrays conform closures.  Also, the
way they evaluate may be surprising.  This is no capricious.

When an array type is bounded, be it by number of elements or by size,
the expression indicating the boundary doesn't need to be constant and
it can involve variables.  For example, consider the following type
definition:

@example
defvar N = 2;
deftype List = int[N*2];
@end example

@noindent
Let's map a @code{List} at some offset:

@example
(poke) List @@ 0#B
[0x746f6f72,0x303a783a,0x723a303a,0x3a746f6f]
@end example

As expected, we get an array of four integers.  Very good,
obviously the boundary expression @code{N*2} got evaluated
when defining the type @code{List}, and the result of the
evaluation was @code{4}, right?.  Typical semantics like in my
garden variety programming language@dots{}?  Right?!?

Well, not really.  Let's modify the value of @code{N} and map
a @code{List} again@dots{}

@example
(poke) N = 1
(poke) List @@ 0#B
[0x746f6f72,0x303a783a]
@end example


Yes, The boundary of the array type changed@dots{} on, this is Poke,
was you @strong{really} expecting something typical? ;)

What happens is that at type definition time the lexical environment
is captured and a closure is created.  The body of the closure is the
expression.  Every time the type is referred, the closure is
re-evaluated and a new value is computed.

Consequently, if the value of a variable referred in the expression
changes, like in our example, the type itself gets updated
auto-magically.  Very nice but, why is Poke designed like this?  Just
to impress the cat?  Nope.

In binary formats, and also in protocols, the size of some given data
is often defined in terms of some other data that should be decoded
first.  Consider for example the following definition of a
@code{Packet}:

@example
deftype Packet =
  struct
  @{
    byte size;
    byte[size] payload;
  @};
@end example

Each packet contains a 8-bit integer specifying the size of the
payload transported in the packet.  The payload, a sequence of
@code{size} bytes, follows.

In struct types like the above, the boundaries of arrays depend on
fields that have been decoded before and that exist, like variables,
in the lexical scope captured by the struct type definition (yes,
these are also closures, but that's for another article.)  This
absolutely depends on having the array types evaluate their bounding
expressions when the type is used, and not at type definition time.


@noindent
To show this property in action, let's play a bit:

@example
(poke) defvar data = byte[4] @@ 0#B
(poke) data[0] = 2
(poke) data[1] = 3
(poke) data[2] = 4
(poke) data[3] = 5
(poke) dump
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff
00000000: 0203 0405 0000 0000 0000 0000 0000 0000
00000010: 0000 0000 0000 0000 0000 0000 0000 0000
(poke) defvar p1 = Packet @@ 0#B
(poke) defvar p2 = Packet @@ 1#B
(poke) p1
Packet @{size=0x2UB,payload=[0x3UB,0x4UB]@}
(poke) p2
Packet @{size=0x3UB,payload=[0x4UB,0x5UB,0x0UB]@}
@end example

Now, let's change the data and see how the sizes of the payloads
are adjusted accordingly:

@example
(poke) data[0] = 1
(poke) data[1] = 0
(poke) p1
Packet @{size=0x1UB,payload=[0x0UB]@}
(poke) p2
Packet @{size=0x0UB,payload=[]@}
@end example

So, as we have seen, Poke's way of handling boundaries in array types
allows data structures to adjust to the particular data they contain,
so usual in binary formats.  This is an important feature, that gives
Poke part of its feel and magic.

@node Array Comparison
@subsection Array Comparison
@cindex comparing, arrays

The equality operator (@code{==}) and the inequality operator
(@code{!=}) can be applied to arrays.  Examples:

@example
(poke) [1,2,3] == [1,2,3]
1
(poke) [[1,2],[3,4]] != [[5,6],[7,8]]
1
@end example

Note that the array elements are compared recursively.

@node Array Indexing
@subsection Array Indexing
@cindex indexing, into arrays

Arrays are indexed using the usual notation, providing an index
enclosed between square brackets with @code{[} and @code{]}:

@example
(poke) [1,2,3][0]
1
(poke) [1,2,3][1]
2
@end example

The index should be an expression that evaluates to an integer value,
and it is promoted to an unsigned 64-bit integer when needed.

@cindex exceptions
The valid range for the index is @code{[0,@var{n}]} where @var{n} is
the number of elements stored in the array minus one.  If the passed
integer is out of that range, an @code{E_out_of_bounds} exception is
raised:

@example
(poke) [1,2,3][-1]
unhandled out of bounds exception
(poke) [1,2,3][3]
unhandled out of bounds exception
@end example

@node Array Trimming
@subsection Array Trimming

Indexing is used to fetch elements from arrays.  Another operation,
called @dfn{trimming}, allows you to extract a subset of the array, as
another array.

Trims use the following notation, where a range is specified between
square brackets.  Both sides of the range are included:

@example
(poke) [1,2,3][0:1]
[1,2]
(poke) [1,2,3][1:1]
[2]
(poke) [1,2,3][0:2]
[1,2,3]
@end example

If the minimum side of the range is omitted, it is assumed to be zero.
If the maximum side of the range is omitted, it is assumed to be the
length of the trimmed array minus one:

@example
(poke) [1,2,3][:1]
[1,2]
(poke) [1,2,3][1:]
[2,3]
(poke) [1,2,3][:]
[1,2,3]
@end example

The elements of the base array and the trimmed sub-array are copied by
shared value, exactly like when passing arguments to functions.  This
means that for simple types, copies of the elements are done:

@example
(poke) defvar a = [1,2,3]
(poke) defvar s = a[1:1]
(poke) s[0] = 66
(poke) a
[1,2,3]
@end example

However, for complex types like arrays and structs, the values are
shared:

@example
(poke) defvar a = Packet[] @@ 0#B
(poke) defvar s = a[1:1]
(poke) s[0].field = 66
(poke) a[1].field
66
@end example

@node Array Elements
@subsection Array Elements

The @code{in} operator can be used to determine whether a given
element is stored in an array.  Examples:

@example
(poke) 2 in [1,2,3]
1
(poke) 10#B in [2#b,10*8#b,3#b]
1
(poke) 30#B in [2#b,10*8#b,3#b]
0
@end example


@node Array Attributes
@subsection Array Attributes
@cindex attributes, array attributes
The following attributes are defined for array values.

@table @code
@item size
Gives an offset with the storage occupied by the complete array.
Example:

@example
(poke) [1,2,3]'size
96UL#b
@end example
@item length
Gives the number of elements stored in the array.  Example:

@example
(poke) [1,2,3]'length
3
@end example
@item mapped
Gives 1 if the array is mapped, 0 otherwise.  Examples:

@example
(poke) defvar a = [1,2,3]
(poke) defvar b = int[3] @@ 0#B
(poke) a'mapped
0
(poke) b'mapped
1
@end example
@end table

@node Structs
@section Structs
@cindex structs

Structs are the main abstraction that Poke provides to structure data.
They contain heterogeneous collections of values.

@menu
* Struct Types::		Simple structs.
* Struct Constructors::		Constructing struct values.
* Struct Comparison::		Comparing struct values
* Field Endianness::            Specifying the endianness of integral fields.
* Accessing Fields::            Getting and fetching the values of fields.
* Field Constraints::		Specifying data integrity.
* Field Initializers::		Initial values for fields.
* Field Labels::		Explicit offsets for fields.
* Pinned Structs::		Fix the offset of fields.
* Unions::			Dealing with conditional data.
* Optional Fields::		Fields that may or may not exist.
* Casting Structs::		Converting structs from one type to another.
* Declarations in Structs::	Declaring stuff within a struct.
* Methods::			Declaring functions within a struct.
* Struct Attributes::		Accessing properties of struct values.
@end menu

@node Struct Types
@subsection Struct Types

A simple struct type definition in Poke looks like:

@example
deftype Packet =
  struct
  @{
    byte magic;
    uint<16> length;
    byte[length] data;
  @}
@end example

The above defines a ``Packet'', which consists on a magic number
encoded in a byte, a length encoded in an unsigned 16-bit integer, and
an array of @code{length} bytes, which is the payload of the packet.

Each entry in the struct type above defines a @dfn{struct field}.

Each field has a type, which is mandatory, and a name, which is
optional.  Fields without names are not accessible (not even within
the struct itself) but they are handy for expressing padding.
Example:

@example
deftype Imm64 =
  struct
  @{
    uint<32> lo;
    uint<32>;
    uint<32> hi;
  @}
@end example

It is not allowed to have several fields with the same name in the
same struct.  The compiler will complain if it finds such an
occurrence.

@node Struct Constructors
@subsection Struct Constructors

Once a struct type gets defined, there are two ways to build struct
values from it.  One is @dfn{mapping}.  @xref{Mapping Structs}.  The
other is using @dfn{struct constructor}, which is explained in this
section.

Struct constructors have the following form:

@example
@var{type_name} @{ [@var{field_initializer},]@dots{} @}
@end example

@noindent
where each @var{field_initializer} has the form:

@example
[@var{field_name}=]@var{exp}
@end example

Note how each field has an optional name @var{field_name} and a value
@var{exp}.  The expression for the value can be of any type.  For
convenience, a trailing comma is accepted but not required.

Suppose for example that we have a type defined as:

@example
deftype Packet =
  struct
  @{
    uint<16> flags;
    byte[32] data;
  @}
@end example

We can construct a new packet, with all its fields initialized to
zero, like this:

@example
(poke) Packet @{@}
Packet @{
  flags=0x0UH,
  data=[0x0UB,0x0UB,0x0UB,0x0UB,0x0UB,...]
@}
@end example

In the constructor we can specify initial values for some of the
fields:

@example
(poke) Packet @{ flags = 0x8 @}
Packet @{
  flags=0x8UH,
  data=[0x0UB,0x0UB,0x0UB,0x0UB,0x0UB,...]
@}
@end example

It is not allowed to specify initializers that are not part of the
type being constructed:

@example
(poke) Packet @{ foo = 10 @}
<stdin>:1:10: error: invalid struct field `foo' in constructor
Packet @{ foo = 10 @};
         ^~~
@end example

As we shall see later, many struct types define constraints on the
values their fields can hold.  This is a way to implement data
integrity.  While building struct values using constructors, these
constraints are taken into account.  For example, given the following
struct type:

@example
deftype BPF_Reg =
  struct
  @{
   uint<4> code < 11;
  @};
@end example

@noindent
we will get a constraint violation exception if we try to construct an
@code{BPF_Reg}:

@example
(poke) BPF_Reg @{ code = 20 @}
unhandled constraint violation exception
@end example

@node Struct Comparison
@subsection Struct Comparison
@cindex comparing, structs

The equality operator (@code{==}) and the inequality operator
(@code{!=}) can be applied to struct values.  Examples:

@example
(poke) E_eof == E_eof
1
(Poke) Packet @{ payload=0x3 @} != Packet @{ payload=0x4 @}
1
@end example

The struct values are compares recursively.

@node Field Endianness
@subsection Field Endianness

By default fields are accessed in IO space using the current default
endianness.  However, it is possible to annotate integral fields with
an explicit endianness, like in:

@example
deftype Foo =
  struct
  @{
    little int a;
    big int b;
    int c;
  @};
@end example

In the example above, the field @code{a} will be stored using
little-endian, the field @code{b} will be stored using big-endian, and
the field @code{c} will be stored using whatever current endianness.

@node Accessing Fields
@subsection Accessing Fields

Poke uses the usual dot-notation to provide access to struct fields.
Examples:

@example
(poke) defvar s = struct @{ i = 10, l = 20L @}
(poke) s.i
10
(poke) s.l
20L
@end example

Writing to fields is achieved by having the field reference in the
left side of an assignment statement:

@example
(poke) s.i = 100
(poke) s.l = 200
(poke) s
struct @{i=100,l=200L@}
@end example

@node Field Constraints
@subsection Field Constraints
@cindex constraints
It is common for struct fields to be constrained to their values to
satisfy some conditions.  Obvious examples are magic numbers, and
specification-derived constraints.

In Poke you can specify a field's constraint using the following
syntax:

@example
@var{field_type} @var{field_name} : @var{expression} ;
@end example

Where @var{expression} is an arbitrary Poke expression, that should
evaluate to an integer value.  The result is interpreted as a boolean.
@cindex ELF
As an example, this is how the ELF magic number is checked for:

@example
deftype Ctf_Preamble =
  struct
  @{
    uint<16> ctp_magic : ctp_magic == CTF_MAGIC;
    byte ctp_version;
    byte ctp_flags;
  @};
@end example

The constraint expression will often include the field where it is
installed, but that's not mandatory.

Field constraints play an important role in mapping.  On one side,
a map will fail if there is some constraint that fails.  On the other,
they guide the mapping of unbounded arrays.  @xref{Mapping Arrays}.

Another common usage of constraint expressions is to alter the global
state after decoding a field.  For example, this is how mapping an ELF
header sets the current endianness, depending on the value of
@code{ei_data}:

@example
byte ei_data : ei_data == ELFDATA2LSB       \
               ? set_endian (ENDIAN_LITTLE) \
               : set_endian (BIG);
@end example

Note that @code{set_endian} always returns @code{1}.

@node Field Initializers
@subsection Field Initializers

We saw that field constraints are useful to express magic numbers,
which are pretty common in binary formats.  Imagine a package has a
marker byte at the beginning, which should always be @code{0xff}.  We
could use a constraint like in:

@example
deftype Packet =
  struct
  @{
    byte marker : marker == 0xff;
    byte length;
    byte[length] payload;
  @};
@end example

This works well when mapping packages.  The constraint is checked and
a constraint violation exception is raised if the first byte of the
alleged package is not @code{0xff}.

However, suppose we want to construct a new @code{Package}, with no
particular contents.  We would use a constructor, but unfortunately:

@example
(poke) Packet @{ @}
unhandled constraint violation exception
@end example

What happened?  Since we didn't specify a value for the marker in the
struct constructor, a default value was used.  The default value for
an integral type is zero, which violates the constraint associated
with the field.  Therefore, we would need to remember to specify the
marker, every time we construct a new packet:

@example
(poke) Packet @{ marker = 0xff @}
Packet @{
  marker=0xffUB,
  length=0x0UB,
  payload=[]
@}
@end example

Unfortunately, such markers and magic numbers are not precisely very
memorable.  To help with this, Poke has the notion of @dfn{type field
initializers}.  Lets use one in our example:

@example
deftype Packet =
  struct
  @{
    byte marker = 0xff;
    byte length;
    byte[length] payload;
  @};
@end example

Note how the syntax is different than the one used for constraints.
When a field in a struct type has an initializer, two things happen:

@itemize @bullet
@item On one side, an implicit constraint is created for the field, of
the form @code{@var{field} == @var{initializer_expression}}.
@item On the other, the struct constructor will use the initializer
expression as the initial value for the field.
@end itemize

This achieves exactly what we want, in a very natural way:

@example
(poke) Packet @{@}
Packet @{
  marker=0xffUB,
  length=0x0UB,
  payload=[]
@}
@end example

Note that it is not possible to specify both a constraint and an
initializer in a struct type field.

Note also that it is considered good practice to design struct types
in a way that a constructor with no arguments will result in something
usable.

@node Field Labels
@subsection Field Labels

In structs, each field is associated with an offset, which is relative
to the beginning of the struct.  This is the offset used when reading
and writing the field from/to the IO space when mapping.

The offset is reset to zero bits at the beginning of the struct type,
and it is increased by the size of the fields:

@example
struct
@{
                /* Offset: 0#b */
    uint<1> f1; /* Offset: 1#b */
    sint<7> f2; /* Offset: 1#B */
    int     f3; /* Offset: 5#B */
    Bar     f4; /* Offset: 23#B */
@}
@end example

It is possible to specify an alternative offset for a field using a
@dfn{field label}.

Consider for example an entry in an ELF symbol table.  Each entry has
a @code{st_info} field which is 64-bits long, that in turn can be
interpreted as two fields @code{st_bind} and @code{st_type}.

The obvious solution is to encode @code{st_info} as a sub-struct, like
this:

@example
struct
@{
  elf32_word st_name;
  struct
  @{
    uint<60> st_bind;
    uint<4> st_type;
  @} st_info;
@}
@end example

However, that makes it inconvenient to access the value of
@code{st_info} as an integral value, using the bit-concatenation
operator @code{symbol.st_info.st_bind::symbol.st_info.st_type}.  We
can use labels instead:

@example
struct
@{
  elf32_word st_name;
  elf64_word st_info;
  uint<60> st_bind @ 4#B;
  uint<4> st_type @ 4#B + 60#b;
@}
@end example

The resulting struct has fields @code{st_info}, @code{st_bind} and
@code{st_type}, with the last two overlapping the first.

@node Pinned Structs
@subsection Pinned Structs
@cindex pinned structs
Pinned structs is a convenient way to write struct types where the
offset of all its fields is zero.  They are equivalent to C unions.

For example, consider the @code{_u} field below in a CTF type
description:

@example
deftype Ctf_Stype_V1 =
  struct
  @{
    Ctf_Name ctt_name;
    Ctf_Info_V1 ctt_info;
    pinned struct
    @{
      uint32 _size;		/* Size of entire type in bytes.  */
      uint32 _type;		/* Reference to another type.  */
    @} _u;
  @};
@end example

@node Unions
@subsection Unions
@cindex unions
XXX

@node Optional Fields
@subsection Optional Fields
@cindex struct fields

Sometimes a field in a struct is optional, i.e. it exists or not
depending on some criteria.  A good example of this is the ``extended
header'' in a MP3 id3v2 tag.  From the specification:

@example
The second bit (bit 6) indicates whether or not the header is followed
by an extended header. The extended header is described in section
3.2. A set bit indicates the presence of an extended header.
@end example

In order to express this in a Poke struct type, we could of course use
an union, like:

@example
deftype ID3V2_Tag =
  struct
  @{
    ID3V2_Hdr hdr;
    union
    @{
      ID3V2_Ext_Hdr hdr if hdr.extended_hdr_present;
      struct @{@};
    @} ext;
    @dots{}
  @}
@end example

That's it, we use an union with an empty alternative.  However, this
is a bit cumbersome.  Therefore Poke provides a more convenient way to
denote this:

@example
deftype ID3V2_Tag =
  struct
  @{
     ID3V2_Hdr hdr;
     IDV2_Ext_Hdr ext_hdr if hdr.extended_hdr_present;
     @dots{}
  @}
@end example

If both a constraint and an optional field expression are specified,
the second should follow the first.

For obvious reasons, optional fields are not allowed in unions.

@node Casting Structs
@subsection Casting Structs

It is possible to cast a struct of some particular type into another
struct type.   Examples:

@example
(poke) deftype Foo = struct @{ int i; int j; @};
(poke) deftype Bar = struct @{ int k; int j; @};
(poke) Bar @{j=2@} as Foo @{@}
Foo @{i=0,j=2@}
@end example

The semantics of the cast are exactly the same than constructing a
struct of the target type using the struct provided as an expression
to the cast.

@node Declarations in Structs
@subsection Declarations in Structs

XXX

@node Methods
@subsection Methods

XXX

@node Struct Attributes
@subsection Struct Attributes
@cindex attributes, struct attributes
XXX

@node Types
@section Types
@cindex types

@menu
* deftype::			Naming types.
* The any Type::		Polymorphism.
* The isa Operator::		Testing for types of values.
@end menu

@node deftype
@subsection @code{deftype}
@cindex @code{deftype}
The @code{deftype} directive allows you to declare named types.  The
syntax is:

@example
deftype @var{name} = @var{type};
@end example

Where @var{name} is the name of the new type, and @var{type} is either
a type specifier or the name of some other type.

The supported type specifiers are:

@table @code
@item int<@var{n}>, uint<@var{n}>
Integral types. @xref{Integer Types}.
@item string
The string type.  @xref{String Types}.
@item @var{type}[@var{boundary}]
Array types.  @xref{Array Types}.
@item struct @{ @dots{} @}
Struct types.  @xref{Struct Types}.
@item (@var{type},@dots{})@var{type}:
Function types.  @xref{Function Types}.
@item any
The @code{any} type is used to implement polymorphism.  @xref{The any Type}.
@cindex any, the @code{any} type
@end table

@node The any Type
@subsection The @code{any} Type
@cindex any, the @code{any} type
@cindex polymorphism
Poke supports polymorphism with the @code{any} type.  This type is
used in contexts where a value of any type is allowed.  For example,
this is how you would declare a function that prints the size of any
given value:

@example
defun print_size = (any value) void:
@{
  printf "%v\n", any'size;
@}
@end example

The rules for handling @code{any} values are simple:
@itemize @minus
@item Everything coerces to @code{any}.
@item Nothing coerces from @code{any}.
@end itemize

This means that using any operator that require certain types with
@code{any} values will fail: you have to cast them first.  Example:

@example
(poke) defun foo = (any v) int: @{ return v as int; @}
@end example

Arrays of @code{any}, @code{any[]}, are also supported:

@node The isa Operator
@subsection The @code{isa} Operator
@cindex isa operator
The binary operator @code{isa} allows you to check for the type of a given
value:

@example
(poke) 10 isa int
1
(poke) "foo" isa string
1
(poke) (Packet @ 0#B) isa Packet
1
(poke) 2 as int<3> isa uint<4>
0
@end example


@node Assignments
@section Assignments
@cindex assignment
The assignment statement has the form:

@example
@var{lvalue} = @var{exp};
@end example

Where @var{lvalue} is either:

@itemize @bullet
@item A variable.
@item A field reference like @code{foo.bar}.
@item An index reference like @code{foo[30]}.
@item A map of a simple type, like @code{int @@ 0#B}.
@end itemize

In all cases, the type of @var{exp} should match the type of the
referred entity.

Examples:

@example
(poke) foo = 10
(poke) packet.length = 4
(poke) packet.data = [1,2,3,4]
(poke) packet.data[2] = 666
(poke) int @@ 23#B = 23
(poke) string @@ str.offset = "foo"
@end example

@node Compound Statements
@section Compound Statements
@cindex compound statements
@cindex statements, compound statements
Compound statements have the form:

@example
@{ @var{stmt@dots{}} @}
@end example

Where @var{stmt@dots{}} is a list of statements, which can be themselves
compound statements.  Compound statements are primarily used to
sequence instructions like:

@example
@{
  do_a;
  do_b;
  do_c;
@}
@end example

A compound statement introduces a new lexical scope.  Declarations in
the compound statements are local to that statement.

Finally, compound statements can be empty: @code{@{ @}}.

@node Conditionals
@section Conditionals

Poke provides several conditional statements, and a ternary
conditional operator, which are discussed in the sections below.

@menu
* if-else::			Simple conditionals.
* Conditional Expression::	Conditionals in expressions.
@end menu

@node if-else
@subsection @code{if-else}
@cindex conditional statements
The @code{if-else} statement has the form:

@example
if @var{exp} @var{if_stmt} [else @var{else_stmt}]
@end example

Where @var{exp} is an expression that should evaluate to a boolean
value (@i{i.e.} to an integer), @var{if_stmt} is a sentence that will be
executed if @var{exp} holds true, and @var{else_stmt} is a sentence
that will be executed if @var{exp} holds false.  The @code{else} part
of the sentence is optional.


@node Conditional Expression
@subsection Conditional Expressions

Poke supports a ternary conditional expression that has the form:

@example
@var{condition} ? @var{true_expression} : @var{false_expression}
@end example

Where @var{condition} is an expression that should evaluate to a
boolean, and @var{true_expression} and @var{false_expression} are
expressions that have exactly the same type.

@node Loops
@section Loops
@cindex loops
@cindex flow control
Poke supports several iteration statements, which are discussed in the
sections below.

@menu
* while::		Iterate while a condition holds true.
* for-in::		Iterate over the elements of a container.
@end menu

@node while
@subsection @code{while}
@cindex @code{while}
The @code{while} statement has this form:

@example
while (@var{exp}) @var{stmt}
@end example

Where @var{exp} is an expression that should evaluate to a boolean
(@i{i.e.} to an integer) and @var{stmt} is an statement that will be
executed until @var{exp} holds false.

@cindex @code{break}
It is possible to leave the loop from within @var{stmt} using the
@code{break} statement.  Example:

@example
while (1)
@{
  [@dots{}]
  if (exit_loop)
    break;
@}
@end example

@node for-in
@subsection @code{for-in}
@cindex @code{for-in}
The @code{for-in} statement has this form:

@example
for (@var{formal} in @var{container} [where @var{exp}]) @var{stmt}
@end example

Where, in each iteration, the name @var{formal} will be associated
with consecutive values of @var{container}, which shall be an
expression evaluating to an array or a string.  @var{formal} is
available in @var{stmt}, which is the sentence executed in each
iteration.

If the @var{where} part is specified, then only iteration in which
@var{exp} holds true are processed.  @var{formal} can be referred in
@var{exp}.  Note that this doesn't mean the loop will stop after
processing the first ``not selected'' element.  See the following
example:

@example
(poke) for (c in [1,2,3,4] where c % 2) printf " %v", c
 1 3
@end example

@cindex @code{break}
It is possible to leave the loop from within @var{stmt} using the
@code{break} statement.


@node Expression Statements
@section Expression Statements

@cindex side effects
Poke is one of these languages where there is a clear separation
between @dfn{expressions} and @dfn{statements}.  However, it is often
useful to use an expression in the place of an statement, in order to
benefit from its side effects.

For that purpose Poke allows you to expressions as statements using
the following syntax:

@example
@var{exp};
@end example

The value computed by the expression will be discarded.

@node Functions
@section Functions
@cindex functions
@c XXX closures

@menu
* Function Declarations::	Writing functions.
* Optional Arguments::		Default values for arguments.
* Variadic Functions::		Functions taking any number of arguments.
* Calling Functions::		Invoking functions.
* Function Types::		Useful for defining interfaces.
@end menu

@node Function Declarations
@subsection Function Declarations
@cindex declarations, function declarations
A function is declared using the following syntax:
@cindex @code{defun}

@example
defun @var{name} = [(@var{formal},@dots{})] @var{ret_type}:
@{
   @dots{} body @dots{}
@}
@end example

Where @var{name} is the name of the function, which uses the same
namespace as variables and types and @var{ret_type} is the type of
the value returned by the function.  If the function returns no value
then it is @code{void}.

Each @var{formal} argument has the form:

@example
@var{type} @var{name} [= @var{exp}]
@end example

Where @var{type} is the type of the formal, @var{name} its name, and
@var{exp} is an optional expression that will be used to initialize
the argument in case it is not specified when the function is called.

The last formal argument can take the form @code{@var{name}@dots{}},
meaning the function is variadic.  @xref{Variadic Functions}.

If the function takes no arguments, it is possible to omit the list of
arguments entirely:

@example
defun hello = void: @{ print "Hello!\n"; @}
@end example

The @code{return} statement is used to return values in functions that
return a value.  Example:

@example
defun gcd = (uint<64> a, uint<64> b) uint<64>:
  @{
   if (b == 0)
     return a;
   else
     return gcd (b, a % b);
  @}
@end example

Note that reaching the end of a non-void function will trigger a
run-time error.

@node Optional Arguments
@subsection Optional Arguments
@cindex arguments
Optional function arguments are specified like:

@example
defun atoi = (string s, int b = 10) long: @{ @dots{} @}
@end example

Which means that if the base argument is not specified when passed to
@code{atoi} then it is initialized to 10.

Optional arguments should not appear before any non-optional argument
in function declarations.  The following is not valid Poke:

@example
defun foo = (int i = 10, int j) int: @{ return i + j; @}
@end example

Note that arguments declared before an optional argument can be used
in its initialization expression.  This is valid Poke:

@example
defun foo = (int n, int[n] array = init_array (n)) void: @{ @dots{} @}
@end example

@node Variadic Functions
@subsection Variadic Functions
@cindex variadic functions
Functions getting an arbitrary number of arguments are denoted like
this:

@example
defun printf (string fmt, args@dots{}) void: @{ @dots{} @}
@end example

The variadic argument shall be the last argument in the function, and
it is of type @code{any[]}.

@node Calling Functions
@subsection Calling Functions
@cindex calling, function calls
To call a function, write its name followed by the arguments in
parentheses.  Examples:

@example
foo (1,2,3)
bar ()
@end example

If the function takes no arguments then it is not necessary to write
the empty list of arguments.  Therefore the following two calls are
equivalent:

@example
bar ()
bar
@end example

There is an alternate syntax that can only be used in an
expression-as-statement context.  This alternate syntax is:

@example
@var{function_name} :@var{arg1} @var{val1}@dots{}
@end example

Where @var{arg1} is the name of an argument and @var{val1} the value
to pass for that argument.  This is useful when using functions as
commands in the REPL:

@cindex dump
@example
(poke) dump :from 12#B :size 16#B :ascii 0
@end example

Note that the named arguments can appear in any order.  The following
two calls are equivalent:

@example
dump :from 12#B :size 16#B
dump :size 16#B :from 12#B
@end example

@node Function Types
@subsection Function Types
@cindex function types
@cindex types, function types
Function types are denoted like:

@example
(@var{type},@dots{})@var{ret_type}:
@end example

Where @var{type} are the types of the arguments and @var{ret_type} is
the type of the value returned by the function.

Optional arguments are marked with a @code{?} after the type.  For
example, the type of the @code{atoi} function with declaration:

@example
defun atoi = (string s, int b = 10) long: @{ @dots{} @}
@end example

is @code{(string,int?)long:}.

If the function has variadic arguments, the position of the variadic
argument in the function type specifier contains @code{@dots{}}.  For
example, the type of a @code{printf} function with declaration:

@example
defun printf (string fmt, args@dots{}) void: @{ @dots{} @}
@end example

is @code{(string,@dots{})void:}.

@node Endianness
@section Endianness
@cindex endianness

Byte endianness is an important aspect of encoding data.  As a good
binary editor poke provides support for both little and big endian,
and will soon acquire the ability to encode exotic endianness like PDP
endian.  Endianness control is integrated in the Poke language, and is
designed to be easily used in type descriptions.

@menu
* set endian::			dot-command to get and set the endianness.
* Endian in Fields::		setting the endianness of struct fields.
* Endian built-ins::		changing endianness programmatically.
@end menu

@node set endian
@subsection @code{.set endian}
@cindex endianness

GNU poke maintains a global variable that holds the current
endianness.  This is the endianness that will be used when mapping
integers whose types do not specify an explicit endianness.

Like other poke global state, this global variable can be
modified using the @command{.set} dot-command:

@example
.set endian little
.set endian big
.set endian host
@end example

@noindent
The current endianness can be obtained like this:

@example
(poke) .set endian
little
@end example

We can easily see how changing the current endianness indeed impacts
the way integers are mapped:

@example
(poke) dump :from 0#B :size 4#B :ruler 0 :ascii 0
00000000: 8845 4c46
(poke) .set endian little
(poke) int @@ 0#B
0x464c4588
(poke) .set endian big
(poke) int @@ 0#B
0x88454c46
@end example

@node Endian in Fields
@subsection Endian in Fields

It is possible to set the endianness of integral fields in struct type
descriptors.  @xref{Field Endianness}.

@node Endian built-ins
@subsection Endian built-ins

As handy as the @command {.set endian} dot-command may be, it is also
important to be able to change the current endianness programmatically
from a Poke program.  For that purpose, the PKL compiler provides a
couple of built-in functions: @code{get_endian} and @code{set_endian}.

Their definitions, along with the specific supported values, look
like:

@example
defvar ENDIAN_LITTLE = 0;
defvar ENDIAN_BIG = 1;

defun get_endian = int: @{ @dots{} @}
defun set_endian = (int endian) int: @{ @dots{} @}
@end example

Accessing the current endianness programmatically is especially useful
in situations where the data being poked features a different
structure, depending on the endianness.

@cindex eBPF
A good (or bad) example of this is the way registers are encoded in
eBPF instructions.  eBPF is the in-kernel virtual machine of Linux,
and features an ISA with ten general-purpose registers.  eBPF
instructions generally use two registers, namely the source register
and the destination register.  Each register is encoded using 4 bits,
and the fields encoding registers are consecutive in the instructions.

Typical.  However, for reasons we won't be discussing here the order
of the source and destination register fields is switched depending on
the endianness.

@noindent
In big-endian systems the order is:

@example
dst:4 src:4
@end example

@noindent
Whereas in little-endian systems the order is:

@example
src:4 dst:4
@end example

In Poke, the obvious way of representing data whose structure depends
on some condition is using an union.  In this case, it could read like
this:

@example
deftype BPF_Insn_Regs =
  union
  @{
    struct
    @{
      BPF_Reg src;
      BPF_Reg dst;
    @} le : get_endian == ENDIAN_LITTLE;

    struct
    @{
      BPF_Reg dst;
      BPF_Reg src;
    @} be;
  @};
@end example

Note the call to the @code{get_endian} function (which takes no
arguments and thus can be called Algol68-style, without specifying an
empty argument list) in the constraint of the union alternative.  This
way, the register fields will have the right order corresponding to
the current endianness.

Nifty.  However, there is an ever better way to denote the
structure of these fields.  This is it:

@example
deftype BPF_Insn_Regs =
  struct
  @{
    defvar little_p = (get_endian == ENDIAN_LITTLE);

    BPF_Reg src @@ !little_p * 4#b;
    BPF_Reg dst @@ little_p * 4#b;
  @};
@end example

This version, where the ordering of the fields is implemented using
field labels, is not only more compact, but also has the virtue of not
requiring additional ``intermediate'' fields like @code{le} and
@code{be} above.  It also shows how convenient can be to declare
variables inside structs.

@noindent
Let's see it in action:

@example
(poke) BPF_Insn_Regs @@ 1#B
BPF_Insn_Regs @{src=#<%r4>,dst=#<%r5>@}
(poke) .set endian big
(poke) BPF_Insn_Regs @@ 1#B
BPF_Insn_Regs @{src=#<%r5>,dst=#<%r4>@}
@end example

Changing the current endianness in constraint expressions is useful
when dealing with binary formats that specify the endianness of the
data that follows using some sort of tag.  This is the case of ELF,
for example.
@cindex ELF
The first few bytes in an ELF header conform what is known as the
@code{e_ident}.  One of these bytes is called @code{ei_data} and its
value specifies the endianness of the data stored in the ELF file.

@noindent
This is how we handle this in Poke:

@example
defun elf_endian = (int endian) byte:
 @{
   if (endian == ENDIAN_LITTLE)
     return ELFDATA2LSB;
   else
     return ELFDAT2MSB;
 @}

[@dots{}]

deftype Elf64_Ehdr =
  struct
  @{
    struct
    @{
      byte[4] ei_mag : ei_mag[0] == 0x7fUB
                       && ei_mag[1] == 'E'
                       && ei_mag[2] == 'L'
                       && ei_mag[3] == 'F';
      byte ei_class;
      byte ei_data : (ei_data != ELFDATANONE
                      && set_endian (elf_endian (ei_data)));
      byte ei_version;
      byte ei_osabi;
      byte ei_abiversion;
      byte[6] ei_pad;
      offset<byte,B> ei_nident;
    @} e_ident;

    [@dots{}]
  @};
@end example

Note how @code{set_endian} returns an integer value@dots{}  it is always
@code{1}. This is to facilitate its usage in field constraint
expressions.

@node Mapping
@section Mapping
@cindex mapping
The purpose of poke is to edit @dfn{IO spaces}, which are the files or
devices, or memory areas being edited.  This is achieved by mapping
values.  Mapping is perhaps the most important concept in Poke.

@menu
* IO Spaces::			The underlying entities being edited.
* The Map Operator::		The @@ operator.
* Mapping Simple Types::	Mapping integers, offsets and strings.
* Mapping Structs::		Mapping collections of fields.
* Mapping Arrays::		Mapping sequences of things.
* Unmapping::			From mapped values to regular values.
@end menu

@node IO Spaces
@subsection IO Spaces
@cindex IO space

GNU poke supports the abstract notion of @dfn{IO space}, which is an
addressable space of Poke objects: integers, strings, arrays, structs,
@i{etc}.  This underlying storage for the IO spaces (which we call @dfn{IO
devices}) can be heterogeneous: from a file your file system to the
memory of some process.

@menu
* open::			Creating IO spaces.
* close::			Destroying IO spaces.
* get_ios::			Getting the current IO space.
* set_ios::			Setting the current IO space.
* iosize::			Getting the size of an IO space.
@end menu

@node open
@subsubsection @code{open}
@cindex opening files
@cindex IO space
The @code{open} builtin allows you to create new IO spaces, by opening an
IO device.  It has the following prototype:

@example
defun open = (string @var{handler}, uint<64> flags = 0) int<32>: @{ @dots{} @}
@end example

Where @var{handler} is a string identifying the IO device that will
serve the IO space.  This handler can be:

@table @code
@item *@var{name}*
An auto growing memory buffer.
@item pid://[0-9]+
The process ID of some process.
@item /path/to/file
An either absolute or relative path to a file.
@item nbd://@var{host:port}/@var{export}
@itemx nbd+unix:///@var{export}?socket=@var{/path/to/socket}
A connection to an NBD server. @xref{nbd command}
@end table

@var{flags} is a bitmask that specifies several aspects of the
operation, including the mode in which the IO space is opened.  Its
value is usually built by ORing a set of flags that are provided by
the compiler.  These are:

@table @code
@item IOS_F_READ
The IO space is intended to be read.
@item IOS_F_WRITE
The IO space is intended to be written.
@item IOS_F_TRUNCATE
The IO space shall be truncated upon opening.
@item IOS_F_CREATE
If the IO device doesn't exist, then create it, usually empty.
@end table

@noindent
Note that the specific meanings of these flags depend on the on the
nature of the IO space that is opened: for example, it is optional
whether a file is truncated, but a memory buffer is truncated by
default, and an NBD iospace does not support truncation.

In order to ease the usage of @code{open}, a few pre-made bitmaps are
provided to specify opening @dfn{modes}:

@table @code
@item IOS_M_RDONLY
This is equivalent to @code{IOS_F_READ}.
@item IOS_M_WRONLY
This is equivalent to @code{IOS_F_WRITE}.
@item IOS_M_RDWR
This is equivalent to @code{IOS_F_READ | IOS_F_WRITE}.
@end table

The @code{open} builtin returns a signed 32-bit integer.  This number
will identify the just opened IOS until it gets closed.

If there is a problem opening the specified IO device then @code{open}
will raise an @code{E_no_ios} exception.

@node close
@subsubsection @code{close}
@cindex @code{close}

The @code{close} builtin allows you to destroy IO spaces, closing the
underlying IO device.  The prototype is:

@example
defun close = (int<32> @var{ios}) void: @{ @dots{} @}
@end example

Where @var{ios} is some previously created IO space.  All pending data
is written to the underlying IO device.

If the IO space specified to @code{close} doesn't exist then an
@code{E_no_ios} exception is raised.

@node get_ios
@subsubsection @code{get_ios}
@cindex @code{get_ios}

GNU poke maintains a @dfn{current IO space}, which is the last created
IO space (this includes IO spaces opened and selected using a
dot-command).  The builtin @code{get_ios} returns this space.  It has
the following prototype:

@example
defun get_ios = int<32>: @{ @dots{} @}
@end example

If there is no IO space, @code{get_ios} will raise the @code{E_no_ios}
exception.

@node set_ios
@subsubsection @code{set_ios}
@cindex @code{set_ios}

The @code{set_ios} builtin allows you to set a specific IO space as the
new current IO space.  It has the following prototype:

@example
defun set_ios = (int<32> @var{ios}) int<32>: @{ @dots{} @}
@end example

Where @var{ios} is the IO space that will become the current IO
space.  If the IO space specified to @code{set_ios} doesn't exist,
@code{E_no_ios} will be raised.

Note that @code{set_ios} always returns @code{1}.  This is to ease its
usage in struct fields constraint expressions.

@node iosize
@subsubsection @code{iosize}
@cindex @code{iosize}

The @code{iosize} builtin returns the size of a given IO space, as an
offset.  It has the following prototype:

@example
defun iosize = (int<32> ios) offset<uint<64>,1>: @{ @dots{} @}
@end example

If the IO space specified to @code{iosize} doesn't exist,
@code{E_no_ios} will be raised.

@node The Map Operator
@subsection The Map Operator
@cindex mapping

Poke values reside in memory, and their in-memory representation is
not visible from Poke programs.  For example, @code{32} is a 32-bit
signed integer value, and it happens to not be boxed in the Poke
Virtual Machine.  Therefore, it occupies exactly 32-bit in the memory
of the machine running poke.  Other values, like arrays for example,
are boxed, and they need to store various meta-data.

@cindex @code{@@}
Regardless of the internal representation, we say these values live
``in memory''.  Now, it is also possible to ``map'' a value to some
area in some underlying IO space.  This is done with the map operator
@code{@@}, which has two alternate syntax:

@example
@var{type} @@ @var{offset}
@var{type} @@ @var{ios} : @var{offset}
@end example

The ternary version creates a new value using the data located at the
offset @var{offset} in the specified IO space @var{ios}, which shall
be an expression evaluating to a signed 32-bit integer.

The binary version uses the current IO space.

If there is no IO space, or the specified IO space doesn't exist, an
@code{E_no_ios} exception is raised:

@example
(poke) int @@ 0#B
unhandled no IOS exception
@end example

The value created in a map can be either mapped or not mapped.
Mapping simple types produces not mapped values, whereas mapping
non-simple types create mapped values.

The value attributes @code{mapped} and @code{offset} can be used to
check whether a value is mapped or not, and in that case the offset
where it is mapped:

@example
(poke) defvar p = Packet @@ 0#B
(poke) p'mapped
0x1
(poke) p'offset
0x0UL#b
@end example

Using the @code{offset} attribute in a not mapped value results in the
@code{E_no_map} exception being raised:

@example
(poke) [1,2,3]'mapped
0x0
(poke) [1,2,3]'offset
unhandled no map exception
@end example

If the type specified in the map is not a simple type, like an array
or a struct, the resulting value is said to be mapped in the IO
space:

@example
(poke) deftype Packet = struct @{ int i; long l; @}
(poke) Packet @@ 0#B
Packet @{i=0x464c457f,l=0x10102L@}
(poke) uint<8>[2] @@ 0#B
[0x7fUB,0x45UB]
@end example

A very important idea on Poke mapping is that it should be possible to
manipulate mapped and non-mapped values in a transparent way.  For
example, consider the quick sort implementation in poke's standard
library.  The prototype is:

@example
defun qsort = (any[] array, Comparator cmp_f,
               long left = 0, long right = array'length - 1) void:
@end example

@noindent
@code{qsort} works with both mapped and not-mapped arrays:

@example
(poke) defvar a = [2,3,1]
(poke) defvar b = int[3] @@ 0#B
(poke) b
[1179403647,65794,0]
(poke) qsort (a, IntComparator)
(poke) a
[1,2,3]
(poke) qsort (b, IntComparator)
(poke) b
[0,33620224,1179403647]
(poke) dump :from b'offset :size b'size :ascii 0
76543210  0011 2233 4455 6677 8899 aabb ccdd eeff
00000000: 0000 0000 0001 0102 7f45 4c46
@end example

Similarly, you can write functions that operate on abstract
entities and data structures such as ELF relocations and sections,
DWARF DIEs, @i{etc}, and the same code will work with non mapped and
mapped values.

@node Mapping Simple Types
@subsection Mapping Simple Types

Simple values (@i{i.e.} integers, offsets, strings) cannot be mapped.
Therefore, if the type specified in the map is a simple type, the
resulting value will be a regular non-mapped value.  Examples:

@example
(poke) uint<8> @@ 0#B
0x7fUB
(poke) string @@ 0#B
"ELF"
@end example

@node Mapping Structs
@subsection Mapping Structs

XXX

@node Mapping Arrays
@subsection Mapping Arrays

Arrays can be mapped in IO space in three different ways, depending on
the characteristics of the type provided to the mapping operator.

@subsubsection Array maps bounded by number of elements
When an array type bounded by number of elements is used in a mapping
operation, the resulting mapped array is also bounded by number of
elements.

For example, this is how we would map an array of four 32-bit signed
integers in the current IO space:

@example
(poke) int[4] @@ 0#B
[10,20,30,40]
@end example

Since you can also provide a dynamic array type to the map operator,
the number of elements doesn't need to be constant.  For example,
given the variable @code{nelems} has a value of @code{2}:

@example
(poke) defvar nelems = 2
(poke) int[nelems + 1] @@ 0#B
[100,222,333]
@end example

@cindex end of file
If an end-of-file condition happens while mapping the array, because
the number of elements specified in the array type, at the given
offset, exceeds the capacity of the underlying IO device, an exception
is raised and the mapping is not completed:

@example
(poke) int[99999999999] @@ 0#B
unhandled EOF exception
@end example

Likewise, if a constraint fails while performing the mapping (while
mapping an array of structs, for example) an exception is raised and
the map is aborted.

@subsubsection Array maps bounded by size

While dealing with binary formats, it often happens that the number of
entities in a collection is given by the space they occupy, rather
than the count itself.

For example, consider ELF sections holding relocations.  These
sections contain a collection of zero or more relocations. The layout
of each relocation is specified by the following type:

@example
deftype Elf64_Rela =
  struct
  @{
    offset<Elf64_Addr,B> r_offset;
    Elf64_Xword r_info;
    Elf64_Sxword r_addend;
  @};
@end example

The section is described by an entry in the ELF sections header table:

@example
deftype Elf64_Shdr =
  struct
  @{
    Elf_Word sh_name;
    Elf_Word sh_type;
    Elf64_Xword sh_flags;
    Elf64_Addr sh_addr;
    Elf64_Off sh_offset;
    offset<Elf64_Xword,B> sh_size;
    Elf_Word sh_link;
    Elf_Word sh_info;
    Elf64_Xword sh_addralign;
    offset<Elf64_Xword,b> sh_entsize;
  @};
@end example

The relevant elements of @code{Elf64_Shdr} are @code{sh_offset} and
@code{sh_size}, which indicate the offset of the beginning of the
section's contents, and its size, respectively.  At this point, if we
wanted to get an array with all the relocations in the section, we
could map an array bounded by number of elements like we saw in the
previous section, like this:

@example
(poke) Elf64_Rela[sh_size / 1#Elf64_Rela]
[@dots{} relocs @dots{}]
@end example

However, this approach adoleces from two problems.  First, it doesn't
work with any entity type.  For an offset like @code{1#Elf64_Rela} to
work, it is required to know the size of the type specified as the
unit at compile time.  In the particular case of @code{Elf64_Rela},
that condition is satisfied, but too often that's not the case.  For
example, think about a section containing @code{NULL} terminated
strings: you can't know the number of strings contained in the section
until you actually read it.

Another problem is when the data in the header is corrupt.  Using
the mapping bounded by number of elements, we wouldn't realize it.  It
would be good if the tool would tell us whether the specified size
actually holds an exact number of the requested elements.

A mapping bound by size is what we need.  Fortunately, as we saw when
discussing array types, Poke allows you to specify an offset instead of an
integral value, in the array type specification.  The right amount of
entities (in this case relocations) to strictly satisfy the provided
size will be mapped in the IO space.  So, in order to obtain an array
containing all the relocations in the section, we simply write:

@example
(poke) Elf64_Rela[ehdr.sh_size] @@ ehdr.sh_offset
[@dots{} relocs @dots{}]
@end example

The strictness mentioned above is important.  GNU poke will complain
(and abort the mapping) if it is not possible to map an exact number
of elements.  Thus the following mapping would not be successful:

@example
(poke) int[33#b] @@ 0#B
unhandled out of map bounds exception
@end example

Like in mappings bounded by number of elements, if a constraint fails
while performing the mapping, an exception is raised and the map is
aborted.

@subsubsection Unbounded array maps

We mentioned above that if an end-of-file condition happens while
performing a mapping (be it bounded by number of elements or bounded
by size) an EOF exception is raised, and the mapping operation is
aborted.

Unbounded array mappings are performed by using an unbounded array
type in the mapping operation, like in:

@example
@var{type}[] @@ 0#B
@end example

The above construction will map values of type @var{type} in the IO
space until there is an end-of-file condition, or a constraint fails,
whatever happens first.  When it is a constraint expression that
fails, that last element is not included in the mapped array.

Let's assume a binary file contains a series of blocks, located one
after the other, of a kind described by the following struct type:

@example
deftype Block =
  struct
  @{
     byte magic[2] : magic[0] == 'B' && magic[1] == 'K';
     @dots{} other data @dots{}
  @};
@end example

we can map the blocks using an unbounded array map:

@example
(poke) Block[] @@ 0#B
[ @dots{} blocks @dots{} ]
@end example

If the blocks extend up to the end of the IO space, that many blocks
will be mapped.  If there is some other content in the file following
the blocks, the constraint in the @code{magic} field will fail and
will delimit the map that way (provided the binary format is well
designed.)

@subsubsection Mapped bounds in bounded arrays

When an array map is bounded, be it by number of elements or by size,
the bounding value can be mapped itself.  To illustrate how this
works, let's go back to our ELF file and the section containing
relocations.  First, we map an @code{Elf64_Shdr} to get the section
header:

@example
(poke) defvar shdr = Elf64_Shdr @@ @var{offset}
(poke) shdr.sh_offset
120#B
(poke) shdr.sh_size
24#B
@end example

Now we map an array with the relocations themselves, using a map
bounded by size, as we learned in the last section:

@example
(poke) defvar relocs = ELF64_Rela[shdr.sh_size] @@ shdr.sh_offset
(poke) relocs'length
3
@end example

Now, observe that @code{shdr.sh_size} is mapped itself!  This means
that, should the section size be modified (to accommodate an extra
relocation, for example) the mapping of @code{relocs} will reflect
that automatically:

@example
(poke) shdr.sh_size = shdr.sh_size + 1#Elf64_Rela
(poke) relocs'length
4
@end example

This is certainly an useful idiom, that is often used while poking
around.  However, sometimes this is @emph{not} what we want.  If we
don't want the mapping bounds of @code{relocs} to be tied to
@code{shdr}, we can just use a temporary for the size:

@example
(poke) defvar s = shdr.sh_size
(poke) defvar relocs = Elf64_Rela[s] @@ shdr.sh_offset
@end example

Since simple values (such as the size above) are not mapped, this
trick works as intended.

@node Unmapping
@subsection Unmapping
@cindex unmap

The unary @code{unmap} operator has the form:

@example
unmap @var{value}
@end example

It gets any value and produces the same value, making it not mapped in
case it is a mapped value.

This is useful when we want to read a data structure from the IO space
(say, an array of integers) and then use it for storage without
changing the underlying IO space.  We would do something like:

@example
(poke) defvar a = unmap (int[1] @@ 10#B)
(poke) a[2] = 100
@end example

@node Exception Handling
@section Exception Handling
@cindex exceptions

Sometimes an error or some other unexpected situation arises.  Poke
provides an exceptions mechanism to deal with these situations.

@menu
* Exceptions::		List of supported exception types.
* try-catch::		Catching exceptions in programs.
* try-until::		Running code until some exception occurs.
* raise::		Raising exceptions in programs.
@end menu

@node Exceptions
@subsection Exceptions

Exceptions in Poke are values of type @code{Exception}, which is a
struct defined like this:

@example
deftype Exception =
  struct
  @{
    int<32> code;
    string msg;
  @};
@end example

@noindent
Where @code{code} identifies the type of the exception, and @code{msg}
is supposed to be a textual description of the exceptional situation.

You can use codes @code{255} and higher for your own exceptions.  For
example:

@example
raise Exception @{ code = 255; msg = "double upset event" @};
@end example

Exception codes in the range @code{0..254} are reserved for poke.
These are used in predefined exceptions which are standard, and have
specific meanings:

@table @code
@item E_generic
Generic error.
@item E_out_of_bounds
Out of bounds exception.  This can be raised when accessing
containers, like arrays and strings.
@item E_eof
@cindex end of file
End of file exception.  This can be raised when mapping in the IO
space.
@item E_elem
Invalid element exception.  This is can be raised when accessing union
fields that do not exist.
@item E_constraint
Constraint violation exception.  This is raised when a constraint
exception fails while mapping or constructing a struct.
@item E_conv
Conversion exception.  This can be raised while casting values.
@item E_map_bounds
Out of map bounds exception.  This can be raised while modifying a
mapped value in a way it would violate its declared boundary (like the
size of a mapped array.)
@item E_map
No map exception.  This is raised when trying to map a not mapped
value.
@item E_div_by_zero
Division by zero exception.
@item E_no_ios
No IOS exception.  This is raised when the IO space is accessed but
there is no IO space.
@item E_no_return
No return exception.  This is raised when the end of a void function
is reached.
@item E_io
Generic IO exception.
@item E_io_flags
Invalid flags were tried while opening an IO device.
@end table

The exception codes of the standard exceptions are available in the
form of @code{EC_*} variables.  For example, this how you would raise
an IO error with a particular message:

@example
raise Exception @{ code = EC_io,
                   msg = "fluzo capacitator overheat impedes IO" @}
@end example

@node try-catch
@subsection @code{try-catch}
@cindex @code{try-catch}
The @code{try-catch} statement provides a way to catch exceptions and
handle them.

The simplest form of the statement is:

@example
try @var{stmt} catch @var{compound_stmt}
@end example

Where @var{stmt} is any statement and @var{compound_stmt} is a
compound statement.  First, @var{stmt} is executed.  If during its execution
an exception is raised, then @var{compound_stmt} is executed.

The second form of the statement allows you to catch just one type of
exception:

@example
try @var{stmt} catch if @var{exp} @var{compound_stmt}
@end example

Where @var{exp} is an expression that should evaluate to an
@code{Exception}.  The handler @var{compound_stmt} will only be
executed if that specific exception is caught.  Any other exception
will be re-raised.

The third form of the statement is the most generic:

@example
try @var{stmt} catch (Exception @var{formal}) @var{compound_stmt}
@end example

Where @var{formal} is a formal argument that contains the exception
when @var{compound_stmt} is executed.

@node try-until
@subsection @code{try-until}
@cindex @code{try-until}
The @code{try-until} statement allows you to execute instructions until
some exception is caught.  The syntax is:

@example
try @var{stmt} until @var{exp}
@end example

Where @var{stmt} is the statement that will be executed repeatedly
until some exception is raised.  If the raised exception has type
@var{exp} then execution continues normally.  @var{exp} should be an
expression that evaluates to an @code{Exception}.

@cindex end of file
This statement is particularly useful for mapping IO spaces until an
@code{eof} condition occurs.  For example, this is how we would
compute with every integer in the current IO space:

@example
defvar o = 0#B;
try
@{
  compute (int @@ o);
  o = o + 1#B;
@} until E_eof;
@end example

@node raise
@subsection @code{raise}
@cindex @code{raise}
In previous sections we saw how exceptions are usually the
side-product of performing certain operations.  For example, a
division by zero.

However, it is also useful to explicitly raise exceptions.  The
@code{raise} statement can be used for that purpose.  Its syntax is:

@example
raise @var{exception};
@end example

Where @var{exception} is an integer.  This integer can be any number,
but most often is one of the @code{E_*} codes defined in Poke.

@node Printing
@section Printing

Poke programs can print text to the standard output in two ways:
simple unformatted output, and formatted output.

@menu
* print::			simple output.
* printf::			formatted output.
* Pretty Printers::		improve the legibility of your data structures.
@end menu

@node print
@subsection @code{print}
@cindex @code{print}
@cindex output

The @code{print} statement prints the given string to the standard
output.  @code{print} outputs text strings verbatim.  It can be
invoked using two alternative syntaxes, which are equivalent:

@example
print (@var{str});
print @var{str};
@end example

@code{print} is simple, but fast.  It is good to use it in simple
cases where the information to print out doesn't require any kind of
formatting and styling.

@node printf
@subsection @code{printf}
@cindex @code{printf}
@cindex formatted output

The @code{printf} statement gets a format string and, optionally, a
list of values to print.  It can be invoked using two alternative
syntaxes, which are equivalent:

@example
printf (@var{fmt}[, @var{value}@dots{}])
printf @var{fmt}[, @var{value}@dots{}]
@end example

The format string @var{fmt} is printed verbatim to the standard
output, but for @dfn{format tags} which start with @code{%}.  These
format tags are interpreted especially.
@cindex tags, format tags
Most of the format tags ``consume'' one of the specified values.
Every value in the list shall be described by a tag, or the compiler
will signal an error.  Likewise, values without a corresponding
describing tag is an error.  These tags are:

@table @code
@item %s
Print the argument as a string.
@item %i@var{bits}(d|x|o|b|c)
Print the argument as a signed integer of size @var{bits}.  The last
letter determines how the argument is printed.
@table @code
@item d
@cindex decimal
Print the integer in decimal.
@item x
@cindex hexadecimal
Print the integer in hexadecimal.
@item o
@cindex octal
Print the integer in octal.
@item b
@cindex binary
Print the integer in binary.
@item c
Print the integer as an ASCII character.  This only works with 8 bit
integers.
@end table
@item %u
Same as @code{%i}, but for unsigned integers.
@item %c
A shorter way to write @code{%u8c}.
@item %v
Print the value printed representation of the argument, which can be
of any type including complex types like arrays and structs.  This is
similar to the @code{write} operation available in many Lisp systems.

This tag supports an optional numerical argument (restricted to a
single digit) that specifies the maximum depth level when printing
structures.  Example:

@example
(poke) printf ("%1v\n", struct @{ s = struct @{ i = 10 @},  l = 20L @});
struct @{s=struct @{...@},l=0x14L@}
@end example

By default, the depth level is @code{0}, which means no limit.

This tag also support an optional flag that specifies how the value is
printed.  The supported tags are @code{F} (for @dfn{flat}) and
@code{T} (for @dfn{tree}).  The default is flat.  Example:

@example
(poke) printf ("%Tv\n", struct @{ s = struct @{ i = 10 @},  l = 20L @});
struct @{
  s=struct @{
    i=0xa
  @},
  l=0x14L
@}
(poke) printf ("%Fv\n", struct @{ s = struct @{ i = 10 @},  l = 20L @});
struct @{s=struct @{i=0xa@},l=0x14L@}
@end example

This tag is mainly intended to be used in pretty-printers.
@end table

@cindex styled output
The following format tags do not consume arguments.  They support
emitting styled text using the libtextstyle approach of having styling
classes that you can customize in a @file{.css} file.

@table @code
@item %<@var{classname}:
Start the styling class with name @var{classname}.  The class name
cannot be empty.
@item %>
End the last opened styling class.  All styling classes should be
ended before finishing the format string.
@end table

Note that styling classes can be nested, but all classes should be
ended before finishing the format string.

If you use a @var{name} class, you can define how to style it in the
@file{.css} file (poke installs and uses poke-default.css but you can
set the @code{POKE_STYLE} environment variable to point to another
css) like this:

@example
.NAME @{ text-decoration: blink; color : pink; @}
@end example

Examples:

@example
(poke) printf "This is a NAME: %<NAME:xxx%>"
This is a NAME: xxx
(poke) printf "Name: %<string:%s%> Age: %<integer:%i32d%>, "Jose", 39
Name: Jose Age: 39
@end example

@node Pretty Printers
@subsection Pretty Printers
@cindex pretty printing
XXX

@node Comments
@section Comments
@cindex comments

There are several ways to document your Poke programs: comments of
several types and support for separator characters.

@menu
* Multi-line comments::		C-like comments.
* Single line comments::	C++-like comments.
* Vertical separator::		Using form-feed characters.
@end menu

@node Multi-line comments
@subsection Multi-line comments

Poke supports C-like multi-line, comments, which is text enclosed
between @code{/*} and @code{*/} sequences.  These comments cannot be
nested.

@node Single line comments
@subsection Single line comments

C++-like single line comments are supported.  Everything after the
@code{//} sequence is interpreted as a comment, until the end of the
line or the end of the file, whatever comes first.

@node Vertical separator
@subsection Vertical separator

@cindex @code{^L}
@cindex form feed
Poke ignores form feed characters (ASCII code 12, often visualized as
^L).  In GNU software, this character is traditionally used to
separate conceptually different entities in source files.

@node Modules
@section Modules
@cindex @code{load}
@cindex modules

It is common for pickles to depend on stuff defined in other pickles.
In such cases, the @code{load} language construction can be used to
load pickles from your Poke program.  The syntax is:

@example
load @var{module};
@end example

@noindent
Where @var{module} is the name of the pickle to load.

For example, your Poke program may want to access some ELF data
structures.  In that case, we can just do:

@example
/* Pickle to poke the contents of some ELF section.  */

load elf;

/* ... code  ... */
@end example

When asked to open a module, poke assumes it is implemented in a file
named @file{@var{module}.pk}.  In the example above, it will try to
load @file{elf.pk}.

The pickles are searched first in the current working directory.  If
not found, then @file{@var{prefix}/share/poke/@var{module}.pk} is
tried next.

If the environment variable @code{POKEDATADIR} is defined, it replaces
@file{@var{prefix}/share/poke}.  This is mainly intended to test a
poke program before it gets installed in its final location.

Nothing prevents you to load the same pickle twice.  This will work if
the pickle doesn't include definitions, but just executes statements.
Otherwise, you will likely get an error due to trying to define stuff
twice.

There is an alternate syntax of the @code{load} construction that is
useful when the module is implemented in a file whose name doesn't
conform to a Poke identifier.  This happens, for example, when the
file name contains hyphens.  Example:

@example
load "my-pickle.pk";
@end example

Note that if you use this variant of @code{load}, you must specify the
full file name, including whatever extension it uses (usually
@file{.pk}).

@node The Standard Library
@chapter The Standard Library

@menu
* Standard Integral Types::	int, long and the like.
* Standard Offset Types::	off64 and the like.
* Standard Units::		b, B, Kb and the like.
* Conversion Functions::	catos, atoi, @i{etc}.
* String Functions::		Functions which deal with strings.
* Sorting Functions::		qsort.
* CRC Functions::               Cyclic Redundancy Checksums.
* Dates and Times::             Processing and displaying dates and times.
@end menu

@node Standard Integral Types
@section Standard Integral Types
@cindex integral types
@cindex types, integral types
The Poke standard library provides the following standard integral
types.

@table @code
@item bit
1-bit unsigned integer.
@item nibble
4-bit unsigned integer.
@item uint8
@itemx byte
@itemx char
8-bit unsigned integer.
@item uint16
@itemx ushort
16-bit unsigned integer.
@item uint32
@itemx uint
32-bit unsigned integer.
@item uint64
@itemx ulong
64-bit unsigned integer.
@item int8
8-bit signed integer.
@item int16
@itemx short
16-bit signed integer.
@item int32
@item int
32-bit signed integer.
@item int64
@item long
64-bit signed integer.
@end table

@node Standard Offset Types
@section Standard Offset Types
@cindex offset types
@cindex types, offset types

The Poke standard library provides the following standard offset
types.

@table @code
@item off64
64-bit signed offset in bits.
@item uoff64
64-bit unsigned offset in bits.
@end table

@node Standard Units
@section Standard Units

The following list of units are defined in the standard library.

@cindex units

@table @code
@item b
bits.
@item B
bytes.
@item Kb
@cindex kilobits
kilo bits (1024 bits.)
@item KB
@cindex kilobytes
Kilo bytes (1024 bytes.)
@item Mb
@cindex megabits
Mega bits.
@item MB
@cindex megabytes
Mega bytes.
@item Gb
@cindex gigabits
Giga bits.
@end table

@node Conversion Functions
@section Conversion Functions
@cindex conversion functions
The Poke standard library provides the following functions to do
useful conversions.

@menu
* catos::		converting characters arrays into string.
* atoi::		converting strings to integers.
@end menu

@node catos
@subsection @code{catos}
@cindex @code{catos}
@cindex converting, arrays to strings
It is often useful to convert arrays of characters into strings.  The
standard function @code{catos} provides the following interface:

@example
defun catos = (char[] @var{chars}) string: @{ @dots{} @}
@end example

It builds a string containing the characters in @var{chars}, and
returns it.  Examples:

@example
(poke) catos (['a','b','c'])
"abc"
(poke) catos (['\0'])
""
@end example

Note that if the passed array contains a @code{NULL} character
@code{'\0'} then no further characters are processed.  For example:

@example
(poke) catos (['f','o','o','\0','b','a','r'])
"foo"
@end example

@node atoi
@subsection @code{atoi}
@cindex @code{atoi}
@cindex converting, strings to integers
The standard function @code{atoi} provides the following interface:

@example
defun atoi = (string @var{str}, int @var{base} = 10) long: @{ @dots{} @}
@end example

It parses a signed integral number in the given @var{base} in the
string @var{str} and returns it as a signed 64-bit integer.

@cindex base, argument in @command{atoi}
The accepted values for @var{base} are @code{2}, @code{8}, @code{10}
(the default) and @code{16}.  If any other base is requested an
@code{E_generic} exception is raised.

Note that atoi allows for extra information to be stored in @var{str}
after the parsed integer.  Thus, this works:

@example
(poke) atoi ("10foo")
10L
@end example

@node String Functions
@section String Functions
@cindex string functions
The Poke standard library provides the following functions to do
work on strings:

@menu
* ltrim::		Remove leading whitespace.
* rtrim::		Remove trailing whitespace.
@end menu

@node ltrim
@subsection @code{ltrim}
@cindex @code{ltrim}
@cindex whitespace, trimming
The standard function @code{ltrim} provides the following interface:

@example
defun ltrim = (string s) string: @{ @dots{} @}
@end example

It returns a copy of the input string @code{s} with any leading whitespace removed.

@node rtrim
@subsection @code{rtrim}
@cindex @code{rtrim}
@cindex whitespace, trimming
The standard function @code{rtrim} provides the following interface:

@example
defun rtrim = (string s) string: @{ @dots{} @}
@end example

It returns a copy of the input string @code{s} with any trailing whitespace removed.

@node Sorting Functions
@section Sorting Functions
@cindex sorting
@menu
* qsort::		Sorting arrays with quicksort.
@end menu

@node qsort
@subsection @code{qsort}
@cindex @code{qsort}
@cindex quick sort
The standard function @code{qsort} has the following prototype:

@example
defun qsort = (any[] @var{array}, Comparator @var{cmp_f},
               long @var{left} = 0,
               long @var{right} = array'length - 1) void: @{ @dots{} @}
@end example

Where @var{array} is the array to sort, @var{cmp_f} is a comparator
function, @var{left} is the index of the first array element to
include in the sorting, and @var{right} is the index of the last array
element to include in the sorting.  Both @var{left} and @var{right}
are optional, and the default is to cover the whole array.

The comparator function @var{cmp_f} should have the following
prototype:

@example
deftype Comparator = (any,any):int;
@end example

@node CRC Functions
@section CRC Functions
@cindex CRC
@cindex checksum

Many file formats use checksums of one sort or another.
Therefore you may want to write such a checksum or verify
a checksum in a constrained field. @xref{Field Constraints}.

Some formats use simple additive checksums.  Another common checksum
is the Cyclic Redundancy Checksum (CRC).  The standard function
@code{crc32} calculates the 32 bit CRC defined by ISO-3309.

@example
defun crc32 = (byte[] @var{buf}) uint<32>: @{ @dots{} @}
@end example

@noindent
This function returns the 32 bit CRC for the data contained in the
array @var{buf}.

@node Dates and Times
@section Dates and Times
@cindex date
@cindex time
@cindex @code{POSIX_Time32}

Often a format encodes a date and time expressed as the number of seconds
since midnight, January@tie{}1st 1970@.   You could map these
simply as integers.  However, the standard library provides two
types @code{POSIX_Time32} and @code{POSIX_Time64} which include
pretty-printers (@pxref{Pretty Printers}) to
display the date in a human readable format.
The definition is:

@example
deftype POSIX_Time@var{size} = struct
@{
  uint<@var{size}>  seconds;

  defun _print = void:
  @{ @dots{} @}
@}
@end example

@noindent
where @var{size} is either 32 or 64@.
When pretty printing is enabled, a mapped value of these types will
display similar to

@example
#<2019-Dec-12 8:54:56>
@end example

@noindent
whereas when pretty printing is not enabled, this example would be displayed as:

@example
POSIX_Time32 @{seconds=1576140896U@}
@end example

@noindent
Note that timestamps of this type do not account for leap seconds and
are agnostic towards timezone.

@cindex @code{ptime}
Occasionally you might wish to print an unmapped timestamp value in a
human readable format.  To do this, you can use the @code{ptime} function,
which is defined as follows:

@example
defun ptime = (uint<64> seconds) void:
@{ @dots{} @}
@end example

@node Hacking Poke
@chapter Hacking Poke

@menu
* Writing Commands::		Extending poke with new commands.
@end menu

@node Writing Commands
@section Writing Commands

XXX

@node The Poke Virtual Machine
@chapter The Poke Virtual Machine

@menu
* PVM Instructions::		Virtual Machine instructions.
@end menu

@node PVM Instructions
@section PVM Instructions

@include pvm-insns.texi

@node Table of ASCII Codes
@appendix Table of ASCII Codes

@example
Oct   Dec   Hex   Char                        Oct   Dec   Hex   Char
────────────────────────────────────────────────────────────────────────
000   0     00    NUL '\0' (null character)   100   64    40    @@
001   1     01    SOH (start of heading)      101   65    41    A
002   2     02    STX (start of text)         102   66    42    B
003   3     03    ETX (end of text)           103   67    43    C
004   4     04    EOT (end of transmission)   104   68    44    D
005   5     05    ENQ (enquiry)               105   69    45    E
006   6     06    ACK (acknowledge)           106   70    46    F
007   7     07    BEL '\a' (bell)             107   71    47    G
010   8     08    BS  '\b' (backspace)        110   72    48    H
011   9     09    HT  '\t' (horizontal tab)   111   73    49    I
012   10    0A    LF  '\n' (new line)         112   74    4A    J
013   11    0B    VT  '\v' (vertical tab)     113   75    4B    K
014   12    0C    FF  '\f' (form feed)        114   76    4C    L
015   13    0D    CR  '\r' (carriage ret)     115   77    4D    M
016   14    0E    SO  (shift out)             116   78    4E    N
017   15    0F    SI  (shift in)              117   79    4F    O
020   16    10    DLE (data link escape)      120   80    50    P
021   17    11    DC1 (device control 1)      121   81    51    Q
022   18    12    DC2 (device control 2)      122   82    52    R
023   19    13    DC3 (device control 3)      123   83    53    S
024   20    14    DC4 (device control 4)      124   84    54    T
025   21    15    NAK (negative ack.)         125   85    55    U
026   22    16    SYN (synchronous idle)      126   86    56    V
027   23    17    ETB (end of trans. blk)     127   87    57    W
030   24    18    CAN (cancel)                130   88    58    X
031   25    19    EM  (end of medium)         131   89    59    Y
032   26    1A    SUB (substitute)            132   90    5A    Z
033   27    1B    ESC (escape)                133   91    5B    [
034   28    1C    FS  (file separator)        134   92    5C    \  '\\'
035   29    1D    GS  (group separator)       135   93    5D    ]
036   30    1E    RS  (record separator)      136   94    5E    ^
037   31    1F    US  (unit separator)        137   95    5F    _
040   32    20    SPACE                       140   96    60    `
041   33    21    !                           141   97    61    a
042   34    22    "                           142   98    62    b
043   35    23    #                           143   99    63    c
044   36    24    $                           144   100   64    d
045   37    25    %                           145   101   65    e
046   38    26    &                           146   102   66    f
047   39    27    '                           147   103   67    g
050   40    28    (                           150   104   68    h
051   41    29    )                           151   105   69    i
052   42    2A    *                           152   106   6A    j
053   43    2B    +                           153   107   6B    k
054   44    2C    ,                           154   108   6C    l
055   45    2D    -                           155   109   6D    m
056   46    2E    .                           156   110   6E    n
 057   47    2F    /                           157   111   6F    o
060   48    30    0                           160   112   70    p
061   49    31    1                           161   113   71    q
062   50    32    2                           162   114   72    r
063   51    33    3                           163   115   73    s
064   52    34    4                           164   116   74    t
065   53    35    5                           165   117   75    u
066   54    36    6                           166   118   76    v
067   55    37    7                           167   119   77    w
070   56    38    8                           170   120   78    x
071   57    39    9                           171   121   79    y
072   58    3A    :                           172   122   7A    z
073   59    3B    ;                           173   123   7B    @{
074   60    3C    <                           174   124   7C    |
075   61    3D    =                           175   125   7D    @}
076   62    3E    >                           176   126   7E    ~
077   63    3F    ?                           177   127   7F    DEL
@end example


@node GNU Free Documentation License
@appendix GNU Free Documentation License
@cindex license, GNU Free Documentation License

@include fdl.texi

@node Concept Index
@unnumbered Concept Index

@printindex cp

@bye

@c  LocalWords:  texinfo setfilename texi settitle Pokist afourpaper
@c  LocalWords:  dircategory direntry titlepage vskip filll ifnottex
@c  LocalWords:  insertcopying vm pokerc Structs Endianness catos dfn
@c  LocalWords:  atoi qsort cindex bitpatterns noindent samp
@c  LocalWords:  itemx html init REPL TTY rluserman defun printf PVM
@c  LocalWords:  stdin subcommands disassembler ascii POKEDATADIR FLV
@c  LocalWords:  endian endianness obase expr Booleans uint Bitwise
@c  LocalWords:  emph signedness unary boolean ceil bitwise structs
@c  LocalWords:  BSON deftype struct dstart IETF BFINAL BTYPE BitData
@c  LocalWords:  sizeof kilobits Pokish B'size B'magnitude B'unit UB
@c  LocalWords:  b'magnitude b'unit fUB unhandled defvar CTF isa str
@c  LocalWords:  polymorphism lvalue stmt Variadic ret namespace gcd
@c  LocalWords:  variadic args PDP programmatically PKL eBPF dst src
@c  LocalWords:  BPF Insn Regs le ident ei ELFDATA LSB ELFDAT MSB ios
@c  LocalWords:  Ehdr ELFDATANONE osabi abiversion nident Unmapping
@c  LocalWords:  Comparator cmp relocations DIEs nelems
@c  LocalWords:  EOF Rela Addr Xword Sxword Shdr addr addralign fmt
@c  LocalWords:  entsize relocs adoleces libtextstyle classname css
@c  LocalWords:  ushort ulong uoff abc ltrim whitespace rtrim fdl
@c  LocalWords:  quicksort array'length comparator printindex
