## Jitter specification for the GNU Poke Virtual Machine.

## Copyright (C) 2019, 2020 Jose E. Marchesi
## Written by Jose E. Marchesi

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

vm
  set prefix "pvm"
  tos-stack "pvm_val" "stack"
  ntos-stack "pvm_val" "returnstack"
  ntos-stack "struct pvm_exception_handler *" "exceptionstack"
end



## Register classes.

register-class r 1
  code
    pvm_val
  end
end



## Functions and globals to wrap.

wrapped-functions
  pk_term_class
  pk_term_end_class
  pk_printf
  printf
  pvm_assert
  pvm_env_lookup
  pvm_env_register
  pvm_env_pop_frame
  pvm_env_push_frame
  pvm_make_int
  pvm_make_uint
  pvm_make_long
  pvm_make_ulong
  pvm_make_string
  pvm_make_array
  pvm_make_struct
  pvm_make_offset
  pvm_make_integral_type
  pvm_make_string_type
  pvm_make_offset_type
  pvm_make_array_type
  pvm_allocate_struct_attrs
  pvm_make_struct_type
  pvm_typeof
  pvm_ref_struct
  pvm_set_struct
  ios_cur
  ios_read_int
  ios_read_uint
  ios_read_string
  ios_write_string
  random
end

#wrapped-globals
#  pvm_printf_format_string
#end


## Embedded C code.

early-header-c
  code
#   include <config.h>
#   include "pvm.h"
#   include "ios.h"
#   include "pk-term.h"
#   include "pk-utils.h"

    /* Globals.  */
    extern int poke_obase;

    /* Exception handlers, that are installed in the "exceptionstack".

       EXCEPTION is the exception type, either one of the E_* values defined
       above, or any integer >= 256 for user-defined exceptions.

       MAIN_STACK_HEIGHT and RETURN_STACK_HEIGHT are the heights of
       the main and return stacks, to restore before transferring
       control to the exception handler.

       CODE is the program point where the exception handler starts.

       ENV is the run-time environment to restore before transferring
       control to the exception handler.  */

    struct pvm_exception_handler
    {
      int exception;
      jitter_stack_height main_stack_height;
      jitter_stack_height return_stack_height;
      pvm_program_point code;
      pvm_env env;
    };
  end
end

early-c
  code
#   include <string.h>
  end
end

late-header-c
  code
    extern jitter_uint printer_hi;

    /* Macros to raise an exception from within an instruction.  This
       is used in the RAISE instruction itself, and also in instructions
       that can fail, such as integer division or IO.

       The code in the macro looks for the first matching exception
       handler in the exception handlers stack.  Then it restores the
       heights of the main stack and the return stack, restores the
       original dynamic environment, and then pushes the exception
       type as an integer in the main stack, before branching to the
       exception handler.  */

#define PVM_RAISE_DIRECT(EXCEPTION)                                   \
  do                                                                  \
  {                                                                   \
   int exception_code                                                 \
     = PVM_VAL_INT (pvm_ref_struct ((EXCEPTION),                      \
                                    pvm_make_string ("code")));       \
   while (1)                                                          \
   {                                                                  \
     struct pvm_exception_handler *ehandler                           \
       = JITTER_TOP_EXCEPTIONSTACK ();                                \
     int handler_exception = ehandler->exception;                     \
                                                                      \
     JITTER_DROP_EXCEPTIONSTACK ();                                   \
                                                                      \
     if (handler_exception == 0                                       \
         || handler_exception == exception_code)                      \
     {                                                                \
       JITTER_SET_HEIGHT_STACK (ehandler->main_stack_height);         \
       JITTER_SET_HEIGHT_RETURNSTACK (ehandler->return_stack_height); \
                                                                      \
       JITTER_PUSH_STACK ((EXCEPTION));                               \
                                                                      \
       jitter_state_runtime.env = ehandler->env;                      \
       JITTER_BRANCH (ehandler->code);                                \
       break;                                                         \
     }                                                                \
   }                                                                  \
 } while (0)


#define PVM_RAISE(CODE,STR)                                           \
 do                                                                   \
 {                                                                    \
   pvm_val exception = pvm_make_exception ((CODE),(STR));             \
   PVM_RAISE_DIRECT (exception);                                      \
 } while (0)

    /* Macros to implement different kind of instructions.  These are to
       avoid flagrant code replication below.  */

/* Binary numeric operations generating a boolean in the stack.
   ( TYPE TYPE -- TYPE TYPE INT ) */
# define PVM_BOOL_BINOP(TYPE,OP)                                             \
   do                                                                        \
    {                                                                        \
      pvm_val res = pvm_make_int (PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ()) \
                                  OP PVM_VAL_##TYPE (JITTER_TOP_STACK ()), 32); \
      JITTER_PUSH_STACK (res);                                               \
    } while (0)

/* Unary numeric operations.
   ( TYPE -- TYPE TYPE) */
# define PVM_UNOP(TYPE,TYPER,TYPERLC,OP)                                     \
   do                                                                        \
    {                                                                        \
      int size = PVM_VAL_##TYPER##_SIZE (JITTER_TOP_STACK ());               \
      pvm_val res = pvm_make_##TYPERLC (OP PVM_VAL_##TYPE (JITTER_TOP_STACK ()), size); \
      JITTER_PUSH_STACK (res);                                               \
    } while (0)


/* Binary numeric operations.
  ( TYPE TYPE -- TYPE TYPE TYPE ) */
# define PVM_BINOP(TYPEA,TYPEB,TYPER,TYPERLC,OP)                             \
   do                                                                        \
    {                                                                        \
      int size = PVM_VAL_##TYPER##_SIZE (JITTER_UNDER_TOP_STACK ());       \
      pvm_val res = pvm_make_##TYPERLC (PVM_VAL_##TYPEA (JITTER_UNDER_TOP_STACK ()) \
                                        OP PVM_VAL_##TYPEB (JITTER_TOP_STACK ()), size); \
      JITTER_PUSH_STACK (res);                                               \
    } while (0)

/* Same, but with division by zero run-time check.  */
# define PVM_CHECKED_BINOP(TYPEA,TYPEB,TYPER,TYPERLC,OP)                     \
   if (PVM_VAL_##TYPEB (JITTER_TOP_STACK ()) == 0)                           \
   {                                                                         \
      PVM_RAISE (PVM_E_DIV_BY_ZERO, PVM_E_DIV_BY_ZERO_MSG);                  \
   }                                                                         \
   else                                                                      \
   {                                                                         \
      PVM_BINOP (TYPEA, TYPEB, TYPER, TYPERLC, OP);                          \
   }

/* Same, but for left-shifts, which includes an overflow check on the
   bit count.  */
# define PVM_BINOP_SL(TYPEA, TYPEB,TYPER,TYPERLC,OP)                         \
   {                                                                         \
     pvm_val type = pvm_typeof (JITTER_UNDER_TOP_STACK ());                  \
     uint64_t size = PVM_VAL_INTEGRAL (PVM_VAL_TYP_I_SIZE (type));           \
                                                                             \
     if (PVM_VAL_##TYPEB (JITTER_TOP_STACK ()) >= size)                      \
     {                                                                       \
        PVM_RAISE (PVM_E_OUT_OF_BOUNDS, PVM_E_OUT_OF_BOUNDS_MSG);            \
     }                                                                       \
     else                                                                    \
     {                                                                       \
        PVM_BINOP (TYPEA, TYPEB, TYPER, TYPERLC, OP);                        \
     }                                                                       \
   }

/* Exponentiation instructions.  */
# define PVM_POWOP(TYPE,TYPEC,TYPELC,POWF)                                  \
  do                                                                        \
  {                                                                         \
     uint64_t size = PVM_VAL_##TYPE##_SIZE (JITTER_UNDER_TOP_STACK ());     \
     TYPEC res                                                              \
      = (TYPEC) POWF (PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ()),           \
                      PVM_VAL_UINT (JITTER_TOP_STACK ()));                  \
                                                                            \
     JITTER_PUSH_STACK (pvm_make_##TYPELC (res, size));                     \
  }                                                                         \
  while (0)

/* Conversion instructions.
   ( TYPE -- TYPE RTYPE )  */
#define PVM_CONVOP(TYPE, TYPEC, RTYPELC, RTYPEC)                             \
   do                                                                        \
    {                                                                        \
      jitter_uint tsize = JITTER_ARGN0;                                      \
      TYPEC val = PVM_VAL_##TYPE (JITTER_TOP_STACK ());                      \
      JITTER_PUSH_STACK (pvm_make_##RTYPELC ((RTYPEC) val, tsize));          \
    } while (0)

/* Auxiliary macros used in PVM_PEEK and PVM_POKE below.  */
#define PVM_IOS_ARGS_INT                                                     \
  io, offset, 0, bits, endian, nenc, &value
#define PVM_IOS_ARGS_UINT                                                    \
  io, offset, 0, bits, endian, &value
#define PVM_IOS_ARGS_WRITE_INT                                               \
  io, offset, 0, bits, endian, nenc, value
#define PVM_IOS_ARGS_WRITE_UINT                                              \
  io, offset, 0, bits, endian, value

/* Integral peek instructions.
   ( IOS BOFF -- VAL )  */
#define PVM_PEEK(TYPE,IOTYPE,NENC,ENDIAN,BITS,IOARGS)                        \
  do                                                                         \
   {                                                                         \
     int ret;                                                                \
     __attribute__((unused)) enum ios_nenc nenc = (NENC);                    \
     enum ios_endian endian = (ENDIAN);                                      \
     int bits = (BITS);                                                      \
     IOTYPE##64_t value;                                                     \
     ios io;                                                                 \
     ios_off offset;                                                         \
                                                                             \
     offset = PVM_VAL_ULONG (JITTER_TOP_STACK ());                           \
     io = ios_search_by_id (PVM_VAL_INT (JITTER_UNDER_TOP_STACK ()));        \
                                                                             \
     if (io == NULL)                                                         \
       PVM_RAISE (PVM_E_NO_IOS, PVM_E_NO_IOS_MSG);                           \
                                                                             \
     JITTER_DROP_STACK ();                                                   \
     if ((ret = ios_read_##IOTYPE (IOARGS)) != IOS_OK)                       \
       {                                                                     \
         if (ret == IOS_EIOFF)                                               \
            PVM_RAISE (PVM_E_EOF, PVM_E_EOF_MSG);                            \
         else                                                                \
            PVM_RAISE (PVM_E_IO, PVM_E_IO_MSG);                              \
         JITTER_TOP_STACK () = PVM_NULL;                                     \
       }                                                                     \
     else                                                                    \
       JITTER_TOP_STACK () = pvm_make_##TYPE (value, bits);                  \
   } while (0)

/* Integral poke instructions.
   ( IOS BOFF VAL -- )  */
#define PVM_POKE(TYPE,IOTYPE,NENC,ENDIAN,BITS,IOARGS)                        \
  do                                                                         \
   {                                                                         \
     int ret;                                                                \
     __attribute__((unused)) enum ios_nenc nenc = (NENC);                    \
     enum ios_endian endian = (ENDIAN);                                      \
     int bits = (BITS);                                                      \
     IOTYPE##64_t value = PVM_VAL_##TYPE (JITTER_TOP_STACK ());              \
     pvm_val offset_val = JITTER_UNDER_TOP_STACK ();                         \
     ios io;                                                                 \
     ios_off offset;                                                         \
                                                                             \
     JITTER_DROP_STACK ();                                                   \
     JITTER_DROP_STACK ();                                                   \
                                                                             \
     io = ios_search_by_id (PVM_VAL_INT (JITTER_TOP_STACK ()));              \
                                                                             \
     if (io == NULL)                                                         \
       PVM_RAISE (PVM_E_NO_IOS, PVM_E_NO_IOS_MSG);                           \
     JITTER_DROP_STACK ();                                                   \
                                                                             \
     offset = PVM_VAL_ULONG (offset_val);                                    \
     if ((ret = ios_write_##IOTYPE (IOARGS)) != IOS_OK)                      \
       {                                                                     \
         if (ret == IOS_EIOFF)                                               \
            PVM_RAISE (PVM_E_EOF, PVM_E_EOF_MSG);                            \
         else                                                                \
            PVM_RAISE (PVM_E_IO, PVM_E_IO_MSG);                              \
       }                                                                     \
   } while (0)

/* Macro to call to a closure.  This is used in the instruction CALL,
   and also other instructions required to... call :D The argument
   should be a closure (surprise.)  */

#define PVM_CALL(CLS)                                                        \
   do                                                                        \
    {                                                                        \
       /* Make place for the return address in the return stack.  */         \
       /* actual value will be written by the callee. */                     \
       JITTER_PUSH_UNSPECIFIED_RETURNSTACK();                                \
                                                                             \
       /* Save the current environment and use the callee's environment. */     \
       JITTER_PUSH_RETURNSTACK ((jitter_uint) (uintptr_t) jitter_state_runtime.env); \
       jitter_state_runtime.env = PVM_VAL_CLS_ENV ((CLS));                   \
                                                                             \
       /* Branch-and-link to the native code, whose first instruction will */ \
       /*  be a prolog. */                                                   \
       JITTER_BRANCH_AND_LINK (PVM_VAL_CLS_ENTRY_POINT ((CLS)));           \
    } while (0)

/* Macros to implement printi* and printl* instructions.  */

#define PVM_PRINTI(TYPE,TYPEC,IFORMAT)                                      \
  do                                                                        \
  {                                                                         \
    TYPEC val = PVM_VAL_##TYPE (JITTER_TOP_STACK ());                       \
    char fmt[6];  /* %0NNd */                                               \
                                                                            \
    fmt[0] = '%';                                                           \
    fmt[1] = '0';                                                           \
    if (JITTER_ARGN1 == 10)                                                 \
    {                                                                       \
      fmt[2] = IFORMAT;                                                     \
      fmt[3] = '\0';                                                        \
    }                                                                       \
    else                                                                    \
    {                                                                       \
      int prec = 0;                                                         \
                                                                            \
      if (JITTER_ARGN1 == 256)                                              \
      {                                                                     \
        fmt[4] = 'c';                                                       \
        prec = 1;                                                           \
      }                                                                     \
      else if (JITTER_ARGN1 == 16)                                          \
      {                                                                     \
        fmt[4] = 'x';                                                       \
        prec = (JITTER_ARGN0 / 4) + ((JITTER_ARGN0 % 4) != 0);              \
      }                                                                     \
      else if (JITTER_ARGN1 == 8)                                           \
      {                                                                     \
        fmt[4] = 'o';                                                       \
        prec = (JITTER_ARGN0 / 3) + ((JITTER_ARGN0 % 3) != 0);              \
      }                                                                     \
      else if (JITTER_ARGN1 == 2)                                           \
      {                                                                     \
        pvm_print_binary (val, JITTER_ARGN0, 1);                            \
        JITTER_DROP_STACK ();                                               \
        break;                                                              \
      }                                                                     \
                                                                            \
      assert (prec != 0);                                                   \
      fmt[2] = '0' + (prec / 10);                                           \
      fmt[3] = '0' + prec - (prec / 10 * 10);                               \
      fmt[5] = '\0';                                                        \
    }                                                                       \
                                                                            \
    pk_printf (fmt, val);                                                   \
    JITTER_DROP_STACK ();                                                   \
  } while (0)

#define PVM_PRINTL(TYPE,TYPEC,IFORMAT)                                      \
  do                                                                        \
  {                                                                         \
    TYPEC val = PVM_VAL_##TYPE (JITTER_TOP_STACK ());                       \
    char fmt[7];  /* %0NNff */                                              \
                                                                            \
    fmt[0] = '%';                                                           \
    fmt[1] = '0';                                                           \
    fmt[4] = 'l';                                                           \
    if (JITTER_ARGN1 == 10)                                                 \
    {                                                                       \
      fmt[2] = IFORMAT;                                                     \
      fmt[3] = '\0';                                                        \
    }                                                                       \
    else                                                                    \
    {                                                                       \
      int prec = 0;                                                         \
                                                                            \
      if (JITTER_ARGN1 == 16)                                               \
      {                                                                     \
        fmt[5] = 'x';                                                       \
        prec = (JITTER_ARGN0 / 4) + ((JITTER_ARGN0 % 4) != 0);              \
      }                                                                     \
      else if (JITTER_ARGN1 == 8)                                           \
      {                                                                     \
        fmt[5] = 'o';                                                       \
        prec = (JITTER_ARGN0 / 3) + ((JITTER_ARGN0 % 3) != 0);              \
      }                                                                     \
      else if (JITTER_ARGN1 == 2)                                           \
      {                                                                     \
        pvm_print_binary (val, JITTER_ARGN0, 1);                            \
        JITTER_DROP_STACK ();                                               \
        break;                                                              \
      }                                                                     \
                                                                            \
      fmt[2] = '0' + (prec / 10);                                           \
      fmt[3] = '0' + prec - (prec / 10 * 10);                               \
      fmt[6] = '\0';                                                        \
    }                                                                       \
                                                                            \
    pk_printf (fmt, val);                                                   \
    JITTER_DROP_STACK ();                                                   \
  } while (0)

  end
end

late-c
  code
    void
    pvm_handle_signal (int signal_number)
    {
      struct vmprefix_state *s;

      /* For every state... */
      VMPREFIX_FOR_EACH_STATE (s)
      {
        /* ...Mark the signal signal_number as pending... */
        VMPREFIX_STATE_AND_SIGNAL_TO_PENDING_SIGNAL_NOTIFICATION
           (s, signal_number) = true;
        /* ...And record the fact that there is at least one notification to
           handle. */
        VMPREFIX_STATE_TO_PENDING_NOTIFICATIONS (s) = true;
      }
    }

    jitter_uint printer_hi;
  end
end

printer-c
  code
    void
    pvm_literal_printer_cast (FILE *out, jitter_uint val)
    {
      fflush (out);
      pk_printf ("%" JITTER_PRIu, val);
      pk_term_flush ();
    }

    void
    pvm_literal_printer (FILE *out, jitter_uint val)
    {
      /* XXX what about out.  */
      fflush (out);
      pvm_print_val ((pvm_val) val, poke_obase, 0);
      pk_term_flush ();
    }

    void
    pvm_literal_printer_hi (FILE *out, jitter_uint hi)
    {
      fflush (out);
      pk_printf ("%%hi(0x%" JITTER_PRIx ")", hi);
      pk_term_flush ();
      printer_hi = hi; /* This sucks */
    }

    void
    pvm_literal_printer_lo (FILE *out, jitter_uint lo)
    {
      fflush (out);
      pk_printf ("%%lo(0x%" JITTER_PRIx") (", lo);
      pvm_print_val (((pvm_val) printer_hi << 32) | lo,
                      poke_obase, 0);
      pk_puts (")");
      pk_term_flush ();
      printer_hi = 0;
    }

    void
    popf_printer (FILE *out, jitter_uint nframes)
    {
      fflush (out);
      pk_printf ("%" JITTER_PRIu, nframes);
      pk_term_flush ();
    }

    void
    bits_printer (FILE *out, jitter_uint val)
    {
      fflush (out);
      pk_printf ("%" JITTER_PRIu, val);
      pk_term_flush ();
    }

    void
    endian_printer (FILE *out, jitter_uint val)
    {
      fflush (out);
      pk_printf ("%s", val == IOS_ENDIAN_MSB ? "big" : "little");
      pk_term_flush ();
    }

    void
    nenc_printer (FILE *out, jitter_uint val)
    {
      fflush (out);
      pk_printf ("%s", val == IOS_NENC_1 ? "1c" : "2c");
      pk_term_flush ();
    }
  end
end


## PVM state.

# Jitter supports maintaining a VM state which is splitted in
# `backing' and `runtime', so the question arises what to put in either
# part of the state.  According to the comments generated by jitterc:
#
# "The machine state is separated into the backing and the more
#  compact runtime data structures, to be allocated in registers as
#  far as possible.  These are just a forward-declarations: the actual
#  definitions are machine-generated."
#
# and:
#
# "The state backing and runtime are initialized at the same time, and
#  in fact the distinction between them is invisible to the VM user."
#
# So it looks like both `backing' and `runtime' are available at
# runtime, but accessing runtime is much more efficient because it is
# kept in host machine registers if possible.

state-struct-backing-c
  code
      enum pvm_exit_code exit_code;
      pvm_val result_value;
      jitter_stack_height canary;
  end
end

state-struct-runtime-c
  code
      pvm_env env;
      uint32_t push_hi;
      uint32_t endian;
      uint32_t nenc;
      uint32_t pretty_print;
      enum pvm_omode omode;
      int omaps;
      uint32_t odepth;
      uint32_t oindent;
      uint32_t oacutoff;
  end
end

state-initialization-c
  code
      jitter_state_backing->canary = NULL;
      jitter_state_backing->exit_code = PVM_EXIT_OK;
      jitter_state_backing->result_value = PVM_NULL;
      /* XXX: are these reasonable defaults? */
      jitter_state_runtime->endian = IOS_ENDIAN_MSB;
      jitter_state_runtime->nenc = IOS_NENC_2;
      jitter_state_runtime->pretty_print = 0;
      jitter_state_runtime->omode = PVM_PRINT_FLAT;
      jitter_state_runtime->omaps = 0;
      jitter_state_runtime->odepth = 0;
      jitter_state_runtime->oindent = 2;
      jitter_state_runtime->oacutoff = 0;
  end
end

state-finalization-c
  code
   /* Finalize extra state here.  */
  end
end


### Begin of instructions

## VM instructions

# Instruction: canary
#
# This instruction installs a canary to mark the bottom of the stack,
# which is cheched by the `exit' instruction.  To be most effective this
# should be executed before the stack is used for the first time.
#
# Stack: ( -- )

instruction canary ()
  code
     jitter_original_state->pvm_state_backing.canary
      = JITTER_HEIGHT_STACK ();
  end
end

# Instruction: exit
#
# Do some cleanup and finish execution of a PVM program.  This checks
# the stack centinel installed by the `canary' instruction.
#
# Stack: ( -- )

instruction exit ()
  code
    /* The element at the top of the stack is the exit
       code to report to the PVM caller.  */
    jitter_original_state->pvm_state_backing.exit_code
      = PVM_VAL_INT (JITTER_TOP_STACK());

    JITTER_DROP_STACK ();

    /* Get the result of the execution, if any.  */
    jitter_original_state->pvm_state_backing.result_value
                = JITTER_TOP_STACK();
    JITTER_DROP_STACK ();

    /* Check for the stack centinel, but only if it was
       installed.  */
    if (jitter_original_state->pvm_state_backing.canary != NULL)
      assert (jitter_original_state->pvm_state_backing.canary
              == JITTER_HEIGHT_STACK ());

    /* Clear pending signals.  */
    {
      int i;
      for (i = 0; i < JITTER_SIGNAL_NO; i ++)
        if (JITTER_PENDING_SIGNAL_NOTIFICATION (i))
          JITTER_PENDING_SIGNAL_NOTIFICATION (i) = false;
      JITTER_PENDING_NOTIFICATIONS = false;
    }

    JITTER_EXIT ();
  end
end

# Instruction: pushend
#
# Push the current endianness to the stack.  This endianness is part
# of the global state of the PVM.
#
# Stack: ( -- INT )

instruction pushend ()
  code
    JITTER_PUSH_STACK (pvm_make_int (jitter_state_runtime.endian,
                                     32));
  end
end

# Instruction: popend
#
# Pop a signed integer from the stack and make it the current
# endianness in the PVM.  The possible values for endianness are
# IOS_ENDIAN_LSB and IOS_ENDIAN_MSB.
#
# Stack: ( INT -- )

instruction popend ()
  code
    uint32_t endian = PVM_VAL_INT (JITTER_TOP_STACK ());
    jitter_state_runtime.endian = endian;
    JITTER_DROP_STACK ();
  end
end

# Instruction: sync
#
# Handle pending signals, and raise exceptions accordingly.  This
# instruction should be emitted in strategic places, such as before
# backwards jumps and at function prolog, to assure signals are
# eventually attended to.
#
# Stack: ( -- )
# Exceptions: PVM_E_SIGNAL

instruction sync ()
  code
    /* XXX for now we treat all signals the same way.
       As soon as we support exception arguments, we shall
       pass the mask of signals to the signal handler.  */
    if (JITTER_PENDING_NOTIFICATIONS)
      PVM_RAISE (PVM_E_SIGNAL, PVM_E_SIGNAL_MSG);
  end
end


## IOS related instructions

# Instruction: open
#
# Open a new IO space.  The handler string and a set of flags are
# passed on the stack.  The descriptor of the opened IOS is pushed to
# the stack as a signed integer.
#
# If there is no other IO space opened when this instruction is
# executed, then the just opened space becomes the current IO space.
#
# If it is not possible to open the IO space according to the provided
# flags, the PVM_E_IOFLAGS exception is raised.  If there is any other
# error performing the operation, PVM_E_IO is raised.
#
# Stack: ( STR ULONG -- INT )
# Exceptions: PVM_E_IOFLAGS, PVM_E_IO

instruction open ()
  code
     char *filename = PVM_VAL_STR (JITTER_UNDER_TOP_STACK ());
     uint64_t flags = PVM_VAL_ULONG (JITTER_TOP_STACK ());

     int ret = ios_open (filename, flags, 0);

     if (ret == IOS_EFLAGS)
       PVM_RAISE (PVM_E_IOFLAGS, PVM_E_IOFLAGS_MSG);
     else if (ret == IOS_ERROR)
       PVM_RAISE (PVM_E_IO, PVM_E_IO_MSG);

     JITTER_DROP_STACK ();
     JITTER_TOP_STACK () = pvm_make_int (ret, 32);
  end
end

# Instruction: close
#
# Close an IO space.  The descriptor of the space to close is provided
# in the stack as a signed integer.
#
# If the specified IO space doesn't exist, this instruction raises
# PVM_E_IO.
#
# Stack: ( INT -- )
# Exceptions: PVM_E_IO

instruction close ()
  code
    int io_id = PVM_VAL_INT (JITTER_TOP_STACK ());
    ios io = ios_search_by_id (io_id);

    if (io == NULL)
      PVM_RAISE (PVM_E_IO, PVM_E_IO_MSG);

    ios_close (io);
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushios
#
# Push the descriptor of the current IO space to the stack, as a
# signed integer.  If no IO space is currently opened, raise
# PVM_E_NO_IOS.
#
# Stack: ( -- INT )
# Exceptions: PVM_E_NO_IOS

instruction pushios ()
  code
    ios cur_io = ios_cur ();

    if (cur_io == NULL)
       PVM_RAISE (PVM_E_NO_IOS, PVM_E_NO_IOS_MSG);
    JITTER_PUSH_STACK (pvm_make_int (ios_get_id (cur_io), 32));
  end
end

# Instruction: popios
#
# Pop an IO space descriptor from the stack and set it as the current
# IO space.  If the specified descriptor doesn't identify an IO space,
# raise PVM_E_NO_IOS.
#
# Stack: ( INT -- )
# Exceptions: PVM_E_NO_IOS

instruction popios ()
  code
    ios io = ios_search_by_id (PVM_VAL_INT (JITTER_TOP_STACK ()));

    if (io == NULL)
      PVM_RAISE (PVM_E_NO_IOS, PVM_E_NO_IOS_MSG);
    ios_set_cur (io);
    JITTER_DROP_STACK ();
  end
end

# Instruction: iosize
#
# Push the size of the given IO space to the stack, as an offset.  The
# IO space is identified by a descriptor, which is a signed integer.
# If the given IO space doesn't exist, raise PVM_E_NO_IOS.
#
# Stack: ( INT -- INT OFF )
# Exceptions: PVM_E_NO_IOS

instruction iosize ()
  code
    ios io = ios_search_by_id (PVM_VAL_INT (JITTER_TOP_STACK ()));

    if (io == NULL)
      PVM_RAISE (PVM_E_NO_IOS, PVM_E_NO_IOS_MSG);

    JITTER_PUSH_STACK (pvm_make_offset (pvm_make_ulong (ios_size (io), 64),
                                        pvm_make_ulong (1, 64)));
  end
end


# Instruction: iogetb
#
# Each IO space has a bias associated with it, which by default is 0
# bits.  This bias is applied to the offset given to every read/write
# operation.
#
# This instruction pushes the bias associated to the given IO space to
# the stack, as an offset.  If the given IO space doesn't exist then
# the exception PVM_E_NO_IOS is raised.
#
# Stack: ( INT - INT OFF )
# Exceptions: PVM_E_NO_IOS

instruction iogetb ()
  code
    ios io = ios_search_by_id (PVM_VAL_INT (JITTER_TOP_STACK ()));

    if (io == NULL)
      PVM_RAISE (PVM_E_NO_IOS, PVM_E_NO_IOS_MSG);

    JITTER_PUSH_STACK (pvm_make_offset (pvm_make_ulong (ios_get_bias (io), 64),
                                        pvm_make_ulong (1, 64)));
  end
end

# Instruction: iosetb
#
# Each IO space has a bias associated with it, which by default is 0
# bits.  This bias is applied to the offset given to every read/write
# operation.
#
# This instruction sets the bias associated to the given IO space.
# The bias is specified as an offset.  If the given IO space doesn't
# exist, the exception PVM_E_NO_IOS is raised.
#
# Stack: ( INT OFF -- INT )
# Exceptions: PVM_E_NO_IOS

instruction iosetb ()
  code
    pvm_val bias = JITTER_TOP_STACK();
    ios io = ios_search_by_id (PVM_VAL_INT (JITTER_UNDER_TOP_STACK ()));

    JITTER_DROP_STACK ();

    if (io == NULL)
      PVM_RAISE (PVM_E_NO_IOS, PVM_E_NO_IOS_MSG);

    ios_set_bias (io,
                  (PVM_VAL_INTEGRAL (PVM_VAL_OFF_MAGNITUDE (bias))
                   * PVM_VAL_INTEGRAL (PVM_VAL_OFF_UNIT (bias))));
  end
end


## Function management instructions

# Instruction: call
#
# Call a closure in the stack, passing the specified arguments.  After
# the execution of the closure, control is transferred to the
# instruction immediately following the call instruction.
#
# Stack: ( ARG1 ... ARGN CLOSURE -- RETVAL )

instruction call ()
  caller
  code
    pvm_val closure = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
    PVM_CALL (closure);
  end
end

# Instruction: prolog
#
# Prepare the PVM for the execution of a function.  This instruction
# shall be the target of every `call' instruction and shall be the
# first instruction in every function body.
#
# Stack: ( -- )

instruction prolog ()
  callee
  code
    /* Fill the return stack slot with the return address.  The return
       stack has already been pushesd (with an unspecified value on the
       under top) by the caller. */
    JITTER_UNDER_TOP_RETURNSTACK() = (jitter_uint) JITTER_LINK;
  end
end

# Instruction: return
#
# Return from a function.  A function can have many `return'
# instructions.
#
# Stack: ( -- )

instruction return ()
  code
    jitter_uint return_address;

    /* Restore the environment of the caller.  Note the cast to
       jitter_uint is to avoid a warning in 32-bit.  */
    jitter_state_runtime.env = (pvm_env) (jitter_int) JITTER_TOP_RETURNSTACK ();
    JITTER_DROP_RETURNSTACK();

    return_address = JITTER_TOP_RETURNSTACK();
    JITTER_DROP_RETURNSTACK();

    JITTER_RETURN (return_address);
  end
end


## Environment instructions

# Instruction: pushf
#
# Push a new lexical frame.
#
# Stack: ( -- )

instruction pushf ()
  code
    jitter_state_runtime.env
       = pvm_env_push_frame (jitter_state_runtime.env);
  end
end

# Instruction: popf
#
# Pop a lexical frame.
#
# Stack: ( -- )

instruction popf (?n popf_printer)
  code
    jitter_uint i;

    for (i = 0; i < JITTER_ARGN0; ++i)
        jitter_state_runtime.env
           = pvm_env_pop_frame (jitter_state_runtime.env);
  end
end

# Instruction: pushvar BACK, OVER
#
# Retrieve the value of a variable from the lexical environment and
# push it to the stack.  The lexical address of the variable is
# specified as arguments to the instruction.
#
# Stack: ( -- VAL )

instruction pushvar (?n 0, ?n 0 1 2 3 4 5)
  code
    JITTER_PUSH_STACK (pvm_env_lookup (jitter_state_runtime.env,
                                       (int) JITTER_ARGN0,
                                       (int) JITTER_ARGN1));
  end
end

# Instruction: popvar BACK, OVER
#
# Pop a value from the stack and set it as the value of a variable
# having the lexical address specified in the arguments, in the
# current lexical environment.
#
# Stack: ( VAL -- )

instruction popvar (?n, ?n)
  code
    pvm_env_set_var (jitter_state_runtime.env,
                     (int) JITTER_ARGN0,
                     (int) JITTER_ARGN1,
                     JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: regvar
#
# Pop a value from the stack and use it as the value for a new
# variable in the current lexical environment.
#
# Stack: ( VAL -- )

instruction regvar ()
  code
    pvm_env_register (jitter_state_runtime.env,
                      JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: pec
#
# Put the current lexical environment to the closure at the top of the
# stack.
#
# Stack: ( CLS -- CLS )

instruction pec ()
  code
    pvm_val cls = JITTER_TOP_STACK ();
    PVM_VAL_CLS_ENV (cls) = jitter_state_runtime.env;
  end
end


## Printing Instructions

# In the following instructions the meaning of the argument BASE is
# the following:
#
# 2 - print the number in binary.
# 8 - print the number in octal.
# 16 - print the number in hexadecimal.
# Any other value - print the number in decimal.

# Instruction: printi BITS, BASE
#
# Print the signed integer at the top of the stack using the width in
# BITS and numeration base BASE.
#
# Stack: ( INT -- )

instruction printi (?n popf_printer, ?n popf_printer)
  code
    PVM_PRINTI (INT, int32_t, 'd');
  end
end

# Instruction: printiu BITS, BASE
#
# Print the unsigned integer at the top of the stack using the width
# in BITS and numeration base BASE.
#
# Stack: ( UINT -- )

instruction printiu (?n popf_printer, ?n popf_printer)
  code
    PVM_PRINTI (UINT, uint32_t, 'u');
  end
end

# Instruction: printl BITS, BASE
#
# Print the signed long at the top of the stack using the width in
# BITS and numeration base BASE.
#
# Stack: ( LONG -- )

instruction printl (?n popf_printer, ?n popf_printer)
  code
    PVM_PRINTL (LONG, int64_t, 'd');
  end
end

# Instruction: printlu BITS, BASE
#
# Print the unsigned long at the top of the stack using the width in
# BITS and numeration base BASE.
#
# Stack: ( ULONG -- )

instruction printlu (?n popf_printer, ?n popf_printer)
  code
   PVM_PRINTL (ULONG, uint64_t, 'u');
  end
end

# Instruction: prints
#
# Print the string at the top of the stack.
#
# Stack: ( STR -- )

instruction prints ()
  code
    pvm_print_string (JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: printv MODE, DEPTH
#
# Print the PVM value at the top of the stack, using the same printer
# that is used in the REPL.  This takes into account pretty-printers.
#
# MODE can be one of the printing modes PVM_PRINT_* defined in pvm.h.
# DEPTH is either 0 (meaning no depth limit while printing structures) or
# a positive integer, specifying how many levels of structures to print.
#
# Stack: ( VAL -- )

instruction printv (?n,?n)
  code
    int mode = (int) JITTER_ARGN0;
    int depth = (int) JITTER_ARGN1;
    int indent = jitter_state_runtime.oindent;
    int maps = jitter_state_runtime.omaps;

    pvm_print_val (JITTER_TOP_STACK (), poke_obase,
                   PVM_PRINT_F_MODE (mode)
                   | PVM_PRINT_F_MAPS (maps)
                   | PVM_PRINT_F_DEPTH (depth)
                   | PVM_PRINT_F_INDENT (indent));

    JITTER_DROP_STACK ();
  end
end

# Instruction: begsc
#
# Begin the styling class whose name is found in the stack.  This
# class will be in effect in subsequent print operations until it is
# explicitly ended by a `endsc' instruction.
#
# Stack: ( STR -- )

instruction begsc ()
  code
    pk_term_class (PVM_VAL_STR (JITTER_TOP_STACK ()));
    JITTER_DROP_STACK ();
  end
end

# Instruction: endsc
#
# End the styling class whose name is found in the stack.  This class
# should have been previously began by a `begsc' instruction.
#
# Stack: ( STR -- )

instruction endsc ()
  code
    pk_term_end_class (PVM_VAL_STR (JITTER_TOP_STACK ()));
    JITTER_DROP_STACK ();
  end
end


## Main stack manipulation instructions

# Instruction: push VAL
#
# Push the value given as an argument to the main stack.
#
# Stack: ( -- VAL )

instruction push (?nl pvm_literal_printer)
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK(k);
  end
end

# Instruction: drop
#
# Pop the value at the top of the main stack, and discard it.
#
# Stack: ( VAL -- )

instruction drop ()
  code
    JITTER_DROP_STACK();
  end
end

# Instruction: drop2
#
# Pop the two values at the top of the main stack, and discard them.
#
# Stack: ( VAL VAL -- )

instruction drop2 ()
  code
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
  end
end

# Instruction: drop3
#
# Pop the three values at the top of the main stack, and discard them.
#
# Stack: ( VAL VAL VAL -- )

instruction drop3 ()
  code
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
  end
end

# Instruction: drop4
#
# Pop the four values at the top of the stack, and discard them.
#
# Stack: ( VAL VAL VAL VAL -- )

instruction drop4 ()
  code
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
  end
end

# Instruction: swap
#
# Exchange the two elements at the top of the stack.
#
# Stack: ( A B -- B A)

instruction swap ()
  code
    pvm_val tmp = JITTER_UNDER_TOP_STACK ();
    JITTER_UNDER_TOP_STACK () = JITTER_TOP_STACK ();
    JITTER_TOP_STACK () = tmp;
  end
end

# Instruction: nip
#
# Discard the element at the under top of the main stack.
#
# Stack: ( A B -- B )

instruction nip ()
  code
    JITTER_NIP_STACK();
  end
end

# Instruction: nip2
#
# Discard the two elements at the under top of the main stack.
#
# Stack: ( A B C -- C )

instruction nip2 ()
  code
    JITTER_NIP_STACK ();
    JITTER_NIP_STACK ();
  end
end

# Instruction: nip3
#
# Discard the three elements at the under top of the main stack.
#
# Stack: ( A B C D -- D )

instruction nip3 ()
  code
    JITTER_NIP_STACK ();
    JITTER_NIP_STACK ();
    JITTER_NIP_STACK ();
  end
end

# Instruction: dup
#
# Push a copy of the element at the top of the main stack.
#
# Stack: ( A -- A A )

instruction dup ()
  code
    JITTER_DUP_STACK ();
  end
end

# Instruction: over
#
# Push a copy of the element at the under top of the main stack.
#
# Stack: ( A B -- A B A )

instruction over ()
  code
    JITTER_PUSH_STACK (JITTER_UNDER_TOP_STACK ());
  end
end

# Instruction: rot
#
# Rotate the three elements at the top of the main stack, clock-wise.
#
# Stack: ( A B C -- B C A )

instruction rot ()
  code
    JITTER_ROT_STACK ();
  end
end

# Instruction: nrot
#
# Rotate the three elements at the top of the main stakc, counter
# clock-wise.
#
# Stack: ( A B C -- C A B )

instruction nrot ()
  code
    JITTER_MROT_STACK ();
  end
end

# Instruction: tuck
#
# Tuck a copy of the element at the top of the main stack down two
# positions.
#
# Stack: ( A B -- B A B )

instruction tuck ()
  code
    JITTER_TUCK_STACK ();
  end
end

# Instruction: quake
#
# Swap the two elements at the under top of the main stack.
#
# Stack: ( A B C - B A C )

instruction quake ()
  code
    JITTER_QUAKE_STACK ();
  end
end

# Instruction: revn N
#
# Reverse the N elements at the top of the main stack.
#
# Stack: ( VAL{N} -- VAL{N} )

instruction revn (?n 3 4 popf_printer)
  code
    JITTER_REVERSE_STACK (JITTER_ARGU0);
  end
end

# Instruction: pushhi VAL
#
# Push the high 32 bits of the value passed as an argument to the main
# stack.  This instruction shall be completed with a `pushlo'.
#
# This instruction is a workaround to a limitation of Jitter.
#
# Stack: ( -- HI32(VAL) )

instruction pushhi (?nl pvm_literal_printer_hi)
  code
     jitter_state_runtime.push_hi
       = JITTER_ARGN0;
  end
end

# Instruction: pushlo VAL
#
# Push the low 32 bits of the value passed as an argument to the main
# stack.  This instruction shall be preceded by a `pushhi'.
#
# This instruction is a workaround to a limitation of Jitter.
#
# Stack: ( -- LO32(VAL) )

instruction pushlo (?nl pvm_literal_printer_lo)
  code
     pvm_val k
       = ((pvm_val) jitter_state_runtime.push_hi << 32)
         | JITTER_ARGN0;
     JITTER_PUSH_STACK (k);
  end
end

# Instruction: push32 VAL
#
# Push the value passed as an argument to the main stack.  This
# assumes that the internal representation of VAL doesn't require more
# than 32-bit.
#
# This instruction is a workaround to a limitation of Jitter.
#
# Stack: ( -- VAL )

instruction push32 (?nl pvm_literal_printer)
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK (k);
  end
end


## Registers manipulation instructions

# Instruction: pushr REGNO
#
# Push the contents of the register REGNO to the main stack.
#
# Stack: ( -- VAL )

instruction pushr (?R)
  code
    JITTER_PUSH_STACK (JITTER_ARG0);
  end
end

# Instruction: popr REGNO
#
# Pop the element at the top of the main stack and put it in the
# register REGNO.
#
# Stack: ( VAL -- )

instruction popr (!R)
  code
    JITTER_ARG0 = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
  end
end

# Instruction: setr REGNO
#
# Set the element at the top of the main stack to the value of the
# register REGNO.
#
# Stack: ( -- )

instruction setr (!R)
  code
    JITTER_ARG0 = JITTER_TOP_STACK();
  end
end


## Return stack manipulation instructions

# Instruction: saver REGNO
#
# Push the contents of the register REGNO to the return stack.
#
# Stack: ( -- )
# ReturnStack: ( -- VAL )

instruction saver (?R)
  code
    JITTER_PUSH_RETURNSTACK (JITTER_ARG0);
  end
end

# Instruction: restorer REGNO
#
# Pop the element at the top of the return stack and put it in the
# register REGNO.
#
# Stack: ( -- )
# ReturnStack: ( VAL -- )

instruction restorer (!R)
  code
    JITTER_ARG0 = JITTER_TOP_RETURNSTACK ();
    JITTER_DROP_RETURNSTACK ();
  end
end

# Instruction: tor
#
# Pop an element from the main stack and push it in the return stack.
#
# Stack: ( VAL -- )
# ReturnStack: ( -- VAL )

instruction tor ()
  code
    JITTER_PUSH_RETURNSTACK (JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: fromr
#
# Pop an element from the return stack and push it in the main stack.
#
# Stack: ( -- VAL)
# ReturnStack: ( VAL -- )

instruction fromr ()
  code
    JITTER_PUSH_STACK (JITTER_TOP_RETURNSTACK ());
    JITTER_DROP_RETURNSTACK ();
  end
end

# Instruction: atr
#
# Push a copy of the element at the top of the return stack into the
# main stack.
#
# Stack: ( -- VAL )

instruction atr ()
  code
    JITTER_PUSH_STACK (JITTER_TOP_RETURNSTACK ());
  end
end


## Arithmetic instructions

# The following instructions assume that both operands have the same
# size in bits.

# Instruction: addi
#
# Push the result of adding the two integers at the top of the main
# stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction addi ()
  code
    PVM_BINOP (INT, INT, INT, int,  +);
  end
end

# Instruction: addiu
#
# Push the result of adding the two unsigned integers at the top of
# the main stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction addiu ()
  code
    PVM_BINOP (UINT, UINT, UINT, uint,  +);
  end
end

# Instruction addl
#
# Push the result of adding the two longs at the top of the main
# stack.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction addl ()
  code
    PVM_BINOP (LONG, LONG, LONG, long,  +);
  end
end

# Instruction: addlu
#
# Push the result of adding the two unsigned longs at the top of
# the main stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction addlu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, ulong,  +);
  end
end

# Instruction: subi
#
# Push the result of subtracting the two integers at the top of
# the main stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction subi ()
  code
    PVM_BINOP (INT, INT, INT, int,  -);
  end
end

# Instruction: subiu
#
# Push the result of subtracting the two unsigned integers at the
# top of the main stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction subiu ()
  code
    PVM_BINOP (UINT, UINT, UINT, uint,  -);
  end
end

# Instruction: subl
#
# Push the result of subtracting the two longs at the top
# of the main stack.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction subl ()
  code
    PVM_BINOP (LONG, LONG, LONG, long,  -);
  end
end

# Instruction: sublu
#
# Push the result of subtracting the two unsigned longs at the
# top of the main stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction sublu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, ulong,  -);
  end
end

# Instruction: muli
#
# Push the result of multiplying the two integers at the top of the
# main stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction muli ()
  code
    PVM_BINOP (INT, INT, INT, int,  *);
  end
end

# Instruction: muliu
#
# Push the result of multiplying the two unsigned integers at the
# top of the main stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction muliu ()
  code
    PVM_BINOP (UINT, UINT, UINT, uint,  *);
  end
end

# Instruction: mull
#
# Push the result of multiplying the two longs at the top of the
# main stack.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction mull ()
  code
    PVM_BINOP (LONG, LONG, LONG, long,  *);
  end
end

# Instruction: mullu
#
# Push the result of multiplying the two unsigned longs at the top
# of the main stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction mullu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, ulong,  *);
  end
end

# Instruction: divi
#
# Push the result of the integer division of the two integers at
# the top of the main stack.  If the denominator is zero, raise
# PVM_E_DIV_BY_ZERO.
#
# Stack: ( INT INT -- INT INT INT )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction divi ()
  code
    PVM_CHECKED_BINOP (INT, INT, INT, int, /);
  end
end

# Instruction: diviu
#
# Push the result of the integer division of the two unsigned integers
# at the top of the main stack.  If the denominator is zero, raise
# PVM_E_DIV_BY_ZERO.
#
# Stack: ( UINT UINT -- UINT UINT UINT )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction diviu ()
  code
    PVM_CHECKED_BINOP (UINT, UINT, UINT, uint, /);
  end
end

# Instruction: divl
#
# Push the result of the integer division of the two longs at
# the top of the main stack.  If the denominator is zero, raise
# PVM_E_DIV_BY_ZERO.
#
# Stack: ( LONG LONG -- LONG LONG LONG )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction divl ()
  code
    PVM_CHECKED_BINOP (LONG, LONG, LONG, long, /);
  end
end

# Instruction: divlu
#
# Push the result of the integer division of the two unsigned
# longs at the top of the stack.  If the denominator is zero,
# raise PVM_E_DIV_BY_ZERO.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction divlu ()
  code
    PVM_CHECKED_BINOP (ULONG, ULONG, ULONG, ulong, /);
  end
end

# Instruction: modi
#
# Push the result of the modulus of the two integers at the top
# of the main stack.  If the denominator is zero, raise
# PVM_E_DIV_BY_ZERO.
#
# Stack: ( INT INT -- INT INT INT )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction modi ()
  code
    PVM_CHECKED_BINOP (INT, INT, INT, int, %);
  end
end

# Instruction: modiu
#
# Push the result of the modulus of the two unsigned integers at
# the top of the main stack.  If the denominator is zero, raise
# PVM_E_DIV_BY_ZERO.
#
# Stack: ( UINT UINT -- UINT UINT UINT )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction modiu ()
  code
    PVM_CHECKED_BINOP (UINT, UINT, UINT, uint, %);
  end
end

# Instruction: modl
#
# Push the result of the modulus of the two longs at the top
# of the main stack.  If the denominator is zero, raise
# PVM_E_DIV_BY_ZERO.
#
# Stack: ( LONG LONG -- LONG LONG LONG )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction modl ()
  code
    PVM_CHECKED_BINOP (LONG, LONG, LONG, long, %);
  end
end

# Instruction: modlu
#
# Push the result of the modulus of the two unsigned longs at the
# top of the main stack.  If the denominator is zero, raise
# PVM_E_DIV_BY_ZERO.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction modlu ()
  code
    PVM_CHECKED_BINOP (ULONG, ULONG, ULONG, ulong, %);
  end
end

# Instruction: negi
#
# Push the result of the negation of the integer at the top of the
# main stack.
#
# Stack: ( INT -- INT INT )

instruction negi ()
  code
    PVM_UNOP (INT, INT, int, -);
  end
end

# Instruction: negiu
#
# Push the result of the negation of the unsigned integer at the
# top of the main stack.
#
# Stack: ( UINT -- UINT UINT UINT )

instruction negiu ()
  code
    PVM_UNOP (UINT, UINT, uint, -);
  end
end

# Instruction: negl
#
# Push the result of the negation of the long at the top of the
# main stack.
#
# Stack: ( LONG -- LONG LONG )

instruction negl ()
  code
    PVM_UNOP (LONG, LONG, long, -);
  end
end

# Instruction: neglu
#
# Push the result of the negation of the unsigned long at the top
# of the main stack.
#
# Stack: ( ULONG -- ULONG ULONG )

instruction neglu ()
  code
    PVM_UNOP (ULONG, ULONG, ulong, -);
  end
end

# Instruction: powi
#
# Perform the exponentiation of the integer at the under top of the
# main stack.  The exponent is the unsigned integer at the top of the
# stack.  If the exponent is 0, the result is 1.
#
# Stack: ( INT UINT -- INT UINT INT )

instruction powi ()
  code
    PVM_POWOP (INT,int64_t,int,pk_ipow);
  end
end

# Instruction: powiu
#
# Perform the exponentiation of the unsigned integer at the under top
# of the main stack.  The exponent is the unsigned integer at the top
# of the stack.  If the exponent is 0, the result is 1.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction powiu ()
  code
    PVM_POWOP (UINT,uint64_t,uint,pk_upow);
  end
end

# Instruction: powl
#
# Perform the exponentiation of the long at the under top of the
# main stack.  The exponent is the unsigned integer at the top of the
# stack.  If the exponent is 0, the result is 1.
#
# Stack: ( LONG UINT -- LONG UINT LONG )

instruction powl ()
  code
    PVM_POWOP (LONG,int64_t,long,pk_ipow);
  end
end

# Instruction: powlu
#
# Perform the exponentiation of the unsigned long at the under top
# of the main stack.  The exponent is the unsigned integer at the top
# of the stack.  If the exponent is 0, the result is 1.
#
# Stack: ( ULONG UINT -- ULONG UINT ULONG )

instruction powlu ()
  code
    PVM_POWOP (ULONG,uint64_t,ulong,pk_upow);
  end
end


## Relational instructions

# Instruction: eqi
#
# Push 1 to the main stack if the two integers at the top of
# the main stack are equal.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction eqi ()
  code
     PVM_BOOL_BINOP (INT, ==);
  end
end

# Instruction: eqiu
#
# Push 1 to the main stack if the two unsigned integers at the top of
# the main stack are equal.  Otherwise push 0.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction eqiu ()
  code
     PVM_BOOL_BINOP (UINT, ==);
  end
end

# Instruction: eql
#
# Push 1 to the main stack if the two longs at the top of
# the main stack are equal.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction eql ()
  code
     PVM_BOOL_BINOP (LONG, ==);
  end
end

# Instruction: eqlu
#
# Push 1 to the main stack if the two unsigned longs at the top of the
# main stack are equal.  Otherwise push 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction eqlu ()
  code
     PVM_BOOL_BINOP (ULONG, ==);
  end
end

# Instruction: eqs
#
# Push 1 to the main stack if the two strings at the top of the
# main stack are equal.  Otherwise push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction eqs ()
  code
    pvm_val res = pvm_make_int (STREQ (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                       PVM_VAL_STR (JITTER_TOP_STACK ())),
                                32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: nei
#
# Push 1 to the main stack if the two integers at the top of the
# main stack are not equal.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction nei ()
  code
     PVM_BOOL_BINOP (INT, !=);
  end
end

# Instruction: neiu
#
# Push 1 to the main stack if the two unsigned integers at the top of
# the main stack are not equal.  Otherwise push 0.
#
# Stack: ( UINT UINT -- UINT UINT INT )

instruction neiu ()
  code
     PVM_BOOL_BINOP (UINT, !=);
  end
end

# Instruction: nel
#
# Push 1 to the main stack if the two longs at the top of the
# main stack are not equal.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction nel ()
  code
     PVM_BOOL_BINOP (LONG, !=);
  end
end

# Instruction: nelu
#
# Push 1 to the main stack if the two unsigned longs at the top of the
# main stack are not equal.  Otherwise push 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction nelu ()
  code
     PVM_BOOL_BINOP (ULONG, !=);
  end
end

# Instruction: nes
#
# Push 1 to the main stack if the two strings at the top of the main
# stack are not equal.  Otherwise push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction nes ()
  code
    pvm_val res = pvm_make_int (STRNEQ (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())),
                                32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: nn
#
# Push 1 to the main stack if the value at the top of the main
# stack equals PVM_NULL.  Otherwise push 0.
#
# Stack: ( VAL -- VAL INT )

instruction nn ()
  code
     JITTER_PUSH_STACK (pvm_make_int (JITTER_TOP_STACK () != PVM_NULL,
                                      32));
  end
end

# Instruction: lti
#
# Push 1 to the main stack if the integer at the under top is
# less that the integer at the top.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction lti ()
  code
     PVM_BOOL_BINOP (INT, <);
  end
end

# Instruction: ltiu
#
# Push 1 to the main stack if the unsigned integer at the under top is
# less that the unsigned integer at the top.  Otherwise push 0.
#
# Stack: ( UINT INT -- UINT UINT INT )

instruction ltiu () # ( UINT UINT -- UINT UINT INT )
  code
     PVM_BOOL_BINOP (UINT, <);
  end
end

# Instruction: ltl
#
# Push 1 to the main stack if the long at the under top is
# less that the long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction ltl () # ( LONG LONG -- LONG LONG INT )
  code
     PVM_BOOL_BINOP (LONG, <);
  end
end

# Instruction: ltlu
#
# Push 1 to the main stack if the unsigned long at the under top is
# less that the unsigned long at the top.  Otherwise push 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction ltlu ()
  code
     PVM_BOOL_BINOP (ULONG, <);
  end
end

# Instruction: lei
#
# Push 1 to the main stack if the integer at the under top is
# less or equal that the integer at the top.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction lei () # ( INT INT -- INT INT INT )
  code
     PVM_BOOL_BINOP (INT, <=);
  end
end

# Instruction: leiu
#
# Push 1 to the main stack if the unsigned integer at the under top is
# less or equal that the unsigned integer at the top.  Otherwise push
# 0.
#
# Stack: ( UINT UINT -- UINT UINT INT )

instruction leiu () # ( UINT UINT -- UINT UINT INT )
  code
     PVM_BOOL_BINOP (UINT, <=);
  end
end

# Instruction: lel
#
# Push 1 to the main stack if the long at the under top is
# less or equal that the long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction lel () # ( LONG LONG -- LONG LONG INT )
  code
     PVM_BOOL_BINOP (LONG, <=);
  end
end

# Instruction: lelu
#
# Push 1 to the main stack if the unsigned long at the under top is
# less or equal that the unsigned long at the top.  Otherwise push 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction lelu ()
  code
     PVM_BOOL_BINOP (ULONG, <=);
  end
end

# Instruction: gti
#
# Push 1 to the main stack if the integer at the under top is
# greater than the integer at the top.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction gti ()
  code
     PVM_BOOL_BINOP (INT, >);
  end
end

# Instruction: gtiu
#
# Push 1 to the main stack if the unsigned integer at the under top is
# greater than the unsigned integer at the top.  Otherwise push 0.
#
# Stack: ( UINT UINT -- UINT UINT INT )

instruction gtiu ()
  code
     PVM_BOOL_BINOP (UINT, >);
  end
end

# Instruction: gtl
#
# Push 1 to the main stack if the long at the under top is greater
# than the long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction gtl ()
  code
     PVM_BOOL_BINOP (LONG, >);
  end
end

# Instruction: gtlu
#
# Push 1 to the main stack if the unsigned long at the under top is
# greater than the unsigned long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction gtlu ()
  code
     PVM_BOOL_BINOP (ULONG, >);
  end
end

# Instruction: gei
#
# Push 1 to the main stack if the integer at the under top is greater
# or equal than the integer at the top.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction gei ()
  code
     PVM_BOOL_BINOP (INT, >=);
  end
end

# Instruction: geiu
#
# Push 1 to the main stack if the unsigned integer at the under top is
# greater or equal than the unsigned integer at the top.  Otherwise
# push 0.
#
# Stack: ( UINT UINT -- UINT UINT INT )

instruction geiu ()
  code
     PVM_BOOL_BINOP (UINT, >=);
  end
end

# Instruction: gel
#
# Push 1 to the main stack if the long at the under top is greater
# or equal than the long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction gel ()
  code
     PVM_BOOL_BINOP (LONG, >=);
  end
end

# Instruction: gelu
#
# Push 1 to the main stack if the unsigned long at the under top is
# greater or equal than the unsigned long at the top.  Otherwise push
# 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction gelu ()
  code
     PVM_BOOL_BINOP (ULONG, >=);
  end
end

# Instruction: lts
#
# Push 1 to the main stack if the string at the under top is less than
# the string at the top, in lexicographic order.  Otherwise push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction lts ()
  code
    pvm_val res = pvm_make_int (strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())) < 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: gts
#
# Push 1 to the main stack if the string at the under top is greater than
# the string at the top, in lexicographic order.  Otherwise push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction gts ()
  code
    pvm_val res = pvm_make_int (strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())) > 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: ges
#
# Push 1 to the main stack if the string at the under top is greater
# or equal than the string at the top, in lexicographic order.
# Otherwise push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction ges ()
  code
    pvm_val res = pvm_make_int (strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())) >= 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: les
#
# Push 1 to the main stack if the string at the under top is less or
# equal than the string at the top, in lexicographic order.  Otherwise
# push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction les ()
  code
    pvm_val res = pvm_make_int (strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())) <= 0, 32);
    JITTER_PUSH_STACK (res);
  end
end


## Concatenation instructions.

# Instruction: sconc
#
# Push the concatenation of the two strings at the top of the main
# stack.
#
# Stack: ( STR STR -- STR STR STR )

instruction sconc ()
  code
     pvm_val res;
     char *sa = PVM_VAL_STR (JITTER_UNDER_TOP_STACK ());
     char *sb = PVM_VAL_STR (JITTER_TOP_STACK ());
     char *s = pvm_alloc (strlen (sa) + strlen (sb) + 1);
     strcpy (s, sa);
     strcat (s, sb);
     res = pvm_make_string (s);

     JITTER_PUSH_STACK (res);
#undef F
  end
end


## Logical instructions

# Instruction: and
#
# Push the logical and of the two elements at the top of the main
# stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction and ()
  code
    PVM_BOOL_BINOP (INT, &&);
  end
end

# Instruction: or
#
# Push the logical or of the two elements at the top of the main
# stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction or ()
  code
    PVM_BOOL_BINOP (INT, ||);
  end
end

# Instruction: not
#
# Push the logical not of the element at the top of the main stack.
#
# Stack: ( INT -- INT INT )

instruction not ()
  code
    pvm_val res = pvm_make_int (! PVM_VAL_INT (JITTER_TOP_STACK ()), 32);
    JITTER_PUSH_STACK (res);
  end
end


## Bitwise instructions

# Instruction: bxori
#
# Push the bitwise exclusive or of the two integers at the top of the
# main stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction bxori ()
  code
    PVM_BINOP (INT, INT, INT, int, ^);
  end
end

# Instruction: bxoriu
#
# Push the bitwise exclusive or of the two unsigned integers at the
# top of the main stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction bxoriu ()
  code
    PVM_BINOP (UINT, UINT, UINT, uint, ^);
  end
end

# Instruction: bxorl
#
# Push the bitwise exclusive or of the two longs at the top of the
# main stack.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction bxorl ()
  code
    PVM_BINOP (LONG, LONG, LONG, long, ^);
  end
end

# Instruction: bxorlu
#
# Push the bitwise exclusive or of the two unsigned longs at the top
# of the main stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction bxorlu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, ulong, ^);
  end
end

# Instruction: bori
#
# Push the bitwise or of the two integers at the top of the main
# stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction bori ()
  code
    PVM_BINOP (INT, INT, INT, int, |);
  end
end

# Instruction: boriu
#
# Push the bitwise or of the two unsigned integers at the top of the
# main stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction boriu ()
  code
    PVM_BINOP (UINT, UINT, UINT, uint, |);
  end
end

# Instruction: borl
#
# Push the bitwise or of the two longs at the top of the main stack.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction borl ()
  code
    PVM_BINOP (LONG, LONG, LONG, long, |);
  end
end

# Instruction: borlu
#
# Push the bitwise or of the two longs at the top of the main stack.
#
# Stack: ( ULONG ULONG  -- ULONG ULONG ULONG )

instruction borlu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, ulong, |);
  end
end

# Instruction: bandi
#
# Push the bitwise and of the two integers at the top of the main
# stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction bandi ()
  code
    PVM_BINOP (INT, INT, INT, int, &);
  end
end

# Instruction: bandiu
#
# Push the bitwise and of the two unsigned integers at the top of the
# main stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction bandiu ()
  code
    PVM_BINOP (UINT, UINT, UINT, uint, &);
  end
end

# Instruction: bandl
#
# Push the bitwise and of the two longs at the top of the main
# stack.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction bandl ()
  code
    PVM_BINOP (LONG, LONG, LONG, long, &);
  end
end

# Instruction: bandlu
#
# Push the bitwise and of the two unsigned longs at the top of the
# main stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction bandlu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, ulong, &);
  end
end

# Instruction: bnoti
#
# Push the bitwise not of the integer at the top of the main stack.
#
# Stack: ( INT -- INT INT INT )

instruction bnoti ()
  code
    PVM_UNOP (INT, INT, int, ~);
  end
end

# Instruction: bnotiu
#
# Push the bitwise not of the unsigned integer at the top of the main
# stack.
#
# Stack: ( UINT -- UINT UINT )

instruction bnotiu ()
  code
    PVM_UNOP (UINT, UINT, uint, ~);
  end
end

# Instruction: bnotl
#
# Push the bitwise not of the long at the top of the main stack.
#
# Stack: ( LONG -- LONG LONG )

instruction bnotl () # ( LONG -- LONG LONG )
  code
    PVM_UNOP (LONG, LONG, long, ~);
  end
end

# Instruction: bnotlu
#
# Push the bitwise not of the unsigned long at the top of the main
# stack.
#
# Stack: ( ULONG -- ULONG ULONG )

instruction bnotlu ()
  code
    PVM_UNOP (ULONG, ULONG, ulong, ~);
  end
end


## Shift instructions

# Instruction: bsli
#
# Left-shift the integer at the under top of the main stack the number
# of bits indicated by the unsigned int at the top of the stack.
#
# If the bit count is equal or bigger than the size of the left
# operand, then raise PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( INT UINT -- INT UINT INT )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction bsli () # ( INT UINT -- INT UINT INT )
  code
    PVM_BINOP_SL (INT, UINT, INT, int, <<);
  end
end

# Instruction: bsliu
#
# Left-shift the unsigned integer at the under top of the main stack
# the number of bits indicated by the unsigned int at the top of the
# stack.
#
# If the bit count is equal or bigger than the size of the left
# operand, then raise PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( UINT UINT -- UINT UINT UINT )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction bsliu () # ( UINT UINT -- UINT UINT UINT )
  code
    PVM_BINOP_SL (UINT, UINT, UINT, uint, <<);
  end
end

# Instruction: bsll
#
# Left-shift the long at the under top of the main stack the number
# of bits indicated by the unsigned int at the top of the stack.
#
# If the bit count is equal or bigger than the size of the left
# operand, then raise PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( LONG UINT -- LONG UINT LONG )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction bsll () # ( LONG UINT -- LONG UINT LONG )
  code
    PVM_BINOP_SL (LONG, UINT, LONG, long, <<);
  end
end

# Instruction: bslu
#
# Left-shift the unsigned long at the under top of the main stack the
# number of bits indicated by the unsigned int at the top of the
# stack.
#
# If the bit count is equal or bigger than the size of the left
# operand, then raise PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( ULONG UINT -- ULONG UINT ULONG )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction bsllu () # ( ULONG UINT -- ULONG UINT ULONG )
  code
    PVM_BINOP_SL (ULONG, UINT, ULONG, ulong, <<);
  end
end

instruction bsri () # ( INT UINT -- INT UINT INT )
  code
    PVM_BINOP (INT, UINT, INT, int, >>);
  end
end

instruction bsriu () # ( UINT UINT -- UINT UINT UINT )
  code
    PVM_BINOP (UINT, UINT, UINT, uint, >>);
  end
end

instruction bsrl () # ( LONG UINT -- LONG UINT LONG )
  code
    PVM_BINOP (LONG, UINT, LONG, long, >>);
  end
end

instruction bsrlu () # ( ULONG UINT -- ULONG UINT ULONG )
  code
    PVM_BINOP (ULONG, UINT, ULONG, ulong, >>);
  end
end


## Compare-and-swap instructions.

instruction swapgti () # ( INT INT - INT INT )
  code
     pvm_val a = JITTER_UNDER_TOP_STACK ();
     pvm_val b = JITTER_TOP_STACK ();
     if (PVM_VAL_INT (a) > PVM_VAL_INT (b))
     {
       JITTER_UNDER_TOP_STACK () = b;
       JITTER_TOP_STACK () = a;
     }
  end
end

instruction swapgtiu () # ( UINT UINT - UINT UINT )
  code
     pvm_val a = JITTER_UNDER_TOP_STACK ();
     pvm_val b = JITTER_TOP_STACK ();
     if (PVM_VAL_UINT (a) > PVM_VAL_UINT (b))
     {
       JITTER_UNDER_TOP_STACK () = b;
       JITTER_TOP_STACK () = a;
     }
  end
end
instruction swapgtl () # ( LONG LONG - LONG LONG )
  code
     pvm_val a = JITTER_UNDER_TOP_STACK ();
     pvm_val b = JITTER_TOP_STACK ();
     if (PVM_VAL_LONG (a) > PVM_VAL_LONG (b))
     {
       JITTER_UNDER_TOP_STACK () = b;
       JITTER_TOP_STACK () = a;
     }
  end
end

instruction swapgtlu () # ( ULONG ULONG - ULONG ULONG )
  code
     pvm_val a = JITTER_UNDER_TOP_STACK ();
     pvm_val b = JITTER_TOP_STACK ();
     if (PVM_VAL_ULONG (a) > PVM_VAL_ULONG (b))
     {
       JITTER_UNDER_TOP_STACK () = b;
       JITTER_TOP_STACK () = a;
     }
  end
end



## Branches

instruction ba (?f) # Branch always.
  code
    JITTER_BRANCH_FAST(JITTER_ARGF0);
  end
end

instruction bn (?f) # Branch if null
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (tmp != PVM_NULL, JITTER_ARGF0);
  end
end

instruction bnn (?f) # Branch if not null
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (tmp == PVM_NULL, JITTER_ARGF0);
  end
end

instruction bzi (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_INT (tmp), JITTER_ARGF0);
  end
end

instruction bziu (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_UINT (tmp), JITTER_ARGF0);
  end
end

instruction bzl (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_LONG (tmp), JITTER_ARGF0);
  end
end

instruction bzlu (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_ULONG (tmp), JITTER_ARGF0);
  end
end

instruction bnzi (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_INT (tmp), JITTER_ARGF0);
  end
end

instruction bnziu (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_UINT (tmp), JITTER_ARGF0);
  end
end

instruction bnzl (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_LONG (tmp), JITTER_ARGF0);
  end
end

instruction bnzlu (?f)
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_ULONG (tmp), JITTER_ARGF0);
  end
end



## Conversion instructions.

instruction ctos () # ( UINT8 - UINT8 STR )
  code
    uint8_t c = PVM_VAL_UINT (JITTER_TOP_STACK ());
    char *str = pvm_alloc (2);
    str[0] = c;
    str[1] = '\0';

    JITTER_PUSH_STACK (pvm_make_string (str));
  end
end

instruction itoi (?n pvm_literal_printer_cast) # ( INT -- INT INT )
  code
    PVM_CONVOP (INT, int32_t, int, int32_t);
  end
end

instruction itoiu (?n pvm_literal_printer_cast) # ( INT -- INT UINT )
  code
    PVM_CONVOP (INT, int32_t, uint, uint32_t);
  end
end

instruction itol (?n pvm_literal_printer_cast) # ( INT -- INT LONG )
  code
    PVM_CONVOP (INT, int32_t, long, int64_t);
  end
end

instruction itolu (?n pvm_literal_printer_cast) # ( INT -- INT ULONG )
  code
    PVM_CONVOP (INT, int32_t, ulong, uint64_t);
  end
end

instruction iutoi (?n pvm_literal_printer_cast) # ( UINT -- UINT INT )
  code
    PVM_CONVOP (UINT, uint32_t, int, int32_t);
  end
end

instruction iutoiu (?n pvm_literal_printer_cast) # ( UINT -- UINT UINT )
  code
    PVM_CONVOP (UINT, uint32_t, uint, uint32_t);
  end
end

instruction iutol (?n pvm_literal_printer_cast) # ( UINT -- UINT LONG )
  code
    PVM_CONVOP (UINT, uint32_t, long, int64_t);
  end
end

instruction iutolu (?n pvm_literal_printer_cast) # ( UINT -- UINT ULONG )
  code
    PVM_CONVOP (UINT, uint32_t, ulong, uint64_t);
  end
end

instruction ltoi (?n pvm_literal_printer_cast) # ( LONG -- LONG INT )
  code
    PVM_CONVOP (LONG, int64_t, int, int32_t);
  end
end

instruction ltoiu (?n pvm_literal_printer_cast) # ( LONG -- LONG UINT )
  code
    PVM_CONVOP (LONG, int64_t, uint, uint32_t);
  end
end

instruction ltol (?n pvm_literal_printer_cast) # ( LONG -- LONG LONG )
  code
    PVM_CONVOP (LONG, int64_t, long, int64_t);
  end
end

instruction ltolu (?n pvm_literal_printer_cast) # ( LONG -- LONG ULONG )
  code
    PVM_CONVOP (LONG, int64_t, ulong, uint64_t);
  end
end

instruction lutoi (?n pvm_literal_printer_cast) # ( ULONG -- ULONG INT )
  code
    PVM_CONVOP (ULONG, uint64_t, int, int32_t);
  end
end

instruction lutoiu (?n pvm_literal_printer_cast) # ( ULONG -- ULONG UINT )
  code
    PVM_CONVOP (ULONG, uint64_t, uint, uint32_t);
  end
end

instruction lutol (?n pvm_literal_printer_cast) # ( ULONG -- ULONG LONG )
  code
    PVM_CONVOP (ULONG, uint64_t, long, int64_t);
  end
end

instruction lutolu (?n pvm_literal_printer_cast) # ( ULONG -- ULONG ULONG )
  code
    PVM_CONVOP (ULONG, uint64_t, ulong, uint64_t);
  end
end



## String instructions

instruction strref () # ( STR ULONG -- STR ULONG VAL )
  code
     pvm_val string = JITTER_UNDER_TOP_STACK ();
     pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            strlen (PVM_VAL_STR (string))))
      PVM_RAISE (PVM_E_OUT_OF_BOUNDS, PVM_E_OUT_OF_BOUNDS_MSG);

    JITTER_PUSH_STACK (pvm_make_uint (PVM_VAL_STR (string)[PVM_VAL_ULONG (index)],
                                      8));
  end
end

instruction substr () # ( STR ULONG ULONG -- STR ULONG ULONG STR )
  code
    pvm_val str;
    char *s;
    pvm_val to = JITTER_TOP_STACK ();
    pvm_val from = JITTER_UNDER_TOP_STACK ();
    size_t slen = PVM_VAL_ULONG (to) - PVM_VAL_ULONG (from) + 1;

    JITTER_DROP_STACK ();
    str = JITTER_UNDER_TOP_STACK ();
    JITTER_PUSH_STACK (to);

    if (PVM_VAL_ULONG (from) >= strlen (PVM_VAL_STR (str))
        || PVM_VAL_ULONG (to) >= strlen (PVM_VAL_STR (str))
        || PVM_VAL_ULONG (from) > PVM_VAL_ULONG (to))
        PVM_RAISE (PVM_E_OUT_OF_BOUNDS, PVM_E_OUT_OF_BOUNDS_MSG);

    s = pvm_alloc (slen + 1); /* XX XGC */
    strncpy (s,
             PVM_VAL_STR (str) + PVM_VAL_ULONG (from),
             slen);
    s[slen] = '\0';

    JITTER_PUSH_STACK (pvm_make_string (s));
  end
end

# Instruction: muls
#
# Given a string and an unsigned long in the stack, push a new
# string value whose value is the concatenation of the argument
# string applied to itself as many times as the unsigned long.  If
# the second argument to muls is 0 then the result of the operation
# is the empty string.
#
# Stack: ( STR ULONG -- STR ULONG STR )

instruction muls ()
  code
    pvm_val str = JITTER_UNDER_TOP_STACK ();
    size_t i, num = PVM_VAL_ULONG (JITTER_TOP_STACK ());
    char *res = xmalloc (strlen (PVM_VAL_STR (str)) * num + 1);

    *res = '\0';
    for (i = 0; i < num; ++i)
      strcat (res, PVM_VAL_STR (str));

    JITTER_PUSH_STACK (pvm_make_string (res));
    free (res);
  end
end


## Array instructions.

# ( BOFF TYP [BOFF IDX VAL]... ULONG(nelem) ULONG(ninitializer) -- ARR )
instruction mka ()
  code
    size_t i;
    pvm_val nelem, ninitializer, arr, elem;

    ninitializer = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    arr = pvm_make_array (nelem, PVM_NULL /* type */);
    for (i = 0; i < PVM_VAL_ULONG (ninitializer); ++i)
    {
      size_t index
        = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());

      PVM_VAL_ARR_ELEM_VALUE (arr, index) = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();

      PVM_VAL_ARR_ELEM_OFFSET (arr, index) = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
    }

    /* Fill-in non-initialized elements in the array.  */
    if (PVM_VAL_ULONG (nelem) != PVM_VAL_ULONG (ninitializer))
    {
       for (i = PVM_VAL_ULONG (nelem), elem = PVM_NULL;
            i > 0;
            --i)
       {
         pvm_val elem_value = PVM_VAL_ARR_ELEM_VALUE (arr, i - 1);

         if (elem_value == PVM_NULL)
           PVM_VAL_ARR_ELEM_VALUE (arr, i - 1) = elem;
         else
           elem = elem_value;
       }
    }

    PVM_VAL_ARR_TYPE (arr) = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    PVM_VAL_ARR_OFFSET (arr) = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    JITTER_PUSH_STACK (arr);
  end
end

# Executing this instruction can result in the following exceptions:
#   PVM_E_CONV

instruction aset () # ( ARR ULONG VAL -- ARR )
  code
    uint64_t idx;
    pvm_val val;
    pvm_val arr;
    pvm_val array_type, bound;

    val= JITTER_TOP_STACK ();
    idx = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();

    arr = JITTER_TOP_STACK ();

    if (idx < 0 || idx >= PVM_VAL_INTEGRAL (PVM_VAL_ARR_NELEM (arr)))
      PVM_RAISE (PVM_E_OUT_OF_BOUNDS, PVM_E_OUT_OF_BOUNDS_MSG);

    /* If the array is bounded by size, check whether the new value
       results in a different size.  */

    array_type = PVM_VAL_ARR_TYPE (arr);
    bound = PVM_VAL_TYP_A_BOUND (array_type);

    if (PVM_IS_OFF (bound))
      {
        pvm_val oval = PVM_VAL_ARR_ELEM_VALUE (arr, idx);
        uint64_t old_size_bits;
        uint64_t new_size_bits;

        PVM_VAL_ARR_ELEM_VALUE (arr, idx) = val;

        old_size_bits = (PVM_VAL_INTEGRAL (PVM_VAL_OFF_MAGNITUDE (bound))
                         * PVM_VAL_INTEGRAL (PVM_VAL_OFF_UNIT (bound)));
        new_size_bits = pvm_sizeof (arr);

        if (new_size_bits != old_size_bits)
         {
           PVM_VAL_ARR_ELEM_VALUE (arr, idx) = oval;
           PVM_RAISE (PVM_E_CONV, PVM_E_CONV_MSG);
         }
      }
   else
     PVM_VAL_ARR_ELEM_VALUE (arr, idx) = val;
  end
end

instruction aseto () # ( ARR ULONG BOFF -- ARR )
  code
    uint64_t idx;
    pvm_val boff;
    pvm_val arr;

    boff = JITTER_TOP_STACK ();
    idx = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    arr = JITTER_TOP_STACK ();

    if (idx < 0 || idx >= PVM_VAL_INTEGRAL (PVM_VAL_ARR_NELEM (arr)))
      PVM_RAISE (PVM_E_OUT_OF_BOUNDS, PVM_E_OUT_OF_BOUNDS_MSG);

    PVM_VAL_ARR_ELEM_OFFSET (arr, idx) = boff;
  end
end

instruction aref () # ( ARR ULONG -- ARR ULONG VAL )
  code
    pvm_val array = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_ARR_NELEM (array))))
      PVM_RAISE (PVM_E_OUT_OF_BOUNDS, PVM_E_OUT_OF_BOUNDS_MSG);

    JITTER_PUSH_STACK (PVM_VAL_ARR_ELEM_VALUE (array,
                                               PVM_VAL_ULONG (index)));
  end
end

instruction arefo () # ( ARR ULONG -- ARR ULONG OFF )
  code
    pvm_val array = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_ARR_NELEM (array))))
      PVM_RAISE (PVM_E_OUT_OF_BOUNDS, PVM_E_OUT_OF_BOUNDS_MSG);

    JITTER_PUSH_STACK (PVM_VAL_ARR_ELEM_OFFSET (array,
                                                PVM_VAL_ULONG (index)));
  end
end

# Array set type boundary
instruction asettb () # ( ARR BOUND -- ARR )
  code
    pvm_val type = PVM_VAL_ARR_TYPE (JITTER_UNDER_TOP_STACK ());

    PVM_VAL_TYP_A_BOUND (type) = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
  end
end



## Struct instructions.

#          fields         methods  nmethods nfields
# ( OFF [OFF STR VAL]... [STR VAL]... ULONG ULONG TYP -- SCT )
instruction mksct ()
  code
    size_t e;
    pvm_val nfields, nmethods, sct, type;

    type = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nfields = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nmethods = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    sct = pvm_make_struct (nfields, nmethods, type);

    for (e = 0; e < PVM_VAL_ULONG (nmethods); ++e)
    {
      PVM_VAL_SCT_METHOD_VALUE (sct, PVM_VAL_ULONG (nmethods) - e - 1)
         = JITTER_TOP_STACK ();
      PVM_VAL_SCT_METHOD_NAME (sct, PVM_VAL_ULONG (nmethods) - e - 1)
         = JITTER_UNDER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    for (e = 0; e < PVM_VAL_ULONG (nfields); ++e)
    {
      PVM_VAL_SCT_FIELD_VALUE (sct, PVM_VAL_ULONG (nfields) - e - 1)
          = JITTER_TOP_STACK ();
      PVM_VAL_SCT_FIELD_NAME (sct, PVM_VAL_ULONG (nfields) - e - 1)
          = JITTER_UNDER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();

      PVM_VAL_SCT_FIELD_OFFSET (sct, PVM_VAL_ULONG (nfields) - e -1)
          = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
    }

    PVM_VAL_SCT_OFFSET (sct) = JITTER_TOP_STACK();
    JITTER_DROP_STACK ();

    JITTER_PUSH_STACK (sct);
  end
end

instruction sset () # ( SCT STR VAL -- SCT )
  code
    pvm_val val = JITTER_TOP_STACK ();
    pvm_val name = JITTER_UNDER_TOP_STACK ();
    pvm_val sct;

    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();

    sct = JITTER_TOP_STACK ();
    if (!pvm_set_struct (sct, name, val))
       PVM_RAISE (PVM_E_ELEM, PVM_E_ELEM_MSG);
  end
end

instruction sref () # ( SCT STR -- SCT STR VAL )
  code
    pvm_val val = pvm_ref_struct (JITTER_UNDER_TOP_STACK (),
                                  JITTER_TOP_STACK ());

    if (val == PVM_NULL)
      PVM_RAISE (PVM_E_ELEM, PVM_E_ELEM_MSG);
    JITTER_PUSH_STACK (val);
  end
end

instruction srefi () # ( SCT ULONG -- SCT ULONG VAL )
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_SCT_NFIELDS (sct))))
      PVM_RAISE (PVM_E_OUT_OF_BOUNDS, PVM_E_OUT_OF_BOUNDS_MSG);

    JITTER_PUSH_STACK (PVM_VAL_SCT_FIELD_VALUE (sct,
                                               PVM_VAL_ULONG (index)));
  end
end

instruction srefio () # ( SCT ULONG -- SCT ULONG OFF )
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_SCT_NFIELDS (sct))))
      PVM_RAISE (PVM_E_OUT_OF_BOUNDS, PVM_E_OUT_OF_BOUNDS_MSG);

    JITTER_PUSH_STACK (PVM_VAL_SCT_FIELD_OFFSET (sct,
                                                 PVM_VAL_ULONG (index)));
  end
end

instruction smodi () # ( SCT ULONG -- BOOL )
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    JITTER_PUSH_STACK (PVM_VAL_SCT_FIELD_MODIFIED (sct,
                                                   PVM_VAL_ULONG (index)));
  end
end



## Offset instructions.

instruction mko () # ( EXP ULONG -- OFF )
  code
   pvm_val res = pvm_make_offset (JITTER_UNDER_TOP_STACK (),
                                  JITTER_TOP_STACK ());
   JITTER_DROP_STACK ();
   JITTER_TOP_STACK () = res;
  end
end

instruction ogetm () # ( OFF -- OFF (INT|LONG|UINT|ULONG) )
  code
   JITTER_PUSH_STACK (PVM_VAL_OFF_MAGNITUDE (JITTER_TOP_STACK ()));
  end
end

instruction osetm () # ( OFF (INT|LONG|UINT|ULONG) -- OFF )
  code
   PVM_VAL_OFF_MAGNITUDE (JITTER_UNDER_TOP_STACK ())
    =  JITTER_TOP_STACK ();
   JITTER_DROP_STACK ();
  end
end

instruction ogetu () # ( OFF -- OFF ULONG )
  code
    JITTER_PUSH_STACK (PVM_VAL_OFF_UNIT (JITTER_TOP_STACK ()));
  end
end

instruction ogetbt () # ( OFF -- OFF BT )
  code
    JITTER_PUSH_STACK (PVM_VAL_OFF_BASE_TYPE (JITTER_TOP_STACK ()));
  end
end



## Instructions to handle mapped values.

instruction mgeto () # ( VAL -- VAL OFF )
  code
    JITTER_PUSH_STACK (PVM_VAL_OFFSET (JITTER_TOP_STACK ()));
  end
end

instruction mseto () # ( VAL OFF -- VAL )
  code
    PVM_VAL_SET_OFFSET (JITTER_UNDER_TOP_STACK (),
                        JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

instruction mgetios () # ( VAL -- VAL INT )
  code
    JITTER_PUSH_STACK (PVM_VAL_IOS (JITTER_TOP_STACK ()));
  end
end

instruction msetios () # ( VAL INT -- VAL )
  code
    PVM_VAL_SET_IOS (JITTER_UNDER_TOP_STACK (),
                     JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

instruction mgetm () # ( VAL -- VAL CLS )
  code
     JITTER_PUSH_STACK (PVM_VAL_MAPPER (JITTER_TOP_STACK ()));
  end
end

instruction msetm () #  ( VAL CLS -- VAL )
  code
    PVM_VAL_SET_MAPPER (JITTER_UNDER_TOP_STACK (), JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

instruction mgetw () #  ( VAL -- VAL CLS )
  code
     JITTER_PUSH_STACK (PVM_VAL_WRITER (JITTER_TOP_STACK ()));
  end
end

instruction msetw () #  ( VAL CLS -- VAL )
  code
    PVM_VAL_SET_WRITER (JITTER_UNDER_TOP_STACK (), JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# mgetsel
#
# Given a value in the TOS, push the number of elements to which a
# given mapped value is bounded to.  If the value is not mapped, or if
# it is not bounded by number of elements, push PVM_NULL.

instruction mgetsel () # ( VAL -- VAL ULONG )
  code
    JITTER_PUSH_STACK (PVM_VAL_ELEMS_BOUND (JITTER_TOP_STACK ()));
  end
end

instruction msetsel () # ( VAL ULONG -- VAL )
  code
    PVM_VAL_SET_ELEMS_BOUND (JITTER_UNDER_TOP_STACK (), JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

instruction mgetsiz () # ( VAL -- VAL OFF )
  code
    JITTER_PUSH_STACK (PVM_VAL_SIZE_BOUND (JITTER_TOP_STACK ()));
  end
end

instruction msetsiz () # ( VAL OFF -- VAL )
  code
    PVM_VAL_SET_SIZE_BOUND (JITTER_UNDER_TOP_STACK (), JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end


## Type related instructions

instruction isa () # ( VAL TYPE -- TYPE VAL BOOL )
  code
    pvm_val type = JITTER_TOP_STACK ();
    pvm_val val = JITTER_UNDER_TOP_STACK ();
    pvm_val val_type = pvm_typeof (val);

    JITTER_PUSH_STACK (pvm_make_int (pvm_type_equal (type, val_type),
                                     32));
  end
end

instruction typof () # ( VAL -- VAL TYP )
  code
    JITTER_PUSH_STACK (pvm_typeof (JITTER_TOP_STACK ()));
  end
end

instruction tyisc () # ( VAL -- VAL BOOL )
  code
    JITTER_PUSH_STACK (pvm_make_int (PVM_IS_CLS (JITTER_TOP_STACK ()), 32));
  end
end

instruction tyissct () # ( VAL -- VAL BOOL )
  code
    JITTER_PUSH_STACK (pvm_make_int (PVM_IS_SCT (JITTER_TOP_STACK ()), 32));
  end
end

# `Any' type.

instruction mktyany () # ( -- TYP )
  code
    JITTER_PUSH_STACK (pvm_make_any_type ());
  end
end

# Integral types

instruction mktyi () # ( ULONG UINT -- TYP )
  code
    pvm_val size = JITTER_UNDER_TOP_STACK ();
    pvm_val signed_p = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    JITTER_TOP_STACK () = pvm_make_integral_type (size, signed_p);
  end
end

# String types

instruction mktys () # ( -- TYP )
  code
    JITTER_PUSH_STACK (pvm_make_string_type ());
  end
end

# Offset types

instruction mktyo () # ( TYP INT -- TYP )
  code
#define F(res, a, b) \
  { res = pvm_make_offset_type (a, b); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Array types

instruction mktya () # ( TYP BOUND -- TYP )
  code
     pvm_val bound = JITTER_TOP_STACK ();
     pvm_val etype = JITTER_UNDER_TOP_STACK ();

     JITTER_DROP_STACK ();
     JITTER_TOP_STACK () = pvm_make_array_type (etype, bound);
  end
end

instruction tyagett () # ( TYP -- TYP TYP )
  code
    JITTER_PUSH_STACK (PVM_VAL_TYP_A_ETYPE (JITTER_TOP_STACK ()));
  end
end

instruction tyagetb () # ( TYP - TYP BOUND )
  code
    JITTER_PUSH_STACK (PVM_VAL_TYP_A_BOUND (JITTER_TOP_STACK ()));
  end
end

# Function types

instruction mktyc () # ( ATYPE... RTYPE NARGS -- TYP )
  code
    size_t i;
    pvm_val nargs, rtype, *atypes;

    nargs = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    rtype = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    pvm_allocate_closure_attrs (nargs, &atypes);

    for (i = 0; i < PVM_VAL_ULONG (nargs); ++i)
    {
      atypes[i] = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (pvm_make_closure_type (rtype,
                                              nargs, atypes));
  end
end

# Struct types

instruction mktysct () # ( [STRING TYP]... NLONG NAME -- TYP )
  code
    size_t i;
    pvm_val nelem, name, *etypes, *enames;

    name = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    pvm_allocate_struct_attrs (nelem, &etypes, &enames);

    for (i = 0; i < PVM_VAL_ULONG (nelem); ++i)
    {
      enames[PVM_VAL_ULONG (nelem) - i - 1] = JITTER_UNDER_TOP_STACK ();
      etypes[PVM_VAL_ULONG (nelem) - i - 1] = JITTER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (pvm_make_struct_type (nelem, name,
                                             enames, etypes));
  end
end



## IO instructions
#
#
# The following instructions operate on the global IO space.

# write
#
# If the value at the TOS is mapped, then write it to IO.
# Otherwise, this is a NOP.
#
# Executing this instruction can result in the following exceptions:
#   PVM_E_IOS_FULL
#   PVM_E_CONSTRAINT_ERROR

instruction write () # ( VAL -- VAL )
  caller
  code
     pvm_val val = JITTER_TOP_STACK ();
     pvm_val writer = pvm_val_writer (val);

     if (writer != PVM_NULL)
     {
        JITTER_DUP_STACK ();                      /* VAL VAL */
        JITTER_PUSH_STACK (PVM_VAL_OFFSET (val)); /* VAL VAL OFF */
        PVM_CALL (writer);
      }
  end
end

# peeki NENC,ENDIAN,BITS
# ( IOS BOFF -- INT )

instruction peeki (?n nenc_printer,?n endian_printer,?n bits_printer)
  code
    PVM_PEEK (int, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_INT);
  end
end

# peekiu ENDIAN,BITS
# ( IOS BOFF -- UINT )

instruction peekiu (?n endian_printer,?n bits_printer)
  code
   PVM_PEEK (uint, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_UINT);
  end
end

# peekl NENC,ENDIAN,BITS
# ( IOS BOFF -- LONG )

instruction peekl (?n nenc_printer,?n endian_printer,?n bits_printer)
  code
    PVM_PEEK (long, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_INT);
  end
end

# peeklu ENDIAN,BITS
# ( IOS BOFF -- ULONG )

instruction peeklu (?n endian_printer,?n bits_printer)
  code
   PVM_PEEK (ulong, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_UINT);
  end
end

# peekdi BITS
# ( IOS BOFF -- INT )

instruction peekdi (?n bits_printer)
  code
    PVM_PEEK (int, int, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_INT);
  end
end

# peekdiu BITS
# ( IOS BOFF -- UINT )

instruction peekdiu (?n bits_printer)
  code
    PVM_PEEK (uint, uint, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_UINT);
  end
end

# peekdl BITS
# ( IOS BOFF -- LONG )

instruction peekdl (?n bits_printer)
  code
    PVM_PEEK (long, int, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_INT);
  end
end

# peekdlu BITS
# ( IOS BOFF -- ULONG )

instruction peekdlu (?n bits_printer)
  code
    PVM_PEEK (ulong, uint, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_UINT);
  end
end

# pokei NENC,ENDIAN,BITS
# ( IOS BOFF INT -- )

instruction pokei (?n nenc_printer,?n endian_printer,?n bits_printer)
  code
    PVM_POKE (INT, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_WRITE_INT);
  end
end

# pokeiu ENDIAN,BITS
# ( IOS BOFF UINT -- )

instruction pokeiu (?n endian_printer,?n bits_printer)
  code
   PVM_POKE (UINT, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_WRITE_UINT);
  end
end

# pokel NENC,ENDIAN,BITS
# ( IOS BOFF LONG -- )

instruction pokel (?n nenc_printer,?n endian_printer,?n bits_printer)
  code
    PVM_POKE (LONG, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_WRITE_INT);
  end
end

# pokelu ENDIAN,BITS
# ( IOS BOFF ULONG -- )

instruction pokelu (?n endian_printer,?n bits_printer)
  code
   PVM_POKE (ULONG, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_WRITE_UINT);
  end
end

# pokedi BITS
# ( IOS BOFF INT -- )

instruction pokedi (?n bits_printer)
  code
    PVM_POKE (INT, int, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_INT);
  end
end

# pokediu BITS
# ( IOS BOFF UINT -- )

instruction pokediu (?n bits_printer)
  code
    PVM_POKE (UINT, uint, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_UINT);
  end
end

# pokedl BITS
# ( IOS BOFF LONG -- )

instruction pokedl (?n bits_printer)
  code
    PVM_POKE (LONG, int, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_INT);
  end
end

# pokedlu BITS
# ( IOS BOFF ULONG -- )

instruction pokedlu (?n bits_printer)
  code
    PVM_POKE (ULONG, uint, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_UINT);
  end
end

# peeks
# ( IOS BOFF -- STR )

instruction peeks ()
  code
    ios io;
    ios_off offset;
    char *ios_str;
    int ret;

    offset = PVM_VAL_ULONG (JITTER_TOP_STACK ());
    io = ios_search_by_id (PVM_VAL_INT (JITTER_UNDER_TOP_STACK ()));

    if (io == NULL)
      PVM_RAISE (PVM_E_NO_IOS, PVM_E_NO_IOS_MSG);

    JITTER_DROP_STACK ();
    if ((ret = ios_read_string (io, offset, 0 /* flags */, &ios_str)) != IOS_OK)
    {
      if (ret == IOS_EIOFF)
         PVM_RAISE (PVM_E_EOF, PVM_E_EOF_MSG);
      else
         PVM_RAISE (PVM_E_IO, PVM_E_IO_MSG);
      JITTER_TOP_STACK () = PVM_NULL;
    }
    else
      JITTER_TOP_STACK () = pvm_make_string (ios_str);
  end
end

# pokes
# ( IOS BOFF STR -- )

instruction pokes ()
  code
    ios io;
    ios_off offset;
    char *str;
    int ret;

    str = PVM_VAL_STR (JITTER_TOP_STACK ());
    offset = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();

    io = ios_search_by_id (PVM_VAL_INT (JITTER_TOP_STACK ()));

    if (io == NULL)
      PVM_RAISE (PVM_E_NO_IOS, PVM_E_NO_IOS_MSG);

    JITTER_DROP_STACK ();
    if ((ret = ios_write_string (io, offset, 0 /* flags */, str)) != IOS_OK)
    {
      if (ret == IOS_EIOFF)
         PVM_RAISE (PVM_E_EOF, PVM_E_EOF_MSG);
      else
         PVM_RAISE (PVM_E_IO, PVM_E_IO_MSG);
    }
  end
end



## Exceptions handling instructions

# pushe LABEL
#
# ( EXCEPTION -- )

instruction pushe (?l)
  code
   struct pvm_exception_handler *ehandler
      = pvm_alloc (sizeof (struct pvm_exception_handler));
   pvm_val exception = JITTER_TOP_STACK ();
   pvm_val exception_code = pvm_ref_struct (exception,
                                            pvm_make_string ("code"));

   ehandler->exception = PVM_VAL_INT (exception_code);
   JITTER_DROP_STACK ();
   ehandler->main_stack_height = JITTER_HEIGHT_STACK ();
   ehandler->return_stack_height = JITTER_HEIGHT_RETURNSTACK ();
   ehandler->code = JITTER_ARGP0;
   ehandler->env = jitter_state_runtime.env;

   JITTER_PUSH_EXCEPTIONSTACK (ehandler);
  end
end

# pope
#
# ( EXCEPTION_HANDLER -- )

instruction pope ()
  code
    JITTER_DROP_EXCEPTIONSTACK ();
  end
end

# raise
#
# ( EXCEPTION -- )

instruction raise ()
  code
    pvm_val exception = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
    PVM_RAISE_DIRECT (exception);
  end
end


## Debugging Instructions

instruction strace (?n) # ( -- )
  code
     pvm_val tmp[1024];
     int i = 0, j;
     int num_elems = (int) JITTER_ARGN0;

     while (((num_elems == 0 || i < num_elems)
             && (JITTER_HEIGHT_STACK () !=
                 jitter_original_state->pvm_state_backing.canary)))
        {
          assert (i < 1024);
          pvm_print_val (JITTER_TOP_STACK (), poke_obase, PVM_PRINT_F_MAPS (1));
          pk_puts ("\n");
          tmp[i++] = JITTER_TOP_STACK ();
          JITTER_DROP_STACK ();
        }

     /* Restore the stack.  */
     for (j = (i - 1); j >= 0; j--)
        JITTER_PUSH_STACK (tmp[j]);
  end
end


## Miscellaneous Instructions

instruction nop ()
  code
  end
end

instruction note (?n pvm_literal_printer)
  code
  end
end

instruction rand () # ( -- INT )
  code
    JITTER_PUSH_STACK (pvm_make_int (random (), 32));
  end
end

instruction siz () # ( VAL -- VAL ULONG )
  code
    uint64_t size = pvm_sizeof (JITTER_TOP_STACK ());
    JITTER_PUSH_STACK (pvm_make_ulong (size, 64));
  end
end

instruction sel () # ( VAL -- VAL ULONG )
  code
    JITTER_PUSH_STACK (pvm_elemsof (JITTER_TOP_STACK ()));
  end
end

### End of instructions


## Peephole optimizations

rule swap-drop-to-nip rewrite
  swap; drop
into
  nip
end

rule rot-rot-to-nrot rewrite
  rot; rot
into
  nrot
end

rule nip-nip-to-nip2 rewrite
  nip; nip
into
  nip2
end

rule nip2-nip-to-nip3 rewrite
  nip2; nip
into
  nip3
end

rule drop-drop-to-drop2 rewrite
  drop; drop
into
  drop2
end

rule drop2-drop-to-drop3 rewrite
  drop2; drop
into
  drop3
end

rule drop3-drop-to-drop4 rewrite
  drop3; drop
into
  drop4
end

rule swap-over-to-tuck rewrite
  swap; over
into
  tuck
end

rule rot-swap-to-quake rewrite
  rot; swap
into
  quake
end
