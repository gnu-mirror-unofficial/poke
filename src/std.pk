/* std.pk - Standard definitions for poke.  */

/* Copyright (C) 2019 Jose E. Marchesi.  */

/* This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* Standard Integral Types.  */

deftype bit = uint<1>;
deftype nibble = uint<4>;

deftype uint8 = uint<8>;
deftype uint16 = uint<16>;
deftype uint32 = uint<32>;
deftype uint64 = uint<64>;

deftype int8 = int<8>;
deftype int16 = int<16>;
deftype int32 = int<32>;
deftype int64 = int<64>;

deftype uint = uint32;
deftype int = int32;
deftype char = uint8;
deftype byte = uint8;
deftype ushort = uint16;
deftype short = int16;
deftype ulong = uint64;
deftype long = int64;

/* Standard Offset Types.  */

deftype off64 = offset<int64,b>;
deftype uoff64 = offset<uint64,b>;

/* Conversion Functions.  */

defun catos = (char[] chars) string:
  {
   defvar s = "";

   for (c in chars)
     {
       if (c == '\0')
         return s;
       s = s + c as string;
     }
   return s;
  }

  /* Return S with leading whitespace omitted.  */
defun ltrim = (string s) string:
  {
    defvar result = "";
    for (c in s)
      {
	if (c == ' ' || c == '\t' || result != "")
	  result = result + c as string;
      }
    return result;
  }

  /* Return S with trailing whitespace omitted.  */
defun rtrim = (string s) string:
  {
    defvar result = "";
    defvar i = s'length;
    while (i > 0)
    {
      defvar c = s[i - 1];
      if ((c != ' ' && c != '\t') || result != "")
        result = c as string + result;
      i = i - 1;
    }
    return result;
  }

defun atoi = (string s, int b = 10) long:
  {
    defvar result = 0;

    defun htoi = (char c) int:
      {
        if (c >= '0' && c <= '9') return c - '0';
        if (c >= 'a' && c <= 'f') return c - 'a' + 10;
        if (c >= 'A' && c <= 'F') return c - 'A' + 10;
      }

    defun valid = (char c, int b) int:
      {
        if (b <= 10) return (c >= '0') && (c <= '0' + b - 1);
        if (b == 16) return ((c >= '0') && (c <= '9')) ||
         ((c >= 'a') && (c <= 'f')) || ((c >= 'A') && (c <= 'F'));
      }

    if (!(b in [2, 8, 10, 16]))
      raise E_generic;

    for (c in s)
    {
      if (!valid(c, b))
        return result;

      result = result * b + htoi(c);
    }

    return result;
  }

/* Sorting Functions.  */

deftype Comparator = (any,any)int;

defun qsort = (any[] array, Comparator cmp_f,
               long left = 0, long right = array'length - 1) void:
{
   defun partition = int:
   {
     defun swap = (long i1, long i2) void:
     {
       defvar t = array[i1];
       array[i1] = array[i2];
       array[i2] = t;
     }

     defvar pivot = array[right];
     defvar i = left - 1;

     defvar j = left;
     while (j <= right - 1)
     {
       if (cmp_f (array[j], pivot) <= 0)
       {
         i = i + 1;
         swap (i, j);
       }

       j = j + 1;
     }

     swap (i + 1, right);
     return i + 1;
   }

   if (left < right)
   {
     defvar pi = partition;

     qsort (array, cmp_f, left, pi - 1);
     qsort (array, cmp_f, pi + 1, right);
   }
}

/* Miscellanea.  */

defvar NULL = 0#B;
