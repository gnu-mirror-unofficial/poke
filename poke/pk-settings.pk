/* pk-settings.pk - Global settings.  */

/* Copyright (C) 2021 Jose E. Marchesi */

/* This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* This file implements the infrastructure for maintining a global
   database of settings in the poke application.  The .set dot-command
   operates in a generic way on the structures defined here.  */


/* The Poke_Setting type describes a poke global setting.

   NAME is a string identifying the setting.  Please choose reasonably
   short names.  When adding compound words, like "pretty-print",
   please use dash characters and not underline characters.

   KIND identifies the nature of the setting.

   SUMMARY is a one line string with a terse description of the
   setting.  It is used by the help subsystem.

   DESCRIPTION is a long description of the global setting,
   multi-line, and preferably showing some usage example.  It is used
   by the help subsystem.

   GETTER is a function that retuns the current value of the global
   setting.

   SETTER is a function that, given a value, tries to set it as the
   new value for the global setting.  If the operation succeeds, this
   function must return the empty string, otherwise an error message
   indicating what went wrong.  For example, for a setting accepting
   values "yes", "no" and "perhaps", SETTER ("foobar") may return a
   string like "the value must one of `yes', `no' or `perhaps'".  The
   setters can assume that the given value is of the right type
   according to the kind.

   Note how Poke_Setting doesn't provide a recipient to store the
   value of the global setting itself: it is up to the getter and
   setter to do provide it if needed (via a lexical closure, see
   examples below.)  */


var POKE_SETTING_INT = 0;
var POKE_SETTING_BOOL = 1;
var POKE_SETTING_STR = 2;

type Poke_Setting =
  struct
    {
      fun is_line_p
        = (string s) int<32>: { return strchr (s, '\n') == s'length; }

      string name;
      int kind : kind in [POKE_SETTING_INT,
                          POKE_SETTING_BOOL,
                          POKE_SETTING_STR];
      string summary : is_line_p (summary);
      string usage : is_line_p (usage);
      string description;
      ()any getter;
      (any)string setter;
    };

/* The global settings registry.  */

type Poke_Setting_Registry =
  struct
    {
      Poke_Setting[] entries;

      /* Search for a given setting by name.

         If the given name doesn't identify a setting in pk_settings,
         raise E_inval.  */

      method search = (string name) Poke_Setting:
        {
          for (e in entries)
            if (e.name == name)
              return e;
          raise E_inval;
        }

      /* Add a new global setting to the registry.

         If a setting with the given name already exists in the
         registry, raise E_inval.  */

      method add_setting = (Poke_Setting entry) void:
        {
          try search (entry.name);
          catch if E_inval {
            entries += [entry];
            return;
          }

          raise E_inval;
        }

      /* Get the value of a global setting given its name.  */

      method get = (string name) any:
      {
        var s = search (name);
        var val = s.getter;

        if (s.kind == POKE_SETTING_BOOL)
          val = val as int<32> ? "yes" : "no";

        return val;
      }

      /* Set the value of a global setting given its name.

         If the provided name doesn't name a setting, or the given
         value is not of the right kind for the setting, raise
         E_inval.

         If the provided value doesn't satisfy the constraints
         enforced by the setting, an explicative error message is
         returned.

         If the value is successfully set as the new value of the
         global setting, return an empty string.  */

      method set = (string name, any val) string:
      {
        var s = search (name);

        if (s.kind == POKE_SETTING_BOOL)
          {
            if (!(val isa string))
              raise E_inval;

            if (!(val as string in ["yes", "no"]))
              return s.name + " should be one of `yes' or `no'";

            val = (val as string == "yes");
          }

        try return s.setter (val);
        catch if E_conv { raise E_inval; }
      }
    };

/* Create the registry.  */

var pk_settings = Poke_Setting_Registry {};

pk_settings.add_setting
  :entry Poke_Setting {
           name = "pretty-print",
           kind = POKE_SETTING_BOOL,
           summary = "whether poke should use struct pretty-printers",
           getter = lambda any:
             {
               return vm_opprint;
             },
           setter = lambda (any val) string:
             {
               vm_set_opprint (val as int<32>);
               return "";
             }
         };

pk_settings.add_setting
  :entry Poke_Setting {
           name = "obase",
           kind = POKE_SETTING_INT,
           summary = "numerical base to use when printing integral values",
           usage = ".set obase {2,8,10,16}",
           getter = lambda any:
             {
               return vm_obase;
             },
           setter = lambda (any v) string:
             {
               var obase = v as int<32>;

               try vm_set_obase (obase);
               catch if E_inval {
                 return "obase should be one of 2, 8, 10 or 16";
               }
               return "";
             }
         };

pk_settings.add_setting
  :entry Poke_Setting {
           name = "endian",
           kind = POKE_SETTING_STR,
           summary = "endianness used while accessing the IO spaces",
           usage = ".set endian {little,big,host,network}",
           getter = lambda any:
             {
               if (get_endian == ENDIAN_BIG)
                  return "big";
               else
                  return "little";
             },
           setter = lambda (any v) string:
             {
               var s = v as string;
               var endian = ENDIAN_LITTLE;

               if (s == "big")
                 endian = ENDIAN_BIG;
               else if (s == "little")
                 endian = ENDIAN_LITTLE;
               else if (s == "host")
                 endian = pk_host_endian;
               else if (s == "network")
                 endian = pk_network_endian;
               else
                 return
                   "endian should be one of `little', `big', `host' or `network'";

               set_endian (endian);
               return "";
             }
         };

pk_settings.add_setting
  :entry Poke_Setting {
      name = "auto-map",
      kind = POKE_SETTING_BOOL,
      summary = "whether poke auto-loads maps when opening IO spaces",
      usage = ".set auto-map {yes,no}",
      getter = lambda any: { return pk_auto_map_p; },
      setter = lambda (any val) string:
        {
          pk_auto_map_p = val as int<32>;
          return "";
        }
    };

pk_settings.add_setting
  :entry Poke_Setting {
    name = "prompt-maps",
    kind = POKE_SETTING_BOOL,
    summary = "whether map information should be included in the prompt",
    usage = ".set prompt-maps {yes,no}",
    getter = lambda any: { return pk_prompt_maps_p; },
    setter = lambda (any val) string:
      {
        pk_prompt_maps_p = val as int<32>;
        return "";
      }
    };

pk_settings.add_setting
  :entry Poke_Setting {
    name = "oacutoff",
    kind = POKE_SETTING_INT,
    summary = "cutoff value used when printing array elements",
    usage = ".set oacutoff INTEGER",
    getter = lambda any: { return vm_oacutoff; },
    setter = lambda (any val) string:
      {
        vm_set_oacutoff (val as int<32>);
        return "";
      }
    };

pk_settings.add_setting
  :entry Poke_Setting {
    name = "odepth",
    kind = POKE_SETTING_INT,
    summary = "maximum depth to include when printing nested structures",
    usage = ".set odepth INTEGER",
    getter = lambda any: { return vm_odepth; },
    setter = lambda (any val) string:
      {
        vm_set_odepth (val as int<32>);
        return "";
      }
    };

pk_settings.add_setting
  :entry Poke_Setting {
    name = "oindent",
    kind = POKE_SETTING_INT,
    summary = "witdh of each indentation leveel when printing structures",
    usage = ".set oindent INTEGER",
    getter = lambda any: { return vm_oindent; },
    setter = lambda (any val) string:
      {
        vm_set_oindent (val as int<32>);
        return "";
      }
    };

pk_settings.add_setting
  :entry Poke_Setting {
    name = "omaps",
    kind = POKE_SETTING_BOOL,
    summary = "whether include offset information when printing values",
    usage = ".set omaps {yes,no}",
    getter = lambda any: { return vm_omaps; },
    setter = lambda (any val) string:
      {
        vm_set_omaps (val as int<32>);
        return "";
      }
    };

pk_settings.add_setting
  :entry Poke_Setting {
    name = "omode",
    kind = POKE_SETTING_STR,
    summary = "output mode for printing values",
    usage = ".set omode {flat,tree}",
    getter = lambda any:
      {
        var omode = vm_omode;

        if (omode == VM_OMODE_PLAIN)
          return "flat";
        else if (omode == VM_OMODE_TREE)
          return "tree";

        assert (0, "this point shouln't be reached");
      },
    setter = lambda (any val) string:
      {
        var s = val as string;

        if (s == "flat")
          vm_set_omode (VM_OMODE_PLAIN);
        else if (s == "tree")
          vm_set_omode (VM_OMODE_TREE);
        else
          return "omode should be one of `flat' or `tree'";

        return "";
      }
    };

pk_settings.add_setting
  :entry Poke_Setting {
    name = "doc-viewer",
    kind = POKE_SETTING_STR,
    summary = "program to show document from the manual",
    usage = ".set doc-viewer {info,less}",
    getter = lambda any: { return pk_doc_viewer; },
    setter = lambda (any val) string:
      {
        var s = val as string;

        if (s != "info" && s != "less")
          return "doc-viewer should be one of `info' or `less'";

        pk_doc_viewer = s;
        return "";
      }
    };

/* Create help topics for the global settings defined above.  */

for (setting in pk_settings.entries)
  pk_help_add_topic
    :entry Poke_HelpEntry {
             category = "settings",
             topic = setting.name,
             summary = setting.summary,
             description = setting.description
           };

/* Create the help topic for error-on-warning, which is handled in C
   only and therefore is not in the settings registry.  */

pk_help_add_topic
  :entry Poke_HelpEntry {
           category = "settings",
           topic = "error-on-warning",
           summary = "emit errors instead of warnings",
           description = "",
    };
