## Jitter specification for the GNU Poke Virtual Machine.

## Copyright (C) 2019, 2020, 2021 Jose E. Marchesi
## Written by Jose E. Marchesi

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

vm
  set prefix "pvm"
end



## Stacks.

stack s
  long-name "stack"
  c-element-type "pvm_val"
  tos-optimized
  element-no 65536
  guard-underflow
  guard-overflow
end

stack t
  long-name "returnstack"
  c-element-type "pvm_val"
  non-tos-optimized
  element-no 65536
  guard-underflow
  guard-overflow
end

stack x
  long-name "exceptionstack"
  c-element-type "struct pvm_exception_handler"
  non-tos-optimized
  element-no 65536
  guard-underflow
  guard-overflow
end



## Register classes.

register-class r
  c-type "pvm_val"
  fast-register-no 0
  slow-registers
end



## Functions and globals to wrap.

wrapped-functions
  printf
  snprintf
  pvm_array_insert
  pvm_array_set
  pvm_assert
  pvm_env_lookup
  pvm_env_register
  pvm_env_pop_frame
  pvm_env_push_frame
  pvm_env_toplevel
  pvm_make_string
  pvm_make_string_nodup
  pvm_make_array
  pvm_make_struct
  pvm_make_offset
  pvm_make_integral_type
  pvm_make_string_type
  pvm_make_offset_type
  pvm_make_array_type
  pvm_alloc
  pvm_allocate_struct_attrs
  pvm_make_struct_type
  pvm_typeof
  pvm_type_equal_p
  pvm_ref_struct
  pvm_ref_struct_cstr
  pvm_set_struct
  pvm_val_reloc
  pvm_val_unmap
  pvm_val_ureloc
  ios_close
  ios_cur
  ios_flags
  ios_flush
  ios_get_id
  ios_open
  ios_read_int
  ios_read_uint
  ios_read_string
  ios_search_by_id
  ios_set_bias
  ios_set_cur
  ios_write_string
  random
  srandom
  secure_getenv
  gettime
  memcpy
  strlen
  strcmp
  strcpy
  strncpy
end

#wrapped-globals
#  pvm_printf_format_string
#end


## Embedded C code.

initial-header-c
  code
#   include <config.h>
  end
end

early-header-c
  code
#   include "pvm.h"
#   include "pvm-val.h"
#   include "ios.h"
#   include "pkt.h"
#   include "pk-utils.h"

    /* Exception handlers, that are installed in the "exceptionstack".

       EXCEPTION is the exception type, either one of the E_* values defined
       above, or any integer >= 256 for user-defined exceptions.

       MAIN_STACK_HEIGHT and RETURN_STACK_HEIGHT are the heights of
       the main and return stacks, to restore before transferring
       control to the exception handler.

       CODE is the program point where the exception handler starts.

       ENV is the run-time environment to restore before transferring
       control to the exception handler.  */

    struct pvm_exception_handler
    {
      int exception;
      jitter_stack_height main_stack_height;
      jitter_stack_height return_stack_height;
      pvm_program_point code;
      pvm_env env;
    };
  end
end

initial-vm1-c
  code
#   include <config.h>
  end
end

initial-vm2-c
  code
#   include <config.h>
  end
end

early-c
  code
#   include <config.h>
#   include <stdlib.h>
#   include <string.h>
#   include <assert.h>
#   include <time.h>
#   include <errno.h>
#   include "timespec.h"
#   include "intprops.h"

#   include "pvm-alloc.h"
  end
end

late-header-c
  code
    /* Macros to raise an exception from within an instruction.  This
       is used in the RAISE instruction itself, and also in instructions
       that can fail, such as integer division or IO.

       The code in the macro looks for the first matching exception
       handler in the exception handlers stack.  Then it restores the
       heights of the main stack and the return stack, restores the
       original dynamic environment, and then pushes the exception
       type as an integer in the main stack, before branching to the
       exception handler.  */

#define PVM_RAISE_DIRECT(EXCEPTION)                                   \
  do                                                                  \
  {                                                                   \
   int exception_code                                                 \
     = PVM_VAL_INT (pvm_ref_struct_cstr ((EXCEPTION), "code"));       \
                                                                      \
   while (1)                                                          \
   {                                                                  \
     struct pvm_exception_handler ehandler                            \
       = JITTER_TOP_EXCEPTIONSTACK ();                                \
     int handler_exception = ehandler.exception;                      \
                                                                      \
     JITTER_DROP_EXCEPTIONSTACK ();                                   \
                                                                      \
     if (handler_exception == 0                                       \
         || handler_exception == exception_code)                      \
     {                                                                \
       JITTER_SET_HEIGHT_STACK (ehandler.main_stack_height);          \
       JITTER_SET_HEIGHT_RETURNSTACK (ehandler.return_stack_height);  \
                                                                      \
       JITTER_PUSH_STACK ((EXCEPTION));                               \
                                                                      \
       jitter_state_runtime.env = ehandler.env;                       \
       JITTER_BRANCH (ehandler.code);                                 \
       break;                                                         \
     }                                                                \
   }                                                                  \
 } while (0)


#define PVM_RAISE(CODE,STR,ESTATUS)                                   \
 do                                                                   \
 {                                                                    \
   pvm_val exception = pvm_make_exception ((CODE),(STR),(ESTATUS),    \
                                           NULL, NULL);               \
   PVM_RAISE_DIRECT (exception);                                      \
 } while (0)

#define PVM_RAISE_DFL(BASE)                                           \
 do                                                                   \
 {                                                                    \
   PVM_RAISE (BASE,BASE##_NAME,BASE##_ESTATUS);                        \
 } while (0)

    /* Macros to implement different kind of instructions.  These are to
       avoid flagrant code replication below.  */

/* Binary numeric operations generating a boolean on the stack.
   ( TYPE TYPE -- TYPE TYPE INT ) */
# define PVM_BOOL_BINOP(TYPE,OP)                                             \
   do                                                                        \
    {                                                                        \
      pvm_val res = PVM_MAKE_INT (PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ()) \
                                  OP PVM_VAL_##TYPE (JITTER_TOP_STACK ()), 32); \
      JITTER_PUSH_STACK (res);                                               \
    } while (0)

/* Unary numeric operations.
   ( TYPE -- TYPE TYPE) */
# define PVM_UNOP(TYPE,TYPER,TYPERLC,OP)                                     \
   do                                                                        \
    {                                                                        \
      int size = PVM_VAL_##TYPER##_SIZE (JITTER_TOP_STACK ());               \
      pvm_val res = pvm_make_##TYPERLC (OP PVM_VAL_##TYPE (JITTER_TOP_STACK ()), size); \
      JITTER_PUSH_STACK (res);                                               \
    } while (0)

/* Signed negation.
   We check for overflow, raising E_overflow whenever appropriate.  */

# define PVM_NEG_SIGNED(TYPE,CTYPE)                                          \
  do                                                                         \
  {                                                                          \
    CTYPE a = PVM_VAL_##TYPE (JITTER_TOP_STACK ());                          \
    int size = PVM_VAL_##TYPE##_SIZE (JITTER_TOP_STACK ());                  \
    int64_t a64 = ((int64_t) a << (64 - size));                              \
                                                                             \
    if (INT_NEGATE_OVERFLOW (a64))                                           \
      PVM_RAISE_DFL (PVM_E_OVERFLOW);                                        \
    else                                                                     \
      JITTER_PUSH_STACK (PVM_MAKE_##TYPE (-a, size));                        \
  } while (0)


/* Signed addition.
   The two operands and the result are assumed to be PVM integers, having
   the same bit size.
   We check for overflow, raising E_overflow whenever appropriate.  */

# define PVM_ADD_SIGNED(TYPE,CTYPE)                                          \
  do                                                                         \
  {                                                                          \
    CTYPE a = PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ());                    \
    CTYPE b = PVM_VAL_##TYPE (JITTER_TOP_STACK ());                          \
    int size = PVM_VAL_##TYPE##_SIZE (JITTER_TOP_STACK ());                  \
    int64_t a64 = ((int64_t) a << (64 - size));                              \
    int64_t b64 = ((int64_t) b << (64 - size));                              \
                                                                             \
    if (INT_ADD_OVERFLOW (a64, b64))                                         \
      PVM_RAISE_DFL (PVM_E_OVERFLOW);                                        \
    else                                                                     \
      JITTER_PUSH_STACK (PVM_MAKE_##TYPE (a + b, size));                     \
  } while (0)

/* Signed subtraction.
   The two operands and the result are assumed to be PVM integers, having
   the same bit size.
   We check for overflow, raising E_overflow whenever appropriate.  */

# define PVM_SUB_SIGNED(TYPE,CTYPE)                                          \
  do                                                                         \
  {                                                                          \
    CTYPE a = PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ());                    \
    CTYPE b = PVM_VAL_##TYPE (JITTER_TOP_STACK ());                          \
    int size = PVM_VAL_##TYPE##_SIZE (JITTER_TOP_STACK ());                  \
    int64_t a64 = ((int64_t) a << (64 - size));                              \
    int64_t b64 = ((int64_t) b << (64 - size));                              \
                                                                             \
    if (INT_SUBTRACT_OVERFLOW (a64, b64))                                    \
      PVM_RAISE_DFL (PVM_E_OVERFLOW);                                        \
    else                                                                     \
      JITTER_PUSH_STACK (PVM_MAKE_##TYPE (a - b, size));                     \
  } while (0)

/* Signed multiplication.
   The two operands and the result are assumed to be PVM integers, having
   the same bit size.
   We check for overflow, raising E_overflow whenever appropriate.  */

# define PVM_MUL_SIGNED(TYPE,CTYPE)                                          \
  do                                                                         \
  {                                                                          \
    CTYPE a = PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ());                    \
    CTYPE b = PVM_VAL_##TYPE (JITTER_TOP_STACK ());                          \
    int size = PVM_VAL_##TYPE##_SIZE (JITTER_TOP_STACK ());                  \
    int64_t a64 = ((int64_t) a << (64 - size));                              \
                                                                             \
    if (INT_MULTIPLY_OVERFLOW (a64, b))                                      \
      PVM_RAISE_DFL (PVM_E_OVERFLOW);                                        \
    else                                                                     \
      JITTER_PUSH_STACK (PVM_MAKE_##TYPE (a * b, size));                     \
  } while (0)

/* Signed division.
   We check for overflow, raising E_overflow whenever appropriate.  */

# define PVM_DIV_SIGNED(TYPE,CTYPE)                                          \
   if (PVM_VAL_##TYPE (JITTER_TOP_STACK ()) == 0)                            \
   {                                                                         \
      PVM_RAISE_DFL (PVM_E_DIV_BY_ZERO);                                     \
   }                                                                         \
   else                                                                      \
   {                                                                         \
    CTYPE a = PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ());                    \
    CTYPE b = PVM_VAL_##TYPE (JITTER_TOP_STACK ());                          \
    int size = PVM_VAL_##TYPE##_SIZE (JITTER_TOP_STACK ());                  \
    int64_t a64 = ((int64_t) a << (64 - size));                              \
                                                                             \
    if (INT_DIVIDE_OVERFLOW (a64, b))                                        \
      PVM_RAISE_DFL (PVM_E_OVERFLOW);                                        \
    else                                                                     \
      JITTER_PUSH_STACK (PVM_MAKE_##TYPE (a / b, size));                     \
   }

# define PVM_MOD_SIGNED(TYPE,CTYPE)                                          \
   if (PVM_VAL_##TYPE (JITTER_TOP_STACK ()) == 0)                            \
   {                                                                         \
      PVM_RAISE_DFL (PVM_E_DIV_BY_ZERO);                                     \
   }                                                                         \
   else                                                                      \
   {                                                                         \
    CTYPE a = PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ());                    \
    CTYPE b = PVM_VAL_##TYPE (JITTER_TOP_STACK ());                          \
    int size = PVM_VAL_##TYPE##_SIZE (JITTER_TOP_STACK ());                  \
    int64_t a64 = ((int64_t) a << (64 - size));                              \
                                                                             \
    if (INT_DIVIDE_OVERFLOW (a64, b))                                        \
      PVM_RAISE_DFL (PVM_E_OVERFLOW);                                        \
    else                                                                     \
      JITTER_PUSH_STACK (PVM_MAKE_##TYPE (a % b, size));                     \
   }

/* Binary numeric operations.
  ( TYPE TYPE -- TYPE TYPE TYPE ) */
# define PVM_BINOP(TYPEA,TYPEB,TYPER,OP)                                     \
   do                                                                        \
    {                                                                        \
      int size = PVM_VAL_##TYPER##_SIZE (JITTER_UNDER_TOP_STACK ());       \
      pvm_val res = PVM_MAKE_##TYPER (PVM_VAL_##TYPEA (JITTER_UNDER_TOP_STACK ()) \
                                      OP PVM_VAL_##TYPEB (JITTER_TOP_STACK ()), size); \
      JITTER_PUSH_STACK (res);                                               \
    } while (0)

/* Same, but with division by zero run-time check.  */
# define PVM_CHECKED_BINOP(TYPEA,TYPEB,TYPER,OP)                             \
   if (PVM_VAL_##TYPEB (JITTER_TOP_STACK ()) == 0)                           \
   {                                                                         \
      PVM_RAISE_DFL (PVM_E_DIV_BY_ZERO);                                     \
   }                                                                         \
   else                                                                      \
   {                                                                         \
      PVM_BINOP (TYPEA, TYPEB, TYPER, OP);                                   \
   }

/* Same, but for left-shifts, which includes an overflow check on the
   bit count.  */
# define PVM_BINOP_SL(TYPEA, TYPEB,TYPER, OP)                                \
   {                                                                         \
     pvm_val type = pvm_typeof (JITTER_UNDER_TOP_STACK ());                  \
     uint64_t size = PVM_VAL_INTEGRAL (PVM_VAL_TYP_I_SIZE (type));           \
                                                                             \
     if (PVM_VAL_##TYPEB (JITTER_TOP_STACK ()) >= size)                      \
     {                                                                       \
        PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);                                 \
     }                                                                       \
     else                                                                    \
     {                                                                       \
        PVM_BINOP (TYPEA, TYPEB, TYPER, OP);                                 \
     }                                                                       \
   }

/* Unsigned exponentiation.  */

# define PVM_POWOP(TYPE,TYPEC,TYPELC)                                       \
  do                                                                        \
  {                                                                         \
     uint64_t size = PVM_VAL_##TYPE##_SIZE (JITTER_UNDER_TOP_STACK ());     \
     TYPEC res                                                              \
      = (TYPEC) pk_upow (PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ()),        \
                         PVM_VAL_UINT (JITTER_TOP_STACK ()));               \
                                                                            \
     JITTER_PUSH_STACK (pvm_make_##TYPELC (res, size));                     \
  }                                                                         \
  while (0)

/* Signed exponentiation, with overflow check.  */

# define PVM_POWOP_SIGNED(TYPE,TYPEC,TYPELC)                                \
  do                                                                        \
  {                                                                         \
     int overflow_p;                                                        \
     uint32_t i;                                                            \
     TYPEC res;                                                             \
     uint64_t size = PVM_VAL_##TYPE##_SIZE (JITTER_UNDER_TOP_STACK ());     \
     TYPEC a = PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ());                  \
     uint32_t b = PVM_VAL_UINT (JITTER_TOP_STACK ());                       \
     int64_t res64 = ((uint64_t) 1) << (64 - size);                         \
                                                                            \
     overflow_p = 0;                                                        \
     for (i = 0; i < b; ++i)                                                \
       {                                                                    \
         if (INT_MULTIPLY_OVERFLOW (res64, a))                              \
           {                                                                \
             PVM_RAISE_DFL (PVM_E_OVERFLOW);                                \
             overflow_p = 1;                                                \
             break;                                                         \
           }                                                                \
                                                                            \
         res64 *= a;                                                        \
        }                                                                   \
                                                                            \
     if (!overflow_p)                                                       \
       {                                                                    \
         res = res64 >> (64 - size);                                        \
         JITTER_PUSH_STACK (pvm_make_##TYPELC (res, size));                 \
       }                                                                    \
  }                                                                         \
  while (0)


/* Conversion instructions.
   ( TYPE -- TYPE RTYPE )  */
#define PVM_CONVOP(TYPE, TYPEC, RTYPELC, RTYPEC)                             \
   do                                                                        \
    {                                                                        \
      jitter_uint tsize = JITTER_ARGN0;                                      \
      TYPEC val = PVM_VAL_##TYPE (JITTER_TOP_STACK ());                      \
      JITTER_PUSH_STACK (pvm_make_##RTYPELC ((RTYPEC) val, tsize));          \
    } while (0)

/* Auxiliary macros used in PVM_PEEK and PVM_POKE below.  */
#define PVM_IOS_ARGS_INT                                                     \
  io, offset, 0, bits, endian, nenc, &value
#define PVM_IOS_ARGS_UINT                                                    \
  io, offset, 0, bits, endian, &value
#define PVM_IOS_ARGS_WRITE_INT                                               \
  io, offset, 0, bits, endian, nenc, value
#define PVM_IOS_ARGS_WRITE_UINT                                              \
  io, offset, 0, bits, endian, value

/* Integral peek instructions.
   ( IOS BOFF -- VAL )  */
#define PVM_PEEK(TYPE,IOTYPE,NENC,ENDIAN,BITS,IOARGS)                        \
  do                                                                         \
   {                                                                         \
     int ret;                                                                \
     __attribute__((unused)) enum ios_nenc nenc = (NENC);                    \
     enum ios_endian endian = (ENDIAN);                                      \
     int bits = (BITS);                                                      \
     IOTYPE##64_t value;                                                     \
     ios io;                                                                 \
     ios_off offset;                                                         \
                                                                             \
     offset = PVM_VAL_ULONG (JITTER_TOP_STACK ());                           \
     if (JITTER_UNDER_TOP_STACK () == PVM_NULL)                              \
       io = ios_cur ();                                                      \
     else                                                                    \
       io = ios_search_by_id (PVM_VAL_INT (JITTER_UNDER_TOP_STACK ()));      \
                                                                             \
     if (io == NULL)                                                         \
       PVM_RAISE_DFL (PVM_E_NO_IOS);                                         \
                                                                             \
     JITTER_DROP_STACK ();                                                   \
     if ((ret = ios_read_##IOTYPE (IOARGS)) != IOS_OK)                       \
       {                                                                     \
         if (ret == IOS_EOF)                                                 \
            PVM_RAISE_DFL (PVM_E_EOF);                                       \
         else if (ret == IOS_ENOMEM)                                         \
            PVM_RAISE (PVM_E_IO, "out of memory", PVM_E_IO_ESTATUS);         \
         else if (ret == IOS_EPERM)                                          \
            PVM_RAISE_DFL (PVM_E_PERM);                                      \
         else                                                                \
            PVM_RAISE_DFL (PVM_E_IO);                                        \
         JITTER_TOP_STACK () = PVM_NULL;                                     \
       }                                                                     \
     else                                                                    \
       JITTER_TOP_STACK () = pvm_make_##TYPE (value, bits);                  \
   } while (0)

/* Integral poke instructions.
   ( IOS BOFF VAL -- )  */
#define PVM_POKE(TYPE,IOTYPE,NENC,ENDIAN,BITS,IOARGS)                        \
  do                                                                         \
   {                                                                         \
     int ret;                                                                \
     __attribute__((unused)) enum ios_nenc nenc = (NENC);                    \
     enum ios_endian endian = (ENDIAN);                                      \
     int bits = (BITS);                                                      \
     IOTYPE##64_t value = PVM_VAL_##TYPE (JITTER_TOP_STACK ());              \
     pvm_val offset_val = JITTER_UNDER_TOP_STACK ();                         \
     ios io;                                                                 \
     ios_off offset;                                                         \
                                                                             \
     JITTER_DROP_STACK ();                                                   \
     JITTER_DROP_STACK ();                                                   \
                                                                             \
     if (JITTER_TOP_STACK () == PVM_NULL)                                    \
       io = ios_cur ();                                                      \
     else                                                                    \
       io = ios_search_by_id (PVM_VAL_INT (JITTER_TOP_STACK ()));            \
                                                                             \
     if (io == NULL)                                                         \
       PVM_RAISE_DFL (PVM_E_NO_IOS);                                         \
     JITTER_DROP_STACK ();                                                   \
                                                                             \
     offset = PVM_VAL_ULONG (offset_val);                                    \
     if ((ret = ios_write_##IOTYPE (IOARGS)) != IOS_OK)                      \
       {                                                                     \
         if (ret == IOS_EOF)                                                 \
            PVM_RAISE_DFL (PVM_E_EOF);                                       \
         else if (ret == IOS_EPERM)                                          \
            PVM_RAISE_DFL (PVM_E_PERM);                                      \
         else                                                                \
            PVM_RAISE_DFL (PVM_E_IO);                                        \
       }                                                                     \
   } while (0)

/* Macro to call to a closure.  This is used in the instruction CALL,
   and also other instructions required to... call :D The argument
   should be a closure (surprise.)  */

#define PVM_CALL(CLS)                                                        \
   do                                                                        \
    {                                                                        \
       /* Make place for the return address in the return stack.  */         \
       /* actual value will be written by the callee. */                     \
       JITTER_PUSH_UNSPECIFIED_RETURNSTACK();                                \
                                                                             \
       /* Save the current environment and use the callee's environment. */     \
       JITTER_PUSH_RETURNSTACK ((jitter_uint) (uintptr_t) jitter_state_runtime.env); \
       jitter_state_runtime.env = PVM_VAL_CLS_ENV ((CLS));                   \
                                                                             \
       /* Branch-and-link to the native code, whose first instruction will */ \
       /*  be a prolog. */                                                   \
       JITTER_BRANCH_AND_LINK (PVM_VAL_CLS_ENTRY_POINT ((CLS)));           \
    } while (0)

/* Macros to implement printi* and printl* instructions.  */

#define PVM_PRINTI(TYPE,TYPEC,SIGNED_P,BASE)                                \
  do                                                                        \
  {                                                                         \
    TYPEC val = PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ());                 \
    char fmt[16];  /* %0NNd */                                              \
    char *iformat = "";                                                     \
    uint32_t mask                                                           \
        = JITTER_ARGN0 == 32 ? (uint32_t)-1                                 \
                             : (((uint32_t)1 << JITTER_ARGN0) - 1);         \
                                                                            \
    fmt[0] = '%';                                                           \
    fmt[1] = '0';                                                           \
    fmt[2] = '\0';                                                          \
    if ((BASE) == 10)                                                       \
    {                                                                       \
      iformat = SIGNED_P ? PRIi32 : PRIu32;                                 \
      strcat (fmt, iformat);                                                \
    }                                                                       \
    else                                                                    \
    {                                                                       \
      char *basefmt = "";                                                   \
      int prec = 0;                                                         \
                                                                            \
      if ((BASE) == 256)                                                    \
      {                                                                     \
        iformat = "c";                                                      \
        prec = 1;                                                           \
      }                                                                     \
      else if ((BASE) == 16)                                                \
      {                                                                     \
        iformat = PRIx32;                                                   \
        prec = (JITTER_ARGN0 / 4) + ((JITTER_ARGN0 % 4) != 0);              \
      }                                                                     \
      else if ((BASE) == 8)                                                 \
      {                                                                     \
        basefmt = PRIo32;                                                   \
        prec = (JITTER_ARGN0 / 3) + ((JITTER_ARGN0 % 3) != 0);              \
      }                                                                     \
      else if ((BASE) == 2)                                                 \
      {                                                                     \
        pk_print_binary (pk_puts, val, JITTER_ARGN0, 1);                    \
        JITTER_DROP_STACK ();                                               \
        JITTER_DROP_STACK ();                                               \
        break;                                                              \
      }                                                                     \
                                                                            \
      assert (prec != 0);                                                   \
      fmt[2] = '0' + (prec / 10);                                           \
      fmt[3] = '0' + prec - (prec / 10 * 10);                               \
      fmt[4] = '\0';                                                        \
      strcat (fmt, iformat);                                                \
      strcat (fmt, basefmt);                                                \
    }                                                                       \
                                                                            \
    pk_printf (fmt, (BASE) == 10 ? val : val & mask);                       \
    JITTER_DROP_STACK ();                                                   \
    JITTER_DROP_STACK ();                                                   \
  } while (0)

#define PVM_PRINTL(TYPE,TYPEC,SIGNED_P,BASE)                                \
  do                                                                        \
  {                                                                         \
    TYPEC val = PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ());                 \
    char fmt[16];  /* %0NNfff */                                            \
    char *iformat = "";                                                     \
    uint64_t mask                                                           \
        = JITTER_ARGN0 == 64 ? (uint64_t)-1                                 \
                             : (((uint64_t)1 << JITTER_ARGN0) - 1);         \
                                                                            \
    fmt[0] = '%';                                                           \
    fmt[1] = '0';                                                           \
    fmt[2] = '\0';                                                          \
    if ((BASE) == 10)                                                       \
    {                                                                       \
      iformat = SIGNED_P ? PRIi64 : PRIu64;                                 \
      strcat (fmt, iformat);                                                \
    }                                                                       \
    else                                                                    \
    {                                                                       \
      char *basefmt = "";                                                   \
      int prec = 0;                                                         \
                                                                            \
      if ((BASE) == 16)                                                     \
      {                                                                     \
        iformat = PRIx64;                                                   \
        prec = (JITTER_ARGN0 / 4) + ((JITTER_ARGN0 % 4) != 0);              \
      }                                                                     \
      else if ((BASE) == 8)                                                 \
      {                                                                     \
        basefmt = PRIo64;                                                   \
        prec = (JITTER_ARGN0 / 3) + ((JITTER_ARGN0 % 3) != 0);              \
      }                                                                     \
      else if ((BASE) == 2)                                                 \
      {                                                                     \
        pk_print_binary (pk_puts, val, JITTER_ARGN0, 1);                    \
        JITTER_DROP_STACK ();                                               \
        JITTER_DROP_STACK ();                                               \
        break;                                                              \
      }                                                                     \
                                                                            \
      fmt[2] = '0' + (prec / 10);                                           \
      fmt[3] = '0' + prec - (prec / 10 * 10);                               \
      fmt[4] = '\0';                                                        \
      strcat (fmt, iformat);                                                \
      strcat (fmt, basefmt);                                                \
    }                                                                       \
                                                                            \
    pk_printf (fmt, (BASE) == 10 ? val : val & mask);                       \
    JITTER_DROP_STACK ();                                                   \
    JITTER_DROP_STACK ();                                                   \
  } while (0)

/* Macros to implement formati* and formatl* instructions.  */

#define PVM_FORMATI(OUT,OUTLEN,TYPE,TYPEC,SIGNED_P,BASE)                    \
  do                                                                        \
  {                                                                         \
    TYPEC val = PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ());                 \
    char fmt[16];  /* %0NNd */                                              \
    char *iformat = "";                                                     \
    int n;                                                                  \
    uint32_t mask                                                           \
        = JITTER_ARGN0 == 32 ? (uint32_t)-1                                 \
                             : (((uint32_t)1 << JITTER_ARGN0) - 1);         \
                                                                            \
    fmt[0] = '%';                                                           \
    fmt[1] = '0';                                                           \
    fmt[2] = '\0';                                                          \
    if ((BASE) == 10)                                                       \
    {                                                                       \
      iformat = SIGNED_P ? PRIi32 : PRIu32;                                 \
      strcat (fmt, iformat);                                                \
    }                                                                       \
    else                                                                    \
    {                                                                       \
      char *basefmt = "";                                                   \
      int prec = 0;                                                         \
                                                                            \
      if ((BASE) == 256)                                                    \
      {                                                                     \
        iformat = "c";                                                      \
        prec = 1;                                                           \
      }                                                                     \
      else if ((BASE) == 16)                                                \
      {                                                                     \
        iformat = PRIx32;                                                   \
        prec = (JITTER_ARGN0 / 4) + ((JITTER_ARGN0 % 4) != 0);              \
      }                                                                     \
      else if ((BASE) == 8)                                                 \
      {                                                                     \
        basefmt = PRIo32;                                                   \
        prec = (JITTER_ARGN0 / 3) + ((JITTER_ARGN0 % 3) != 0);              \
      }                                                                     \
      else if ((BASE) == 2)                                                 \
      {                                                                     \
        n = pk_format_binary ((OUT), (OUTLEN), val, JITTER_ARGN0, SIGNED_P);\
        assert (n == 0);                                                    \
        JITTER_DROP_STACK ();                                               \
        JITTER_DROP_STACK ();                                               \
        JITTER_PUSH_STACK (pvm_make_string ((OUT)));                        \
        break;                                                              \
      }                                                                     \
                                                                            \
      assert (prec != 0);                                                   \
      fmt[2] = '0' + (prec / 10);                                           \
      fmt[3] = '0' + prec - (prec / 10 * 10);                               \
      fmt[4] = '\0';                                                        \
      strcat (fmt, iformat);                                                \
      strcat (fmt, basefmt);                                                \
    }                                                                       \
                                                                            \
    n = snprintf ((OUT), (OUTLEN), fmt,  (BASE) == 10 ? val : val & mask);  \
    assert (n < (OUTLEN));                                                  \
    JITTER_DROP_STACK ();                                                   \
    JITTER_DROP_STACK ();                                                   \
    JITTER_PUSH_STACK (pvm_make_string ((OUT)));                            \
  } while (0)

#define PVM_FORMATL(OUT,OUTLEN,TYPE,TYPEC,SIGNED_P,BASE)                    \
  do                                                                        \
  {                                                                         \
    TYPEC val = PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ());                 \
    char fmt[16];  /* %0NNfff */                                            \
    char *iformat = "";                                                     \
    int n;                                                                  \
    uint64_t mask                                                           \
        = JITTER_ARGN0 == 64 ? (uint64_t)-1                                 \
                             : (((uint64_t)1 << JITTER_ARGN0) - 1);         \
                                                                            \
    fmt[0] = '%';                                                           \
    fmt[1] = '0';                                                           \
    fmt[2] = '\0';                                                          \
    if ((BASE) == 10)                                                       \
    {                                                                       \
      iformat = SIGNED_P ? PRIi64 : PRIu64;                                 \
      strcat (fmt, iformat);                                                \
    }                                                                       \
    else                                                                    \
    {                                                                       \
      char *basefmt = "";                                                   \
      int prec = 0;                                                         \
                                                                            \
      if ((BASE) == 16)                                                     \
      {                                                                     \
        iformat = PRIx64;                                                   \
        prec = (JITTER_ARGN0 / 4) + ((JITTER_ARGN0 % 4) != 0);              \
      }                                                                     \
      else if ((BASE) == 8)                                                 \
      {                                                                     \
        basefmt = PRIo64;                                                   \
        prec = (JITTER_ARGN0 / 3) + ((JITTER_ARGN0 % 3) != 0);              \
      }                                                                     \
      else if ((BASE) == 2)                                                 \
      {                                                                     \
        n = pk_format_binary ((OUT), (OUTLEN), val, JITTER_ARGN0, SIGNED_P);\
        assert (n == 0);                                                    \
        JITTER_DROP_STACK ();                                               \
        JITTER_DROP_STACK ();                                               \
        JITTER_PUSH_STACK (pvm_make_string ((OUT)));                        \
        break;                                                              \
      }                                                                     \
                                                                            \
      fmt[2] = '0' + (prec / 10);                                           \
      fmt[3] = '0' + prec - (prec / 10 * 10);                               \
      fmt[4] = '\0';                                                        \
      strcat (fmt, iformat);                                                \
      strcat (fmt, basefmt);                                                \
    }                                                                       \
                                                                            \
    n = snprintf ((OUT), (OUTLEN), fmt,  (BASE) == 10 ? val : val & mask);  \
    assert (n < (OUTLEN));                                                  \
    JITTER_DROP_STACK ();                                                   \
    JITTER_DROP_STACK ();                                                   \
    JITTER_PUSH_STACK (pvm_make_string ((OUT)));                            \
  } while (0)

  end
end

late-c
  code
    void
    pvm_handle_signal (int signal_number)
    {
      struct vmprefix_state *s;

      /* For every state... */
      VMPREFIX_FOR_EACH_STATE (s)
      {
        /* ...Mark the signal signal_number as pending... */
        VMPREFIX_STATE_AND_SIGNAL_TO_PENDING_SIGNAL_NOTIFICATION
           (s, signal_number) = true;
        /* ...And record the fact that there is at least one notification to
           handle. */
        VMPREFIX_STATE_TO_PENDING_NOTIFICATIONS (s) = true;
      }
    }
  end
end

printer-c
  code
    static jitter_uint printer_hi;

    static void
    pvm_literal_printer_cast (jitter_print_context out, jitter_uint val)
    {
      pk_printf ("%" JITTER_PRIu, val);
      pk_term_flush ();
    }

    static void
    pvm_literal_printer (jitter_print_context out, jitter_uint val)
    {
      pvm_print_val_with_params (NULL /* not used since no
                                         pretty-print */,
                                 (pvm_val) val,
                                 1 /* depth */,
                                 PVM_PRINT_FLAT,
                                 16 /* base */,
                                 0 /* indent */,
                                 2 /* acutoff */,
                                 0 /* flags */);
      pk_term_flush ();
    }

    static void
    pvm_literal_printer_hi (jitter_print_context out, jitter_uint hi)
    {
      pk_printf ("%%hi(0x%" JITTER_PRIx ")", hi);
      pk_term_flush ();
      printer_hi = hi; /* This sucks */
    }

    static void
    pvm_literal_printer_lo (jitter_print_context out, jitter_uint lo)
    {
      pk_printf ("%%lo(0x%" JITTER_PRIx") (", lo);

      pvm_print_val_with_params (NULL /* not used since no
                                         pretty-print */,
                                 ((pvm_val) printer_hi << 32) | lo,
                                 1 /* depth */,
                                 PVM_PRINT_FLAT,
                                 16 /* base */,
                                 0 /* indent */,
                                 2 /* acutoff */,
                                 0 /* flags */);
      pk_puts (")");
      pk_term_flush ();
      printer_hi = 0;
    }

    static void
    popf_printer (jitter_print_context out, jitter_uint nframes)
    {
      pk_printf ("%" JITTER_PRIu, nframes);
      pk_term_flush ();
    }

    static void
    bits_printer (jitter_print_context out, jitter_uint val)
    {
      pk_printf ("%" JITTER_PRIu, val);
      pk_term_flush ();
    }

    static void
    endian_printer (jitter_print_context out, jitter_uint val)
    {
      pk_printf ("%s", val == IOS_ENDIAN_MSB ? "big" : "little");
      pk_term_flush ();
    }

    static void
    nenc_printer (jitter_print_context out, jitter_uint val)
    {
      pk_printf ("%s", val == IOS_NENC_1 ? "1c" : "2c");
      pk_term_flush ();
    }
  end
end


## PVM state.

# Jitter supports maintaining a VM state which is splitted in
# `backing' and `runtime', so the question arises what to put in either
# part of the state.  According to the comments generated by jitterc:
#
# "The machine state is separated into the backing and the more
#  compact runtime data structures, to be allocated in registers as
#  far as possible.  These are just a forward-declarations: the actual
#  definitions are machine-generated."
#
# and:
#
# "The state backing and runtime are initialized at the same time, and
#  in fact the distinction between them is invisible to the VM user."
#
# So it looks like both `backing' and `runtime' are available at
# runtime, but accessing runtime is much more efficient because it is
# kept in host machine registers if possible.

state-struct-backing-c
  code
      enum pvm_exit_code exit_code;
      pvm_val result_value;
      jitter_stack_height canary;
      pvm vm;
  end
end

state-struct-runtime-c
  code
      pvm_env env;
      uint32_t push_hi;
      uint32_t endian;
      uint32_t nenc;
      uint32_t pretty_print;
      enum pvm_omode omode;
      int obase;
      int omaps;
      uint32_t odepth;
      uint32_t oindent;
      uint32_t oacutoff;
  end
end

state-initialization-c
  code
      jitter_state_backing->vm = NULL;
      jitter_state_backing->canary = NULL;
      jitter_state_backing->exit_code = PVM_EXIT_OK;
      jitter_state_backing->result_value = PVM_NULL;
      jitter_state_runtime->endian = IOS_ENDIAN_MSB;
      jitter_state_runtime->nenc = IOS_NENC_2;
      jitter_state_runtime->pretty_print = 0;
      jitter_state_runtime->omode = PVM_PRINT_FLAT;
      jitter_state_runtime->obase = 10;
      jitter_state_runtime->omaps = 0;
      jitter_state_runtime->odepth = 0;
      jitter_state_runtime->oindent = 2;
      jitter_state_runtime->oacutoff = 0;
  end
end

state-finalization-c
  code
   /* Finalize extra state here.  */
  end
end


### Begin of instructions

# In the instruction descriptions below, references to "the stack"
# refer to the main stack.  References to the other stacks (exceptions
# stack, return stack) are always explicit.

## VM instructions

# Instruction: canary
#
# This instruction installs a canary to mark the bottom of the stack,
# which is cheched by the `exit' instruction.  To be most effective this
# should be executed before the stack is used for the first time.
#
# Stack: ( -- )

instruction canary ()
  code
     PVM_STATE_BACKING_FIELD (canary) = JITTER_HEIGHT_STACK ();
  end
end

# Instruction: exit
#
# Do some cleanup and finish execution of a PVM program.  This checks
# the stack sentinel installed by the `canary' instruction.
#
# Stack: ( -- )

instruction exit ()
  branching
  code
    /* The element at the top of the stack is the exit
       code to report to the PVM caller.  */
    PVM_STATE_BACKING_FIELD (exit_code)
      = PVM_VAL_INT (JITTER_TOP_STACK());

    JITTER_DROP_STACK ();

    /* Get the result of the execution, if any.  */
    PVM_STATE_BACKING_FIELD (result_value)
                = JITTER_TOP_STACK();
    JITTER_DROP_STACK ();

    /* Check for the stack sentinel, but only if it was
       installed.  */
    if (PVM_STATE_BACKING_FIELD (canary) != NULL)
      assert (PVM_STATE_BACKING_FIELD (canary)
              == JITTER_HEIGHT_STACK ());

    /* Clear pending signals.  */
    {
      int i;
      for (i = 0; i < JITTER_SIGNAL_NO; i ++)
        if (JITTER_PENDING_SIGNAL_NOTIFICATION (i))
          JITTER_PENDING_SIGNAL_NOTIFICATION (i) = false;
      JITTER_PENDING_NOTIFICATIONS = false;
    }

    JITTER_EXIT ();
  end
end

# Instruction: pushend
#
# Push the current endianness on the stack.  This endianness is part
# of the global state of the PVM.
#
# Stack: ( -- INT )

instruction pushend ()
  code
    int endian = PVM_STATE_RUNTIME_FIELD (endian);
    JITTER_PUSH_STACK (PVM_MAKE_INT (endian, 32));
  end
end

# Instruction: popend
#
# Pop a signed integer from the stack and make it the current
# endianness in the PVM.  The possible values for endianness are
# IOS_ENDIAN_LSB and IOS_ENDIAN_MSB.
#
# Stack: ( INT -- )

instruction popend ()
  code
    uint32_t endian = PVM_VAL_INT (JITTER_TOP_STACK ());
    PVM_STATE_RUNTIME_FIELD (endian) = endian;
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushob
#
# Push output base.
#
# This instruction pushes a signed integer value with the output base
# that is used when printing PVM values.  Valid values are 2, 8, 10
# and 16.
#
# Stack: ( -- INT )

instruction pushob ()
  code
    int obase = PVM_STATE_RUNTIME_FIELD (obase);
    JITTER_PUSH_STACK (PVM_MAKE_INT (obase, 32));
  end
end

# Instruction: popob
#
# Pop and set output base.
#
# This instructions pops a signed integer from the stack and uses it
# to set the new output base to be used when printing PVM values.
# Valid values are 2, 8, 10 and 16.
#
# If an invalid obase is specified then this instruction raises
# PVM_E_INVAL.
#
# Stack: ( INT -- )
# Exceptions: PVM_E_INVAL

instruction popob ()
  branching # because of PVM_RAISE_DIRECT
  code
    int obase = PVM_VAL_INT (JITTER_TOP_STACK ());

    if (obase != 2 && obase != 8 && obase != 10 && obase != 16)
      PVM_RAISE (PVM_E_INVAL, "invalid output base", PVM_E_INVAL_ESTATUS);

    PVM_STATE_RUNTIME_FIELD (obase) = obase;
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushom
#
# Push output mode.
#
# This instruction pushes a signed integer value with the output mode
# that is used when printing PVM values.  Valid values are 0 for flat
# mode, and 1 for tree mode.
#
# Stack: ( -- INT )

instruction pushom ()
  code
    int omode = PVM_STATE_RUNTIME_FIELD (omode);
    JITTER_PUSH_STACK (PVM_MAKE_INT (omode, 32));
  end
end

# Instruction: popom
#
# Pop and set output mode.
#
# This instructions pops a signed integer from the stack and uses it
# to set the new output mode to be used when printing PVM values.
# Valid values are 0 for flat mode and 1 for tree mode.
#
# If an invalid omode is specified then this instruction raises
# PVM_E_INVAL.
#
# Stack: ( INT -- )
# Exceptions: PVM_E_INVAL

instruction popom ()
  branching # because of PVM_RAISE_DIRECT
  code
    int omode = PVM_VAL_INT (JITTER_TOP_STACK ());

    if (omode != PVM_PRINT_FLAT && omode != PVM_PRINT_TREE)
      PVM_RAISE (PVM_E_INVAL, "invalid output mode", PVM_E_INVAL_ESTATUS);

    PVM_STATE_RUNTIME_FIELD (omode) = omode;
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushoo
#
# Push output offsets mode.
#
# This instruction pushes a boolean encoded in a signed integer value
# indicating whether to show offsets when printing PVM values.
#
# Stack: ( -- INT )

instruction pushoo ()
  code
    int omaps = PVM_STATE_RUNTIME_FIELD (omaps);
    JITTER_PUSH_STACK (PVM_MAKE_INT (omaps, 32));
  end
end

# Instruction: popoo
#
# Pop and set output offsets mode.
#
# This instructions pops a boolean encoded in a signed integer from
# the stack and uses it to set the new output offset mode to be used
# when printing PVM values.
#
# Stack: ( INT -- )

instruction popoo ()
  code
    int omaps = PVM_VAL_INT (JITTER_TOP_STACK ());

    PVM_STATE_RUNTIME_FIELD (omaps) = omaps;
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushoi
#
# Push output indentation mode.
#
# This instructions pushes an integer to the stack with the current
# indentation step configured in the VM.  The indentation step
# determines how many white characters to use in each indentation
# level when printing output.
#
# Stack: ( -- INT )

instruction pushoi ()
  code
    int oindent = PVM_STATE_RUNTIME_FIELD (oindent);
    JITTER_PUSH_STACK (PVM_MAKE_INT (oindent, 32));
  end
end

# Instruction: popoi
#
# Pop and set output indentation step mode.
#
# This instructions pops an integer from the stack and uses it to
# set the current indentation step in the VM.  The indentation step
# determines how many white characters to use in each indentation
# level when printing output.
#
# Stack: ( INT -- )

instruction popoi ()
  code
    int oindent = PVM_VAL_INT (JITTER_TOP_STACK ());

    PVM_STATE_RUNTIME_FIELD (oindent) = oindent;
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushod
#
# Push output depth.
#
# This instruction pushes a signed integer indicating the depth to use
# when printing PVM values.
#
# Stack: ( -- INT )

instruction pushod ()
  code
    int odepth = PVM_STATE_RUNTIME_FIELD (odepth);
    JITTER_PUSH_STACK (PVM_MAKE_INT (odepth, 32));
  end
end

# Instruction: popod
#
# Pop and set output depth.
#
# This instructions pops a signed integer indicating the maximum depth
# included by the VM when printing values.
#
# Stack: ( INT -- )

instruction popod ()
  code
    int odepth = PVM_VAL_INT (JITTER_TOP_STACK ());

    PVM_STATE_RUNTIME_FIELD (odepth) = odepth;
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushoac
#
# Push output array cutoff.
#
# This instruction pushes a signed integer indicating the number of
# elements that the VM includes in the printed representation of PVM
# array values.
#
# Stack: ( -- INT )

instruction pushoac ()
  code
    int oacutoff = PVM_STATE_RUNTIME_FIELD (oacutoff);
    JITTER_PUSH_STACK (PVM_MAKE_INT (oacutoff, 32));
  end
end

# Instruction: popoac
#
# Pop and set output array cutoff.
#
# This instructions pops a signed integer indicating the number of
# elements that the VM includes in the printed representation of PVM
# array values.
#
# Stack: ( INT -- )

instruction popoac ()
  code
    int oacutoff = PVM_VAL_INT (JITTER_TOP_STACK ());

    PVM_STATE_RUNTIME_FIELD (oacutoff) = oacutoff;
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushopp
#
# Push pretty-print usage.
#
# This instruction pushes a signed integer indicating whether the VM
# is configured to use pretty-printers.
#
# Stack: ( -- INT )

instruction pushopp ()
  code
    int pp = PVM_STATE_RUNTIME_FIELD (pretty_print);
    JITTER_PUSH_STACK (PVM_MAKE_INT (!!pp, 32));
  end
end

# Instruction: popopp
#
# Pop and set usage of pretty-printers.
#
# This instructions pops a signed integer indicating whether to use
# pretty-printers when printing values and sets it in the VM.
#
# Stack: ( INT -- )

instruction popopp ()
  code
    int pp = PVM_VAL_INT (JITTER_TOP_STACK ());

    PVM_STATE_RUNTIME_FIELD (pretty_print) = pp;
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushoc
#
# Push the current output color to the stack, encoded as a
# RGB triplet.
#
# Stack: ( -- INT INT INT )

instruction pushoc ()
  code
    struct pk_color color = pk_term_get_color ();

    JITTER_PUSH_STACK (PVM_MAKE_INT (color.red, 32));
    JITTER_PUSH_STACK (PVM_MAKE_INT (color.green, 32));
    JITTER_PUSH_STACK (PVM_MAKE_INT (color.blue, 32));
  end
end

# Instruction: popoc
#
# Pop the RGB triplet at the top of the stack and use it to set
# the new terminal output color.
#
# Stack: ( INT INT INT -- )

instruction popoc ()
  code
    struct pk_color color;

    color.blue = PVM_VAL_INT (JITTER_TOP_STACK ());
    color.green = PVM_VAL_INT (JITTER_UNDER_TOP_STACK ());
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    color.red = PVM_VAL_INT (JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();

    pk_term_set_color (color);
  end
end

# Instruction: pushobc
#
# Push the current output background color to the stack, encoded as a
# RGB triplet.
#
# Stack: ( -- INT INT INT )

instruction pushobc ()
  code
    struct pk_color color = pk_term_get_bgcolor ();

    JITTER_PUSH_STACK (PVM_MAKE_INT (color.red, 32));
    JITTER_PUSH_STACK (PVM_MAKE_INT (color.green, 32));
    JITTER_PUSH_STACK (PVM_MAKE_INT (color.blue, 32));
  end
end

# Instruction: popobc
#
# Pop the RGB triplet at the top of the stack and use it to set
# the new terminal output background color.
#
# Stack: ( INT INT INT -- )

instruction popobc ()
  code
    struct pk_color color;

    color.blue = PVM_VAL_INT (JITTER_TOP_STACK ());
    color.green = PVM_VAL_INT (JITTER_UNDER_TOP_STACK ());
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    color.red = PVM_VAL_INT (JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();

    pk_term_set_bgcolor (color);
  end
end

# Instruction: sync
#
# Handle pending signals, and raise exceptions accordingly.  This
# instruction should be emitted in strategic places, such as before
# backwards jumps and at function prolog, to assure signals are
# eventually attended to.
#
# Stack: ( -- )
# Exceptions: PVM_E_SIGNAL

instruction sync ()
  branching # because of PVM_RAISE_DIRECT
  code
    /* XXX for now we treat all signals the same way.
       As soon as we support exception arguments, we shall
       pass the mask of signals to the signal handler.  */
    if (JITTER_PENDING_NOTIFICATIONS)
      PVM_RAISE_DFL (PVM_E_SIGNAL);
  end
end


## IOS related instructions

# Instruction: open
#
# Open a new IO space.  The handler string and a set of flags are
# passed on the stack.  The descriptor of the opened IOS is pushed to
# the stack as a signed integer.
#
# If there is no other IO space opened when this instruction is
# executed, then the just opened space becomes the current IO space.
#
# If it is not possible to open the IO space according to the provided
# flags, the PVM_E_IOFLAGS exception is raised.  If there is any other
# error performing the operation, PVM_E_IO is raised.
#
# Stack: ( STR ULONG -- INT )
# Exceptions: PVM_E_IOFLAGS, PVM_E_IO

instruction open ()
  branching # because of PVM_RAISE_DIRECT
  # XXX make non-relocatable: see raise
  code
     char *filename = PVM_VAL_STR (JITTER_UNDER_TOP_STACK ());
     uint64_t flags = PVM_VAL_ULONG (JITTER_TOP_STACK ());

     int ret = ios_open (filename, flags, 0);

     if (ret == IOS_EFLAGS)
       PVM_RAISE_DFL (PVM_E_IOFLAGS);
     else if (ret < IOS_OK)
       PVM_RAISE_DFL (PVM_E_IO);

     JITTER_DROP_STACK ();
     JITTER_TOP_STACK () = PVM_MAKE_INT (ret, 32);
  end
end

# Instruction: close
#
# Close an IO space.  The descriptor of the space to close is provided
# on the stack as a signed integer.
#
# If the specified IO space doesn't exist, this instruction raises
# PVM_E_NO_IOS. If the operation fails, it raises PVM_E_IO.
#
# Stack: ( INT -- )
# Exceptions: PVM_E_NO_IOS, PVM_E_IO

instruction close ()
  branching # because of PVM_RAISE_DIRECT
  # XXX make non-relocatable: see raise
  code
    int io_id = PVM_VAL_INT (JITTER_TOP_STACK ());
    ios io = ios_search_by_id (io_id);

    if (io == NULL)
      PVM_RAISE_DFL (PVM_E_NO_IOS);

    if (ios_close (io) != IOS_OK)
      PVM_RAISE_DFL (PVM_E_IO);

    JITTER_DROP_STACK ();
  end
end

# Instruction: flush
#
#
# Flush an IO space.  The descriptor of the space to flush, and the
# bit-offset up to which perform the flushing are provided on the stack.
#
# If the specified IO space doesn't exist, this instruction raises
# PVM_E_IO.
#
# Stack: ( INT ULONG -- )
# Exceptions: PVM_E_IO

instruction flush ()
  branching # because of PVM_RAISE_DIRECT
  # XXX make non-relocatable: see raise
  code
    ios_off offset = PVM_VAL_ULONG (JITTER_TOP_STACK ());
    int io_id = PVM_VAL_INT (JITTER_UNDER_TOP_STACK ());
    ios io = ios_search_by_id (io_id);

    if (io == NULL)
      PVM_RAISE_DFL (PVM_E_IO);

    if (ios_flush (io, offset) != IOS_OK)
      PVM_RAISE_DFL (PVM_E_IO);

    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushios
#
# Push the descriptor of the current IO space on the stack, as a
# signed integer.  If no IO space is currently opened, raise
# PVM_E_NO_IOS.
#
# Stack: ( -- INT )
# Exceptions: PVM_E_NO_IOS

instruction pushios ()
  branching # because of PVM_RAISE_DIRECT
  # XXX make non-relocatable: see raise
  code
    ios cur_io = ios_cur ();

    if (cur_io == NULL)
       PVM_RAISE_DFL (PVM_E_NO_IOS);
    JITTER_PUSH_STACK (PVM_MAKE_INT (ios_get_id (cur_io), 32));
  end
end

# Instruction: popios
#
# Pop an IO space descriptor from the stack and set it as the current
# IO space.  If the specified descriptor doesn't identify an IO space,
# raise PVM_E_NO_IOS.
#
# Stack: ( INT -- )
# Exceptions: PVM_E_NO_IOS

instruction popios ()
  branching # because of PVM_RAISE_DIRECT
  # XXX make non-relocatable: see raise
  code
    ios io = ios_search_by_id (PVM_VAL_INT (JITTER_TOP_STACK ()));

    if (io == NULL)
      PVM_RAISE_DFL (PVM_E_NO_IOS);
    ios_set_cur (io);
    JITTER_DROP_STACK ();
  end
end

# Instruction: ioflags
#
# Push an unsigned 64-bit integer with the flags of the given IO space
# on the stack.  The IO space is identified by a descriptor, which is
# a signed integer.  If the given IO space doesn't exist, raise
# PVM_E_NO_IOS.
#
# Stack: ( INT -- INT ULONG )
# Exceptions: PVM_E_NO_IOS

instruction ioflags ()
  branching # because of PVM_RAISE_DIRECT
  # XXX make non-relocatable: see raise
  code
    ios io = ios_search_by_id (PVM_VAL_INT (JITTER_TOP_STACK ()));

    if (io == NULL)
      PVM_RAISE_DFL (PVM_E_NO_IOS);

    JITTER_PUSH_STACK (PVM_MAKE_ULONG (ios_flags (io), 64));
  end
end

# Instruction: iosize
#
# Push the size of the given IO space on the stack, as an offset.  The
# IO space is identified by a descriptor, which is a signed integer.
# If the given IO space doesn't exist, raise PVM_E_NO_IOS.
#
# Stack: ( INT -- INT OFF )
# Exceptions: PVM_E_NO_IOS

instruction iosize ()
  branching # because of PVM_RAISE_DIRECT
  # XXX make non-relocatable: see raise
  code
    ios io = ios_search_by_id (PVM_VAL_INT (JITTER_TOP_STACK ()));

    if (io == NULL)
      PVM_RAISE_DFL (PVM_E_NO_IOS);

    JITTER_PUSH_STACK (pvm_make_offset (PVM_MAKE_ULONG (ios_size (io), 64),
                                        PVM_MAKE_ULONG (8, 64)));
  end
end


# Instruction: iogetb
#
# Each IO space has a bias associated with it, which by default is 0
# bits.  This bias is applied to the offset given to every read/write
# operation.
#
# This instruction pushes the bias associated to the given IO space to
# the stack, as an offset.  If the given IO space doesn't exist then
# the exception PVM_E_NO_IOS is raised.
#
# Stack: ( INT - INT OFF )
# Exceptions: PVM_E_NO_IOS

instruction iogetb ()
  branching # because of PVM_RAISE_DIRECT
  # XXX make non-relocatable: see raise
  code
    ios io = ios_search_by_id (PVM_VAL_INT (JITTER_TOP_STACK ()));

    if (io == NULL)
      PVM_RAISE_DFL (PVM_E_NO_IOS);

    uint64_t bias = ios_get_bias (io);
    if (bias % 8 == 0)
      JITTER_PUSH_STACK (pvm_make_offset (PVM_MAKE_ULONG (bias/8, 64),
                                          PVM_MAKE_ULONG (8, 64)));
    else
      JITTER_PUSH_STACK (pvm_make_offset (PVM_MAKE_ULONG (bias, 64),
                                          PVM_MAKE_ULONG (1, 64)));
  end
end

# Instruction: iosetb
#
# Each IO space has a bias associated with it, which by default is 0
# bits.  This bias is applied to the offset given to every read/write
# operation.
#
# This instruction sets the bias associated to the given IO space.
# The bias is specified as an offset.  If the given IO space doesn't
# exist, the exception PVM_E_NO_IOS is raised.
#
# Stack: ( OFF INT -- OFF )
# Exceptions: PVM_E_NO_IOS

instruction iosetb ()
  branching # because of PVM_RAISE_DIRECT
  # XXX make non-relocatable: see raise
  code
    pvm_val bias = JITTER_UNDER_TOP_STACK();
    ios io = ios_search_by_id (PVM_VAL_INT (JITTER_TOP_STACK ()));

    JITTER_DROP_STACK ();

    if (io == NULL)
      PVM_RAISE_DFL (PVM_E_NO_IOS);

    ios_set_bias (io,
                  (PVM_VAL_INTEGRAL (PVM_VAL_OFF_MAGNITUDE (bias))
                   * PVM_VAL_INTEGRAL (PVM_VAL_OFF_UNIT (bias))));
  end
end


## Function management instructions

# Instruction: call
#
# Call a closure on the stack, passing the specified arguments.  After
# the execution of the closure, control is transferred to the
# instruction immediately following the call instruction.
#
# Stack: ( ARG1 ... ARGN CLOSURE -- RETVAL )

instruction call ()
  caller
  code
    pvm_val closure = JITTER_TOP_STACK ();

    assert (PVM_VAL_CLS_ENV (closure) != NULL);
    JITTER_DROP_STACK ();
    PVM_CALL (closure);
  end
end

# Instruction: prolog
#
# Prepare the PVM for the execution of a function.  This instruction
# shall be the target of every `call' instruction and shall be the
# first instruction in every function body.
#
# Stack: ( -- )

instruction prolog ()
  callee
  code
    /* Fill the return stack slot with the return address.  The return
       stack has already been pushesd (with an unspecified value on the
       under top) by the caller. */
    JITTER_UNDER_TOP_RETURNSTACK() = (jitter_uint) JITTER_LINK;
  end
end

# Instruction: return
#
# Return from a function.  A function can have many `return'
# instructions.
#
# Stack: ( -- )

instruction return ()
  returning
  code
    jitter_uint return_address;

    /* Restore the environment of the caller.  Note the cast to
       jitter_uint is to avoid a warning in 32-bit.  */
    jitter_state_runtime.env = (pvm_env) (jitter_uint) JITTER_TOP_RETURNSTACK ();
    JITTER_DROP_RETURNSTACK();

    return_address = JITTER_TOP_RETURNSTACK();
    JITTER_DROP_RETURNSTACK();

    JITTER_RETURN (return_address);
  end
end


## Environment instructions

# Instruction: pushf N
#
# Push a new lexical frame.  If the argument N is bigger than zero, it
# indicates the number of entries in the frame.  If N is 0, it means
# we don't know how many entries will be stored in the frame.
#
# Stack: ( -- )

instruction pushf (?n popf_printer)
  code
    jitter_state_runtime.env
       = pvm_env_push_frame (jitter_state_runtime.env,
                             JITTER_ARGN0);
  end
end

# Instruction: popf N
#
# Pop N lexical frames.
#
# Stack: ( -- )

instruction popf (?n popf_printer)
  code
    jitter_uint i;

    for (i = 0; i < JITTER_ARGU0; ++i)
        jitter_state_runtime.env
           = pvm_env_pop_frame (jitter_state_runtime.env);
  end
end

# Instruction: pushvar BACK, OVER
#
# Retrieve the value of a variable from the lexical environment and
# push it on the stack.  The lexical address of the variable is
# specified as arguments to the instruction.
#
# Stack: ( -- VAL )

instruction pushvar (?n 0, ?n 0 1 2 3 4 5)
  code
    JITTER_PUSH_STACK (pvm_env_lookup (jitter_state_runtime.env,
                                       (int) JITTER_ARGN0,
                                       (int) JITTER_ARGN1));
  end
end

# Instruction: pushtopvar OVER
#
# Retrive the value of a variable from the top-level frame of the
# lexical environment and put it on the stack.  The OVER part of the
# lexical address of the variable is specified as an argument to the
# instruction.
#
# If the variable is not found then raise E_INVAL.
#
# Stack: ( -- VAL )

instruction pushtopvar (?n)
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_env topenv = pvm_env_toplevel (jitter_state_runtime.env);
    pvm_val val = pvm_env_lookup (topenv, 0 /* back */,
                                  (int) JITTER_ARGN0 /* over */);

    if (val == PVM_NULL)
      PVM_RAISE (PVM_E_INVAL, "no top-level variable found",
                 PVM_E_INVAL_ESTATUS);

    JITTER_PUSH_STACK (val);
  end
end

# Instruction: popvar BACK, OVER
#
# Pop a value from the stack and set it as the value of a variable
# having the lexical address specified in the arguments, in the
# current lexical environment.
#
# Stack: ( VAL -- )

instruction popvar (?n, ?n)
  code
    pvm_env_set_var (jitter_state_runtime.env,
                     (int) JITTER_ARGN0,
                     (int) JITTER_ARGN1,
                     JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: regvar
#
# Pop a value from the stack and use it as the value for a new
# variable in the current lexical environment.
#
# Stack: ( VAL -- )

instruction regvar ()
  code
    pvm_env_register (jitter_state_runtime.env,
                      JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: duc
#
# Make a copy of the closure at the top of the stack, and
# replace it.
#
# Stack: ( CLS -- CLS )

instruction duc ()
  code
    pvm_val cls = JITTER_TOP_STACK ();
    pvm_val new_cls = pvm_make_cls (PVM_VAL_CLS_PROGRAM (cls));

    JITTER_DROP_STACK ();
    JITTER_PUSH_STACK (new_cls);
  end
end

# Instruction: pec
#
# Put the current lexical environment to the closure at the top of the
# stack.
#
# Stack: ( CLS -- CLS )

instruction pec ()
  code
    pvm_val cls = JITTER_TOP_STACK ();
    PVM_VAL_CLS_ENV (cls) = jitter_state_runtime.env;
  end
end


## Printing Instructions

# In the following instructions the meaning of the argument BASE is
# the following:
#
# 2 - print the number in binary.
# 8 - print the number in octal.
# 16 - print the number in hexadecimal.
# Any other value - print the number in decimal.

# Instruction: indent
#
# Indent the output in the terminal for LVL levels of indentation,
# using STEP white chars in each indentation level.
#
# LVL is an integer in the under top stack.
# STEP is an integer in the top of the stack.
#
# Stack: ( INT INT -- )

instruction indent ()
  non-relocatable
  code
    pk_term_indent (PVM_VAL_INT (JITTER_UNDER_TOP_STACK ()),
                    PVM_VAL_INT (JITTER_TOP_STACK ()));
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
  end
end

# Instruction: printi BITS
#
# Given a signed integer and a numeration base in the stack, print the
# integer to the terminal.
#
# Stack: ( INT INT -- )

instruction printi (?n popf_printer)
  non-relocatable
  code
    int base = PVM_VAL_INT (JITTER_TOP_STACK ());
    PVM_PRINTI (INT, int32_t, 1 /* signed_p */, base);
  end
end

# Instruction: printiu BITS
#
# Given an unsigned integer and a numeration base in the stack, print
# the integer to the terminal.
#
# Stack: ( UINT INT -- )

instruction printiu (?n popf_printer)
  non-relocatable
  code
    int base = PVM_VAL_INT (JITTER_TOP_STACK ());
    PVM_PRINTI (UINT, uint32_t, 0 /* signed_p */, base);
  end
end

# Instruction: printl BITS
#
# Given a long and a numeration base in the stack, print the integer
# to the terminal.
#
# Stack: ( LONG INT -- )

instruction printl (?n popf_printer)
  non-relocatable
  code
    int base = PVM_VAL_INT (JITTER_TOP_STACK ());
    PVM_PRINTL (LONG, int64_t, 1 /* signed_p */, base);
  end
end

# Instruction: printlu BITS
#
# Given an unsigned long and a numeration base in the stack, print the
# integer to the terminal.
#
# Stack: ( ULONG INT -- )

instruction printlu (?n popf_printer)
  non-relocatable
  code
   int base = PVM_VAL_INT (JITTER_TOP_STACK ());
   PVM_PRINTL (ULONG, uint64_t, 0 /* signed_p */, base);
  end
end

# Instruction: prints
#
# Print the string at the top of the stack.
#
# Stack: ( STR -- )

instruction prints ()
  non-relocatable
  code
    pvm_print_string (JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: beghl
#
# Begin an hyperlink, using the URL and ID on the stack.
#
# Stack: ( STR STR -- )

instruction beghl ()
  non-relocatable
  code
    char *url = PVM_VAL_STR (JITTER_UNDER_TOP_STACK ());
    char *id = PVM_VAL_STR (JITTER_TOP_STACK ());

    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    pk_term_hyperlink (url, id);
  end
end

# Instruction: endhl
#
# End the current hyperlink.
#
# If no hyperlink is currently being generated, this instruction
# raises an exception.
#
# Stack: ( -- )
# Exceptions: PVM_E_GENERIC

instruction endhl ()
  non-relocatable
  branching # because of PVM_RAISE_DIRECT
  code
    if (!pk_term_end_hyperlink ())
      PVM_RAISE (PVM_E_GENERIC,
                 "no current hyperlink",
                 PVM_E_GENERIC_ESTATUS);
  end
end

# Instruction: begsc
#
# Begin the styling class whose name is found on the stack.  This
# class will be in effect in subsequent print operations until it is
# explicitly ended by a `endsc' instruction.
#
# Stack: ( STR -- )

instruction begsc ()
  non-relocatable
  code
    pk_term_class (PVM_VAL_STR (JITTER_TOP_STACK ()));
    JITTER_DROP_STACK ();
  end
end

# Instruction: endsc
#
# End the styling class whose name is found on the stack.  This class
# should have been previously began by a `begsc' instruction.
#
# Stack: ( STR -- )

instruction endsc ()
  non-relocatable
  branching # because of PVM_RAISE_DIRECT
  code
    if (!pk_term_end_class (PVM_VAL_STR (JITTER_TOP_STACK ())))
      PVM_RAISE (PVM_E_INVAL,
                 "invalid class",
                 PVM_E_INVAL_ESTATUS);
    JITTER_DROP_STACK ();
  end
end


## Format Instructions

# In the following instructions the meaning of the argument BASE is
# the following:
#
# 2 - format the number in binary.
# 8 - format the number in octal.
# 16 - format the number in hexadecimal.
# Any other value - format the number in decimal.

# Instruction: formati BITS
#
# Given a signed integer and a numeration base in the stack, push the
# string representation to the stack.
#
# Stack: ( INT INT -- STR )

instruction formati (?n)
  code
    int base = PVM_VAL_INT (JITTER_TOP_STACK ());
    char res[32 + 2 /* suffix */ + 1 /* nul */];

    PVM_FORMATI (res, sizeof (res), INT, int32_t, 1 /* signed_p */, base);
  end
end

# Instruction: formatiu BITS
#
# Given an unsigned integer and a numeration base in the stack, push the
# string representation to the stack.
#
# Stack: ( UINT INT -- STR )

instruction formatiu (?n)
  code
    int base = PVM_VAL_INT (JITTER_TOP_STACK ());
    char res[32 + 2 /* suffix */ + 1 /* nul */];

    PVM_FORMATI (res, sizeof (res), UINT, uint32_t, 0 /* signed_p */, base);
  end
end

# Instruction: formatl BITS
#
# Given a long and a numeration base in the stack, push the string
# representation to the stack.
#
# Stack: ( LONG INT -- STR )

instruction formatl (?n)
  code
    int base = PVM_VAL_INT (JITTER_TOP_STACK ());
    char res[64 + 2 /* suffix */ + 1 /* nul */];

    PVM_FORMATL (res, sizeof (res), LONG, int64_t, 1 /* signed_p */, base);
  end
end

# Instruction: formatlu BITS
#
# Given an unsigned long and a numeration base in the stack, push the
# string representation to the stack.
#
# Stack: ( ULONG INT -- STR )

instruction formatlu (?n)
  code
    int base = PVM_VAL_INT (JITTER_TOP_STACK ());
    char res[64 + 2 /* suffix */ + 1 /* nul */];

    PVM_FORMATL (res, sizeof (res), ULONG, uint64_t, 0 /* signed_p */, base);
  end
end


## Main stack manipulation instructions

# Instruction: push VAL
#
# Push the value given as an argument to the main stack.
#
# Stack: ( -- VAL )

instruction push (?nl pvm_literal_printer)
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK(k);
  end
end

# Instruction: drop
#
# Pop the value at the top of the main stack, and discard it.
#
# Stack: ( VAL -- )

instruction drop ()
  code
    JITTER_DROP_STACK();
  end
end

# Instruction: drop2
#
# Pop the two values at the top of the main stack, and discard them.
#
# Stack: ( VAL VAL -- )

instruction drop2 ()
  code
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
  end
end

# Instruction: drop3
#
# Pop the three values at the top of the main stack, and discard them.
#
# Stack: ( VAL VAL VAL -- )

instruction drop3 ()
  code
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
  end
end

# Instruction: drop4
#
# Pop the four values at the top of the stack, and discard them.
#
# Stack: ( VAL VAL VAL VAL -- )

instruction drop4 ()
  code
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
  end
end

# Instruction: swap
#
# Exchange the two elements at the top of the stack.
#
# Stack: ( A B -- B A)

instruction swap ()
  code
    pvm_val tmp = JITTER_UNDER_TOP_STACK ();
    JITTER_UNDER_TOP_STACK () = JITTER_TOP_STACK ();
    JITTER_TOP_STACK () = tmp;
  end
end

# Instruction: nip
#
# Discard the element at the under top of the main stack.
#
# Stack: ( A B -- B )

instruction nip ()
  code
    JITTER_NIP_STACK();
  end
end

# Instruction: nip2
#
# Discard the two elements at the under top of the main stack.
#
# Stack: ( A B C -- C )

instruction nip2 ()
  code
    JITTER_NIP_STACK ();
    JITTER_NIP_STACK ();
  end
end

# Instruction: nip3
#
# Discard the three elements at the under top of the main stack.
#
# Stack: ( A B C D -- D )

instruction nip3 ()
  code
    JITTER_NIP_STACK ();
    JITTER_NIP_STACK ();
    JITTER_NIP_STACK ();
  end
end

# Instruction: dup
#
# Push a copy of the element at the top of the main stack.
#
# Stack: ( A -- A A )

instruction dup ()
  code
    JITTER_DUP_STACK ();
  end
end

# Instruction: over
#
# Push a copy of the element at the under top of the main stack.
#
# Stack: ( A B -- A B A )

instruction over ()
  code
    JITTER_PUSH_STACK (JITTER_UNDER_TOP_STACK ());
  end
end

# Instruction: rot
#
# Rotate the three elements at the top of the main stack, clock-wise.
#
# Stack: ( A B C -- B C A )

instruction rot ()
  code
    JITTER_ROT_STACK ();
  end
end

# Instruction: nrot
#
# Rotate the three elements at the top of the stack, counter
# clock-wise.
#
# Stack: ( A B C -- C A B )

instruction nrot ()
  code
    JITTER_MROT_STACK ();
  end
end

# Instruction: tuck
#
# Tuck a copy of the element at the top of the stack down two
# positions.
#
# Stack: ( A B -- B A B )

instruction tuck ()
  code
    JITTER_TUCK_STACK ();
  end
end

# Instruction: quake
#
# Swap the two elements at the under top of the stack.
#
# Stack: ( A B C - B A C )

instruction quake ()
  code
    JITTER_QUAKE_STACK ();
  end
end

# Instruction: revn N
#
# Reverse the N elements at the top of the stack.
#
# Stack: ( VAL... -- VAL... )

instruction revn (?n 3 4 popf_printer)
  code
    JITTER_REVERSE_STACK (JITTER_ARGU0);
  end
end

# Instruction: pushhi VAL
#
# Push the high 32 bits of the value passed as an argument to the main
# stack.  This instruction shall be completed with a `pushlo'.
#
# This instruction is a workaround to a limitation of Jitter.
#
# Stack: ( -- HI32(VAL) )

instruction pushhi (?nl pvm_literal_printer_hi)
  code
     jitter_state_runtime.push_hi
       = JITTER_ARGN0;
  end
end

# Instruction: pushlo VAL
#
# Push the low 32 bits of the value passed as an argument to the main
# stack.  This instruction shall be preceded by a `pushhi'.
#
# This instruction is a workaround to a limitation of Jitter.
#
# Stack: ( -- LO32(VAL) )

instruction pushlo (?nl pvm_literal_printer_lo)
  code
     pvm_val k
       = ((pvm_val) jitter_state_runtime.push_hi << 32)
         | JITTER_ARGN0;
     JITTER_PUSH_STACK (k);
  end
end

# Instruction: push32 VAL
#
# Push the value passed as an argument on the stack.  This assumes
# that the internal representation of VAL doesn't require more than
# 32-bit.
#
# This instruction is a workaround to a limitation of Jitter.
#
# Stack: ( -- VAL )

instruction push32 (?nl pvm_literal_printer)
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK (k);
  end
end


## Registers manipulation instructions

# Instruction: pushr REGNO
#
# Push the contents of the register REGNO on the stack.
#
# Stack: ( -- VAL )

instruction pushr (?R)
  code
    JITTER_PUSH_STACK (JITTER_ARG0);
  end
end

# Instruction: popr REGNO
#
# Pop the element at the top of the stack and put it in the
# register REGNO.
#
# Stack: ( VAL -- )

instruction popr (!R)
  code
    JITTER_ARG0 = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
  end
end

# Instruction: setr REGNO
#
# Set the element at the top of the stack to the value of the
# register REGNO.
#
# Stack: ( -- )

instruction setr (!R)
  code
    JITTER_ARG0 = JITTER_TOP_STACK();
  end
end


## Return stack manipulation instructions

# Instruction: saver REGNO
#
# Push the contents of the register REGNO to the return stack.
#
# Stack: ( -- )
# ReturnStack: ( -- VAL )

instruction saver (?R)
  code
    JITTER_PUSH_RETURNSTACK (JITTER_ARG0);
  end
end

# Instruction: restorer REGNO
#
# Pop the element at the top of the return stack and put it in the
# register REGNO.
#
# Stack: ( -- )
# ReturnStack: ( VAL -- )

instruction restorer (!R)
  code
    JITTER_ARG0 = JITTER_TOP_RETURNSTACK ();
    JITTER_DROP_RETURNSTACK ();
  end
end

# Instruction: tor
#
# Pop an element from the stack and push it in the return stack.
#
# Stack: ( VAL -- )
# ReturnStack: ( -- VAL )

instruction tor ()
  code
    JITTER_PUSH_RETURNSTACK (JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: fromr
#
# Pop an element from the return stack and push it on the stack.
#
# Stack: ( -- VAL)
# ReturnStack: ( VAL -- )

instruction fromr ()
  code
    JITTER_PUSH_STACK (JITTER_TOP_RETURNSTACK ());
    JITTER_DROP_RETURNSTACK ();
  end
end

# Instruction: atr
#
# Push a copy of the element at the top of the return stack into the
# stack.
#
# Stack: ( -- VAL )

instruction atr ()
  code
    JITTER_PUSH_STACK (JITTER_TOP_RETURNSTACK ());
  end
end


## Arithmetic instructions

# The following instructions assume that both operands have the same
# size in bits.

# Instruction: addi
#
# Push the result of adding the two integers at the top of the stack.
# If the operation would result in overflow, raise PVM_E_OVERFLOW.
#
# Stack: ( INT INT -- INT INT INT )
# Exceptions: PVM_E_OVERFLOW

instruction addi ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_ADD_SIGNED (INT,int);
  end
end

# Instruction: addiu
#
# Push the result of adding the two unsigned integers at the top of
# the stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction addiu ()
  # branching # because of PVM_RAISE_DIRECT
  code
    PVM_BINOP (UINT, UINT, UINT, +);
  end
end

# Instruction addl
#
# Push the result of adding the two longs at the top of the stack.
# If the operation would result in overflow, raise PVM_E_OVERFLOW.
#
# Stack: ( LONG LONG -- LONG LONG LONG )
# Exceptions: PVM_E_OVERFLOW

instruction addl ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_ADD_SIGNED (LONG, int64_t);
  end
end

# Instruction: addlu
#
# Push the result of adding the two unsigned longs at the top of
# the stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction addlu ()
  # branching # because of PVM_RAISE_DIRECT
  code
    PVM_BINOP (ULONG, ULONG, ULONG, +);
  end
end

# Instruction: subi
#
# Push the result of subtracting the two integers at the top of
# the stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction subi ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_SUB_SIGNED (INT, int);
  end
end

# Instruction: subiu
#
# Push the result of subtracting the two unsigned integers at the
# top of the stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction subiu ()
  # branching # because of PVM_RAISE_DIRECT
  code
    PVM_BINOP (UINT, UINT, UINT, -);
  end
end

# Instruction: subl
#
# Push the result of subtracting the two longs at the top
# of the stack.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction subl ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_SUB_SIGNED (LONG, int64_t);
  end
end

# Instruction: sublu
#
# Push the result of subtracting the two unsigned longs at the
# top of the stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction sublu ()
  # branching # because of PVM_RAISE_DIRECT
  code
    PVM_BINOP (ULONG, ULONG, ULONG, -);
  end
end

# Instruction: muli
#
# Push the result of multiplying the two integers at the top of the
# stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction muli ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_MUL_SIGNED (INT, int);
  end
end

# Instruction: muliu
#
# Push the result of multiplying the two unsigned integers at the
# top of the stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction muliu ()
  # branching # because of PVM_RAISE_DIRECT
  code
    PVM_BINOP (UINT, UINT, UINT, *);
  end
end

# Instruction: mull
#
# Push the result of multiplying the two longs at the top of the
# stack.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction mull ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_MUL_SIGNED (LONG, int64_t);
  end
end

# Instruction: mullu
#
# Push the result of multiplying the two unsigned longs at the top
# of the stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction mullu ()
  # branching # because of PVM_RAISE_DIRECT
  code
    PVM_BINOP (ULONG, ULONG, ULONG, *);
  end
end

# Instruction: divi
#
# Push the result of the integer division of the two integers at the
# top of the stack.  If the denominator is zero, raise
# PVM_E_DIV_BY_ZERO.
#
# Stack: ( INT INT -- INT INT INT )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction divi ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_DIV_SIGNED (INT, int);
  end
end

# Instruction: diviu
#
# Push the result of the integer division of the two unsigned integers
# at the top of the stack.  If the denominator is zero, raise
# PVM_E_DIV_BY_ZERO.
#
# Stack: ( UINT UINT -- UINT UINT UINT )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction diviu ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_CHECKED_BINOP (UINT, UINT, UINT, /);
  end
end

# Instruction: divl
#
# Push the result of the integer division of the two longs at the top
# of the stack.  If the denominator is zero, raise PVM_E_DIV_BY_ZERO.
#
# Stack: ( LONG LONG -- LONG LONG LONG )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction divl ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_DIV_SIGNED (LONG, int64_t);
  end
end

# Instruction: divlu
#
# Push the result of the integer division of the two unsigned
# longs at the top of the stack.  If the denominator is zero,
# raise PVM_E_DIV_BY_ZERO.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction divlu ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_CHECKED_BINOP (ULONG, ULONG, ULONG, /);
  end
end

# Instruction: modi
#
# Push the result of the modulus of the two integers at the top of the
# stack.  If the denominator is zero, raise PVM_E_DIV_BY_ZERO.
#
# Stack: ( INT INT -- INT INT INT )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction modi ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_MOD_SIGNED (INT, int);
  end
end

# Instruction: modiu
#
# Push the result of the modulus of the two unsigned integers at the
# top of the stack.  If the denominator is zero, raise
# PVM_E_DIV_BY_ZERO.
#
# Stack: ( UINT UINT -- UINT UINT UINT )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction modiu ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_CHECKED_BINOP (UINT, UINT, UINT, %);
  end
end

# Instruction: modl
#
# Push the result of the modulus of the two longs at the top of the
# stack.  If the denominator is zero, raise PVM_E_DIV_BY_ZERO.
#
# Stack: ( LONG LONG -- LONG LONG LONG )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction modl ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_MOD_SIGNED (LONG, int64_t);
  end
end

# Instruction: modlu
#
# Push the result of the modulus of the two unsigned longs at the top
# of the stack.  If the denominator is zero, raise PVM_E_DIV_BY_ZERO.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction modlu ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_CHECKED_BINOP (ULONG, ULONG, ULONG, %);
  end
end

# Instruction: negi
#
# Push the result of the negation of the integer at the top of the
# stack.
#
# Stack: ( INT -- INT INT )

instruction negi ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_NEG_SIGNED (INT, int);
  end
end

# Instruction: negiu
#
# Push the result of the negation of the unsigned integer at the
# top of the stack.
#
# Stack: ( UINT -- UINT UINT UINT )

instruction negiu ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_UNOP (UINT, UINT, uint, -);
  end
end

# Instruction: negl
#
# Push the result of the negation of the long at the top of the
# stack.
#
# Stack: ( LONG -- LONG LONG )

instruction negl ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_NEG_SIGNED (LONG, int64_t);
  end
end

# Instruction: neglu
#
# Push the result of the negation of the unsigned long at the top of
# the stack.
#
# Stack: ( ULONG -- ULONG ULONG )

instruction neglu ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_UNOP (ULONG, ULONG, ulong, -);
  end
end

# Instruction: powi
#
# Perform the exponentiation of the integer at the under top of the
# stack.  The exponent is the unsigned integer at the top of the
# stack.  If the exponent is 0, the result is 1.
#
# Stack: ( INT UINT -- INT UINT INT )

instruction powi ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_POWOP_SIGNED (INT,int64_t,int);
  end
end

# Instruction: powiu
#
# Perform the exponentiation of the unsigned integer at the under top
# of the stack.  The exponent is the unsigned integer at the top of
# the stack.  If the exponent is 0, the result is 1.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction powiu ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_POWOP (UINT,uint64_t,uint);
  end
end

# Instruction: powl
#
# Perform the exponentiation of the long at the under top of the
# stack.  The exponent is the unsigned integer at the top of the
# stack.  If the exponent is 0, the result is 1.
#
# Stack: ( LONG UINT -- LONG UINT LONG )

instruction powl ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_POWOP_SIGNED (LONG,int64_t,long);
  end
end

# Instruction: powlu
#
# Perform the exponentiation of the unsigned long at the under top of
# the stack.  The exponent is the unsigned integer at the top of the
# stack.  If the exponent is 0, the result is 1.
#
# Stack: ( ULONG UINT -- ULONG UINT ULONG )

instruction powlu ()
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_POWOP (ULONG,uint64_t,ulong);
  end
end


## Relational instructions

# Instruction: eqi
#
# Push 1 on the stack if the two integers at the top of the stack are
# equal.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction eqi ()
  code
     PVM_BOOL_BINOP (INT, ==);
  end
end

# Instruction: eqiu
#
# Push 1 on the stack if the two unsigned integers at the top of the
# stack are equal.  Otherwise push 0.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction eqiu ()
  code
     PVM_BOOL_BINOP (UINT, ==);
  end
end

# Instruction: eql
#
# Push 1 on the stack if the two longs at the top of the stack are
# equal.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction eql ()
  code
     PVM_BOOL_BINOP (LONG, ==);
  end
end

# Instruction: eqlu
#
# Push 1 on the stack if the two unsigned longs at the top of the
# stack are equal.  Otherwise push 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction eqlu ()
  code
     PVM_BOOL_BINOP (ULONG, ==);
  end
end

# Instruction: eqs
#
# Push 1 on the stack if the two strings at the top of the stack are
# equal.  Otherwise push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction eqs ()
  code
    pvm_val res = PVM_MAKE_INT (STREQ (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                       PVM_VAL_STR (JITTER_TOP_STACK ())),
                                32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: nei
#
# Push 1 on the stack if the two integers at the top of the stack are
# not equal.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction nei ()
  code
     PVM_BOOL_BINOP (INT, !=);
  end
end

# Instruction: neiu
#
# Push 1 on the stack if the two unsigned integers at the top of the
# stack are not equal.  Otherwise push 0.
#
# Stack: ( UINT UINT -- UINT UINT INT )

instruction neiu ()
  code
     PVM_BOOL_BINOP (UINT, !=);
  end
end

# Instruction: nel
#
# Push 1 on the stack if the two longs at the top of the stack are not
# equal.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction nel ()
  code
     PVM_BOOL_BINOP (LONG, !=);
  end
end

# Instruction: nelu
#
# Push 1 on the stack if the two unsigned longs at the top of the
# stack are not equal.  Otherwise push 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction nelu ()
  code
     PVM_BOOL_BINOP (ULONG, !=);
  end
end

# Instruction: nes
#
# Push 1 on the stack if the two strings at the top of the stack are
# not equal.  Otherwise push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction nes ()
  code
    pvm_val res = PVM_MAKE_INT (STRNEQ (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())),
                                32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: nn
#
# Push 0 on the stack if the value at the top of the stack equals
# PVM_NULL.  Otherwise push 1.
#
# Stack: ( VAL -- VAL INT )

instruction nn ()
  code
     JITTER_PUSH_STACK (PVM_MAKE_INT (JITTER_TOP_STACK () != PVM_NULL,
                                      32));
  end
end

# Instruction: nnn
#
# Push 1 on the stack if the value at the top of the stack equals
# PVM_NULL.  Otherwise push 0.
#
# Stack: ( VAL -- VAL INT )

instruction nnn ()
  code
     JITTER_PUSH_STACK (PVM_MAKE_INT (JITTER_TOP_STACK () == PVM_NULL,
                                      32));
  end
end

# Instruction: lti
#
# Push 1 on the stack if the integer at the under top is less that the
# integer at the top.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction lti ()
  code
     PVM_BOOL_BINOP (INT, <);
  end
end

# Instruction: ltiu
#
# Push 1 on the stack if the unsigned integer at the under top is less
# that the unsigned integer at the top.  Otherwise push 0.
#
# Stack: ( UINT INT -- UINT UINT INT )

instruction ltiu () # ( UINT UINT -- UINT UINT INT )
  code
     PVM_BOOL_BINOP (UINT, <);
  end
end

# Instruction: ltl
#
# Push 1 on the stack if the long at the under top is less that the
# long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction ltl () # ( LONG LONG -- LONG LONG INT )
  code
     PVM_BOOL_BINOP (LONG, <);
  end
end

# Instruction: ltlu
#
# Push 1 on the stack if the unsigned long at the under top is less
# that the unsigned long at the top.  Otherwise push 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction ltlu ()
  code
     PVM_BOOL_BINOP (ULONG, <);
  end
end

# Instruction: lei
#
# Push 1 on the stack if the integer at the under top is less or equal
# that the integer at the top.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction lei () # ( INT INT -- INT INT INT )
  code
     PVM_BOOL_BINOP (INT, <=);
  end
end

# Instruction: leiu
#
# Push 1 on the stack if the unsigned integer at the under top is less
# or equal that the unsigned integer at the top.  Otherwise push 0.
#
# Stack: ( UINT UINT -- UINT UINT INT )

instruction leiu () # ( UINT UINT -- UINT UINT INT )
  code
     PVM_BOOL_BINOP (UINT, <=);
  end
end

# Instruction: lel
#
# Push 1 on the stack if the long at the under top is less or equal
# that the long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction lel () # ( LONG LONG -- LONG LONG INT )
  code
     PVM_BOOL_BINOP (LONG, <=);
  end
end

# Instruction: lelu
#
# Push 1 on the stack if the unsigned long at the under top is less or
# equal that the unsigned long at the top.  Otherwise push 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction lelu ()
  code
     PVM_BOOL_BINOP (ULONG, <=);
  end
end

# Instruction: gti
#
# Push 1 on the stack if the integer at the under top is greater than
# the integer at the top.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction gti ()
  code
     PVM_BOOL_BINOP (INT, >);
  end
end

# Instruction: gtiu
#
# Push 1 on the stack if the unsigned integer at the under top is
# greater than the unsigned integer at the top.  Otherwise push 0.
#
# Stack: ( UINT UINT -- UINT UINT INT )

instruction gtiu ()
  code
     PVM_BOOL_BINOP (UINT, >);
  end
end

# Instruction: gtl
#
# Push 1 on the stack if the long at the under top is greater than the
# long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction gtl ()
  code
     PVM_BOOL_BINOP (LONG, >);
  end
end

# Instruction: gtlu
#
# Push 1 on the stack if the unsigned long at the under top is greater
# than the unsigned long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction gtlu ()
  code
     PVM_BOOL_BINOP (ULONG, >);
  end
end

# Instruction: gei
#
# Push 1 on the stack if the integer at the under top is greater or
# equal than the integer at the top.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction gei ()
  code
     PVM_BOOL_BINOP (INT, >=);
  end
end

# Instruction: geiu
#
# Push 1 on the stack if the unsigned integer at the under top is
# greater or equal than the unsigned integer at the top.  Otherwise
# push 0.
#
# Stack: ( UINT UINT -- UINT UINT INT )

instruction geiu ()
  code
     PVM_BOOL_BINOP (UINT, >=);
  end
end

# Instruction: gel
#
# Push 1 on the stack if the long at the under top is greater or equal
# than the long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction gel ()
  code
     PVM_BOOL_BINOP (LONG, >=);
  end
end

# Instruction: gelu
#
# Push 1 on the stack if the unsigned long at the under top is greater
# or equal than the unsigned long at the top.  Otherwise push 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction gelu ()
  code
     PVM_BOOL_BINOP (ULONG, >=);
  end
end

# Instruction: lts
#
# Push 1 on the stack if the string at the under top is less than the
# string at the top, in lexicographic order.  Otherwise push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction lts ()
  code
    pvm_val res = PVM_MAKE_INT (strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())) < 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: gts
#
# Push 1 on the stack if the string at the under top is greater than
# the string at the top, in lexicographic order.  Otherwise push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction gts ()
  code
    pvm_val res = PVM_MAKE_INT (strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())) > 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: ges
#
# Push 1 on the stack if the string at the under top is greater or
# equal than the string at the top, in lexicographic order.  Otherwise
# push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction ges ()
  code
    pvm_val res = PVM_MAKE_INT (strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())) >= 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: les
#
# Push 1 on the stack if the string at the under top is less or equal
# than the string at the top, in lexicographic order.  Otherwise push
# 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction les ()
  code
    pvm_val res = PVM_MAKE_INT (strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                        PVM_VAL_STR (JITTER_TOP_STACK ())) <= 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: eqc
#
# Push 1 on the stack if the two closures at the top of the stack are
# equal.  Otherwise push 0.
#
# Stack: ( CLS CLS -- CLS CLS INT )

instruction eqc ()
  code
    pvm_val res = PVM_MAKE_INT (JITTER_UNDER_TOP_STACK ()
                                == JITTER_TOP_STACK (),
                                32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: nec
#
# Push 1 on the stack if the two closures at the top of the stack are
# not equal.  Otherwise push 0.
#
# Stack: ( CLS CLS -- CLS CLS INT )

instruction nec ()
  code
    pvm_val res = PVM_MAKE_INT (JITTER_UNDER_TOP_STACK ()
                                != JITTER_TOP_STACK (),
                                32);
    JITTER_PUSH_STACK (res);
  end
end


## Concatenation instructions

# Instruction: sconc
#
# Push the concatenation of the two strings at the top of the stack.
#
# Stack: ( STR STR -- STR STR STR )

instruction sconc ()
  code
     pvm_val res;
     char *sa = PVM_VAL_STR (JITTER_UNDER_TOP_STACK ());
     char *sb = PVM_VAL_STR (JITTER_TOP_STACK ());
     char *s = pvm_alloc (strlen (sa) + strlen (sb) + 1);
     strcpy (s, sa);
     strcat (s, sb);
     res = pvm_make_string_nodup (s);

     JITTER_PUSH_STACK (res);
  end
end


## Logical instructions

# Instruction: and
#
# Push the logical and of the two elements at the top of the stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction and ()
  code
    PVM_BOOL_BINOP (INT, &&);
  end
end

# Instruction: or
#
# Push the logical or of the two elements at the top of the stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction or ()
  code
    PVM_BOOL_BINOP (INT, ||);
  end
end

# Instruction: not
#
# Push the logical not of the element at the top of the stack.
#
# Stack: ( INT -- INT INT )

instruction not ()
  code
    pvm_val res = PVM_MAKE_INT (! PVM_VAL_INT (JITTER_TOP_STACK ()), 32);
    JITTER_PUSH_STACK (res);
  end
end


## Bitwise instructions

# Instruction: bxori
#
# Push the bitwise exclusive or of the two integers at the top of the
# stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction bxori ()
  code
    PVM_BINOP (INT, INT, INT, ^);
  end
end

# Instruction: bxoriu
#
# Push the bitwise exclusive or of the two unsigned integers at the
# top of the stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction bxoriu ()
  code
    PVM_BINOP (UINT, UINT, UINT, ^);
  end
end

# Instruction: bxorl
#
# Push the bitwise exclusive or of the two longs at the top of the
# stack.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction bxorl ()
  code
    PVM_BINOP (LONG, LONG, LONG, ^);
  end
end

# Instruction: bxorlu
#
# Push the bitwise exclusive or of the two unsigned longs at the top
# of the stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction bxorlu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, ^);
  end
end

# Instruction: bori
#
# Push the bitwise or of the two integers at the top of the stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction bori ()
  code
    PVM_BINOP (INT, INT, INT, |);
  end
end

# Instruction: boriu
#
# Push the bitwise or of the two unsigned integers at the top of the
# stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction boriu ()
  code
    PVM_BINOP (UINT, UINT, UINT, |);
  end
end

# Instruction: borl
#
# Push the bitwise or of the two longs at the top of the stack.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction borl ()
  code
    PVM_BINOP (LONG, LONG, LONG, |);
  end
end

# Instruction: borlu
#
# Push the bitwise or of the two longs at the top of the stack.
#
# Stack: ( ULONG ULONG  -- ULONG ULONG ULONG )

instruction borlu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, |);
  end
end

# Instruction: bandi
#
# Push the bitwise and of the two integers at the top of the stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction bandi ()
  code
    PVM_BINOP (INT, INT, INT, &);
  end
end

# Instruction: bandiu
#
# Push the bitwise and of the two unsigned integers at the top of the
# stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction bandiu ()
  code
    PVM_BINOP (UINT, UINT, UINT, &);
  end
end

# Instruction: bandl
#
# Push the bitwise and of the two longs at the top of the stack.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction bandl ()
  code
    PVM_BINOP (LONG, LONG, LONG, &);
  end
end

# Instruction: bandlu
#
# Push the bitwise and of the two unsigned longs at the top of the
# stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction bandlu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, &);
  end
end

# Instruction: bnoti
#
# Push the bitwise not of the integer at the top of the stack.
#
# Stack: ( INT -- INT INT INT )

instruction bnoti ()
  code
    PVM_UNOP (INT, INT, int, ~);
  end
end

# Instruction: bnotiu
#
# Push the bitwise not of the unsigned integer at the top of the
# stack.
#
# Stack: ( UINT -- UINT UINT )

instruction bnotiu ()
  code
    PVM_UNOP (UINT, UINT, uint, ~);
  end
end

# Instruction: bnotl
#
# Push the bitwise not of the long at the top of the stack.
#
# Stack: ( LONG -- LONG LONG )

instruction bnotl () # ( LONG -- LONG LONG )
  code
    PVM_UNOP (LONG, LONG, long, ~);
  end
end

# Instruction: bnotlu
#
# Push the bitwise not of the unsigned long at the top of the stack.
#
# Stack: ( ULONG -- ULONG ULONG )

instruction bnotlu ()
  code
    PVM_UNOP (ULONG, ULONG, ulong, ~);
  end
end


## Shift instructions

# Instruction: bsli
#
# Left-shift the integer at the under top of the stack the number of
# bits indicated by the unsigned int at the top of the stack.
#
# If the bit count is equal or bigger than the size of the left
# operand, then raise PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( INT UINT -- INT UINT INT )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction bsli () # ( INT UINT -- INT UINT INT )
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_BINOP_SL (INT, UINT, INT, <<);
  end
end

# Instruction: bsliu
#
# Left-shift the unsigned integer at the under top of the stack the
# number of bits indicated by the unsigned int at the top of the
# stack.
#
# If the bit count is equal or bigger than the size of the left
# operand, then raise PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( UINT UINT -- UINT UINT UINT )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction bsliu () # ( UINT UINT -- UINT UINT UINT )
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_BINOP_SL (UINT, UINT, UINT, <<);
  end
end

# Instruction: bsll
#
# Left-shift the long at the under top of the stack the number of bits
# indicated by the unsigned int at the top of the stack.
#
# If the bit count is equal or bigger than the size of the left
# operand, then raise PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( LONG UINT -- LONG UINT LONG )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction bsll () # ( LONG UINT -- LONG UINT LONG )
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_BINOP_SL (LONG, UINT, LONG, <<);
  end
end

# Instruction: bslu
#
# Left-shift the unsigned long at the under top of the stack the
# number of bits indicated by the unsigned int at the top of the
# stack.
#
# If the bit count is equal or bigger than the size of the left
# operand, then raise PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( ULONG UINT -- ULONG UINT ULONG )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction bsllu () # ( ULONG UINT -- ULONG UINT ULONG )
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_BINOP_SL (ULONG, UINT, ULONG, <<);
  end
end

# Instruction: bsri
#
# Right-shift the integer at the under top of the stack the number of
# tis indicated by the unsigned int at the top of the stack.
#
# Stack: ( INT UINT -- INT UINT INT )

instruction bsri ()
  code
    PVM_BINOP (INT, UINT, INT, >>);
  end
end

# Instruction: bsriu
#
# Right-shift the unsigned integer at the under top of the stack the
# number of tis indicated by the unsigned int at the top of the stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction bsriu ()
  code
    PVM_BINOP (UINT, UINT, UINT, >>);
  end
end

# Instruction: bsrl
#
# Right-shift the long at the under top of the stack the number of tis
# indicated by the unsigned int at the top of the stack.
#
# Stack: ( LONG UINT -- LONG UINT LONG )

instruction bsrl ()
  code
    PVM_BINOP (LONG, UINT, LONG, >>);
  end
end

# Instruction: bsrlu
#
# Right-shift the unsigned long at the under top of the stack the
# number of tis indicated by the unsigned int at the top of the stack.
#
# Stack: ( ULONG UINT -- ULONG UINT ULONG )

instruction bsrlu ()
  code
    PVM_BINOP (ULONG, UINT, ULONG, >>);
  end
end


## Compare-and-swap instructions

# Instruction: swapgti
#
# Swap the two integers at the top of the stack if the element at the
# under-top is greater than the element at the top.
#
# Stack: ( INT INT -- INT INT )

instruction swapgti ()
  code
     pvm_val a = JITTER_UNDER_TOP_STACK ();
     pvm_val b = JITTER_TOP_STACK ();
     if (PVM_VAL_INT (a) > PVM_VAL_INT (b))
     {
       JITTER_UNDER_TOP_STACK () = b;
       JITTER_TOP_STACK () = a;
     }
  end
end

# Instruction: swapgtiu
#
# Swap the two unsigned integers at the top of the stack if the
# element at the under-top is greater than the element at the top.
#
# Stack: ( UINT UINT -- UINT UINT )

instruction swapgtiu ()
  code
     pvm_val a = JITTER_UNDER_TOP_STACK ();
     pvm_val b = JITTER_TOP_STACK ();
     if (PVM_VAL_UINT (a) > PVM_VAL_UINT (b))
     {
       JITTER_UNDER_TOP_STACK () = b;
       JITTER_TOP_STACK () = a;
     }
  end
end

# Instruction: swapgtl
#
# Swap the two longs at the top of the stack if the element at the
# under-top is greater than the element at the top.
#
# Stack: ( LONG LONG -- LONG LONG )

instruction swapgtl ()
  code
     pvm_val a = JITTER_UNDER_TOP_STACK ();
     pvm_val b = JITTER_TOP_STACK ();
     if (PVM_VAL_LONG (a) > PVM_VAL_LONG (b))
     {
       JITTER_UNDER_TOP_STACK () = b;
       JITTER_TOP_STACK () = a;
     }
  end
end

# Instruction: swapgtlu
#
# Swap the two unsigned longs at the top of the stack if the element
# at the under-top is greater than the element at the top.
#
# Stack: ( ULONG ULONG -- ULONG ULONG )

instruction swapgtlu ()
  code
     pvm_val a = JITTER_UNDER_TOP_STACK ();
     pvm_val b = JITTER_TOP_STACK ();
     if (PVM_VAL_ULONG (a) > PVM_VAL_ULONG (b))
     {
       JITTER_UNDER_TOP_STACK () = b;
       JITTER_TOP_STACK () = a;
     }
  end
end


## Branch instructions

# Instruction: ba LABEL
#
# Branch unconditionally to the given LABEL.
#
# Stack: ( -- )

instruction ba (?f)
  branching
  code
    JITTER_BRANCH_FAST(JITTER_ARGF0);
  end
end

# Instruction: bn LABEL
#
# Branch to the given LABEL if the value at the top of the stack is
# PVM_NULL.
#
# Stack: ( VAL -- VAL )

instruction bn (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (tmp != PVM_NULL, JITTER_ARGF0);
  end
end

# Instruction: bnn LABEL
#
# Branch to the given LABEL if the value at the top of the stack is
# not PVM_NULL.
#
# Stack: ( VAL -- VAL )

instruction bnn (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (tmp == PVM_NULL, JITTER_ARGF0);
  end
end

# Instruction: bzi LABEL
#
# Branch to the given LABEL if the integer at the top of the stack is
# zero.
#
# Stack: ( INT -- INT )

instruction bzi (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_INT (tmp), JITTER_ARGF0);
  end
end

# Instruction: bziu LABEL
#
# Branch to the given LABEL if the unsigned integer at the top of
# the stack is zero.
#
# Stack: ( UINT -- UINT )

instruction bziu (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_UINT (tmp), JITTER_ARGF0);
  end
end

# Instruction: bzl LABEL
#
# Branch to the given LABEL if the long at the top of the stack
# is zero.
#
# Stack: ( LONG -- LONG )

instruction bzl (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_LONG (tmp), JITTER_ARGF0);
  end
end

# Instruction: bzlu LABEL
#
# Branch to the given LABEL if the unsigned long at the top of the
# stack is zero.
#
# Stack: ( ULONG -- ULONG )

instruction bzlu (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_ULONG (tmp), JITTER_ARGF0);
  end
end

# Instruction: bnzi LABEL
#
# Branch to the given LABEL if the integer at the top of the stack
# is nonzero.
#
# Stack: ( INT -- INT )

instruction bnzi (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_INT (tmp), JITTER_ARGF0);
  end
end

# Instruction: bnziu LABEL
#
# Branch to the given LABEL if the unsigned integer at the top of the
# stack is nonzero.
#
# Stack: ( UINT -- UINT )

instruction bnziu (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_UINT (tmp), JITTER_ARGF0);
  end
end

# Instruction: bnzl LABEL
#
# Branch to the given LABEL if the long at the top of the stack is
# nonzero.
#
# Stack: ( LONG -- LONG )

instruction bnzl (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_LONG (tmp), JITTER_ARGF0);
  end
end

# Instruction: bnzlu LABEL
#
# Branch to the given LABEL if the unsigned long at the top of the
# stack is nonzero.
#
# Stack: ( ULONG -- ULONG )

instruction bnzlu (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_ULONG (tmp), JITTER_ARGF0);
  end
end


## Conversion instructions

# Instruction: ctos
#
# Convert the character encoded as an unsigned integer at the top of
# the stack to a string that contains just that character.
#
# Stack: ( UINT -- UINT STR )

instruction ctos ()
  code
    uint8_t c = PVM_VAL_UINT (JITTER_TOP_STACK ());
    char *str = pvm_alloc (2);
    str[0] = c;
    str[1] = '\0';

    JITTER_PUSH_STACK (pvm_make_string_nodup (str));
  end
end

# Instruction: itoi NBITS
#
# Convert the integer at the top of the stack to an integer
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( INT -- INT INT )

instruction itoi (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (INT, int32_t, int, int32_t);
  end
end

# Instruction: itoiu NBITS
#
# Convert the integer at the top of the stack to an unsigned integer
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( INT -- INT UINT )

instruction itoiu (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (INT, int32_t, uint, uint32_t);
  end
end

# Instruction: itol NBITS
#
# Convert the integer at the top of the stack to a long featuring
# NBITS bits.
#
# NBITS can be any number from 1 to 64.
#
# Stack: ( INT -- INT LONG )

instruction itol (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (INT, int32_t, long, int64_t);
  end
end

# Instruction: itolu NBITS
#
# Convert the integer at the top of the stack to an unsigned long
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 64.
#
# Stack: ( INT -- INT ULONG )

instruction itolu (?n pvm_literal_printer_cast) # ( INT -- INT ULONG )
  code
    PVM_CONVOP (INT, int32_t, ulong, uint64_t);
  end
end

# Instruction: iutoi NBITS
#
# Convert the unsigned integer at the top of the stack to an integer
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( UINT -- UINT INT )

instruction iutoi (?n pvm_literal_printer_cast) # ( UINT -- UINT INT )
  code
    PVM_CONVOP (UINT, uint32_t, int, int32_t);
  end
end

# Instruction: iutoiu NBITS
#
# Convert the unsigned integer at the top of the stack to an unsigned
# integer featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( UINT -- UINT UINT )

instruction iutoiu (?n pvm_literal_printer_cast) # ( UINT -- UINT UINT )
  code
    PVM_CONVOP (UINT, uint32_t, uint, uint32_t);
  end
end

# Instruction: iutol NBITS
#
# Convert the unsigned integer at the top of the stack to a long
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 64.
#
# Stack: ( UINT -- UINT LONG )

instruction iutol (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (UINT, uint32_t, long, int64_t);
  end
end

# Instruction: iutolu NBITS
#
# Convert the unsigned integer at the top of the stack to an
# unsigned long featuring NBITS bits.
#
# NBITS can be any number from 1 to 64.
#
# Stack: ( UINT -- UINT ULONG )

instruction iutolu (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (UINT, uint32_t, ulong, uint64_t);
  end
end

# Instruction: ltoi NBITS
#
# Convert the long at the top of the stack to an integer
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( LONG -- LONG INT )

instruction ltoi (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (LONG, int64_t, int, int32_t);
  end
end

# Instruction: ltoiu NBITS
#
# Convert the long at the top of the stack to an unsigned
# integer featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( LONG -- LONG UINT )

instruction ltoiu (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (LONG, int64_t, uint, uint32_t);
  end
end

# Instruction: ltol NBITS
#
# Convert the long at the top of the stack to a long featuring
# NBITS bits.
#
# NBITS can be any number from 1 to 64.
#
# Stack: ( LONG -- LONG LONG )

instruction ltol (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (LONG, int64_t, long, int64_t);
  end
end

# Instruction: ltolu NBITS
#
# Convert the long at the top of the stack to an unsigned long
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 64.
#
# Stack: ( LONG -- LONG ULONG )

instruction ltolu (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (LONG, int64_t, ulong, uint64_t);
  end
end

# Instruction: lutoi NBITS
#
# Convert the unsigned long at the top of the stack to an integer
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( ULONG -- ULONG INT )

instruction lutoi (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (ULONG, uint64_t, int, int32_t);
  end
end

# Instruction: lutoiu NBITS
#
# Convert the unsigned long at the top of the stack to an unsigned
# integer featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( ULONG -- ULONG UINT )

instruction lutoiu (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (ULONG, uint64_t, uint, uint32_t);
  end
end

# Instruction: lutol NBITS
#
# Convert the unsigned long at the top of the stack to a long
# featuring NBITS bits.
#
# Stack: ( ULONG -- ULONG LONG )

instruction lutol (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (ULONG, uint64_t, long, int64_t);
  end
end

# Instruction: lutolu NBITS
#
# Convert the unsigned long at the top of the stack to an
# unsigned long featuring NBITS bits.
#
# Stack: ( ULONG -- ULONG ULONG )

instruction lutolu (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (ULONG, uint64_t, ulong, uint64_t);
  end
end


## String instructions

# Instruction: strref
#
# Given a string and an unsigned long at the top of the stack, push an
# unsigned integer with the code of the character that occupies that
# position in the string, on the stack.
#
# The index is zero-based.  If it is less than 0 or exceeds the
# length of the string, then PVM_E_OUT_OF_BOUNDS is raised.
#
# Stack: ( STR ULONG -- STR ULONG UINT )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction strref () # ( STR ULONG -- STR ULONG VAL )
  branching # because of PVM_RAISE_DIRECT
  code
     pvm_val string = JITTER_UNDER_TOP_STACK ();
     pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            strlen (PVM_VAL_STR (string))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_MAKE_UINT (PVM_VAL_STR (string)[PVM_VAL_ULONG (index)],
                                      8));
  end
end

# Instruction: strset
#
# Given a string STR, an index FROM and a string NEWSTR, copy the content
# of NEWSTR to STR at index FROM.
#
# Index is zero-based.
#
# If FROM >= the size of the string, or if FROM+len(NEWSTR) > the size
# of the string, raise the PVM_E_OUT_OF_BOUNDS exception.
#
# Stack: ( STR ULONG NEWSTR -- STR )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction strset ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val newstr = JITTER_TOP_STACK ();
    uint64_t from = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());
    pvm_val str;
    size_t slen, nslen = strlen (PVM_VAL_STR (newstr));

    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    str = JITTER_TOP_STACK ();
    slen = strlen (PVM_VAL_STR (str));

    if (from > slen || from + nslen > slen)
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    /* Using `strncpy` will emit a false compiler warning
       (-Wstringop-overflow=).  */
    memcpy (PVM_VAL_STR (str) + from, PVM_VAL_STR (newstr), nslen);
  end
end

# Instruction: substr
#
# Given a string and two indices FROM and TO conforming a semi-open
# interval [FROM,TO), push the substring enclosed by that interval.
#
# Both indexes are zero-based.
#
# If FROM >= the size of the string, or if TO > the size of the
# string, or if FROM >= TO, raise the PVM_E_OUT_OF_BOUNDS exception.
#
# Stack: ( STR ULONG(from) ULONG(to) -- STR ULONG(from) ULONG(to) STR )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction substr () # ( STR ULONG ULONG -- STR ULONG ULONG STR )
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val str;
    char *s;
    pvm_val to = JITTER_TOP_STACK ();
    pvm_val from = JITTER_UNDER_TOP_STACK ();
    size_t slen = PVM_VAL_ULONG (to) - PVM_VAL_ULONG (from);

    JITTER_DROP_STACK ();
    str = JITTER_UNDER_TOP_STACK ();
    JITTER_PUSH_STACK (to);

    if (PVM_VAL_ULONG (from) >= strlen (PVM_VAL_STR (str))
        || PVM_VAL_ULONG (to) > strlen (PVM_VAL_STR (str))
        || PVM_VAL_ULONG (from) > PVM_VAL_ULONG (to))
        PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    s = pvm_alloc (slen + 1);
    strncpy (s,
             PVM_VAL_STR (str) + PVM_VAL_ULONG (from),
             slen);
    s[slen] = '\0';

    JITTER_PUSH_STACK (pvm_make_string_nodup (s));
  end
end

# Instruction: muls
#
# Given a string and an unsigned long on the stack, push a new
# string value whose value is the concatenation of the argument
# string applied to itself as many times as the unsigned long.  If
# the second argument to muls is 0 then the result of the operation
# is the empty string.
#
# Stack: ( STR ULONG -- STR ULONG STR )

instruction muls ()
  code
    pvm_val str = JITTER_UNDER_TOP_STACK ();
    size_t i, num = PVM_VAL_ULONG (JITTER_TOP_STACK ());
    char *res = pvm_alloc (strlen (PVM_VAL_STR (str)) * num + 1);

    *res = '\0';
    for (i = 0; i < num; ++i)
      strcat (res, PVM_VAL_STR (str));

    JITTER_PUSH_STACK (pvm_make_string_nodup (res));
  end
end

# Instruction: sprops
#
# Given a string STR, set the styling class of the substring with
# length LEN from index IDX to CLASS.
#
# Stack: ( STR IDX LEN CLASS -- STR )

instruction sprops ()
  code
    /* FIXME not implemented yet */
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
  end
end

# Instruction: sproph
#
# Given a string STR, set the hyperlink property (which characterized
# by a URL and an ID) of the substring with length LEN from index IDX.
#
# Stack: ( STR IDX LEN URL ID -- STR )

instruction sproph ()
  code
    /* FIXME not implemented yet */
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
  end
end


# Instruction: spropc
#
# Given a string on the stack, push the copy of the string with all
# properties cleared.
#
# Stack: ( STR -- STR )

instruction spropc ()
  code
    /* FIXME not implemented yet */
  end
end


## Array instructions

# Instruction: mka
#
# Make a new empty array value.
#
# TYP is the type of the new array.
#
# NELEM is a hint on how many elements to use to initialize the array
# value.  This is to avoid allocating memory that will never be used.
# Use 0UL when the number of elements in the array are not known
# in advance; this will make the PVM to choose a reasonable default.
#
# Stack: ( TYP ULONG(nelem) -- ARR )

instruction mka ()
  code
    pvm_val arr = pvm_make_array (JITTER_TOP_STACK (),
                                  JITTER_UNDER_TOP_STACK ());

    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    JITTER_PUSH_STACK (arr);
  end
end

# Instruction: ains
#
# Insert a new element VAL, at the end of the array ARR, making it grow.
#
# If IDX is less than the current size of the array, the value is
# stored in the referred argument.
#
# If IDX is equal or bigger than the current size of the array, the
# same element is replicated in the previous elements.
#
# Examples:
#
# a = [a1, a2, a3]
#
# [a1, a2, a3] 2 VAL ains -> INVAL exception
# [a1, a2, a3] 3 VAL ains -> [a1, a2, a3, VAL]
# [a1, a2, a3] 5 VAL ains -> [a1, a2, a3, VAL, VAL, VAL]
#
# Stack: ( ARR IDX VAL -- ARR )
# Exceptions: PVM_E_INVAL

instruction ains ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val val = JITTER_TOP_STACK ();
    pvm_val idx = JITTER_UNDER_TOP_STACK ();
    pvm_val arr;

    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    arr = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (idx) < PVM_VAL_ULONG (PVM_VAL_ARR_NELEM (arr)))
      /* Note that pvm_array_set can't return 0 here due
         to the index check.  */
      pvm_array_set (arr, idx, val);
    else
    {
      if (!pvm_array_insert (arr, idx, val))
        PVM_RAISE (PVM_E_INVAL, "invalid index in ains",
                   PVM_E_INVAL_ESTATUS);
    }
  end
end

# Instruction: arem
#
# Remove an element from an array at the specified index, making it
# schrink.
#
# If IDX doesn't correspond to an element in the array, raise
# PVM_E_OUT_OF_BOUNDS.  This always happens if the array is empty.
#
# Stack: ( ARR IDX -- ARR )
# Exception: PVM_E_OUT_OF_BOUNDS

instruction arem ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val arr = JITTER_UNDER_TOP_STACK ();
    pvm_val idx = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (idx) >= PVM_VAL_ULONG (PVM_VAL_ARR_NELEM (arr)))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    /* This call can't fail (return 0) due to the index check above.  */
    (void) pvm_array_rem (arr, idx);
    JITTER_DROP_STACK ();
  end
end

# Instruction: aset
#
# Set the value with index ULONG in the array ARR to have the value
# VAL.
#
# If the specified index exceeds the capability of the array, then
# PVM_E_OUT_OF_BOUNDS is raised.  If the array is bounded by size and
# the new value makes the total size of the array to change, then
# PVM_E_CONV is raised.
#
# Stack: ( ARR ULONG VAL -- ARR )
# Exceptions: PVM_E_CONV, PVM_E_OUT_OF_BOUNDS

instruction aset ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val idx;
    pvm_val val;
    pvm_val arr;
    pvm_val array_type, bound;
    size_t index;

    val= JITTER_TOP_STACK ();
    idx = JITTER_UNDER_TOP_STACK ();
    index = PVM_VAL_ULONG (idx);
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();

    arr = JITTER_TOP_STACK ();

    if (index >= PVM_VAL_INTEGRAL (PVM_VAL_ARR_NELEM (arr)))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    /* If the array is bounded by size, check whether the new value
       results in a different size.  */
    array_type = PVM_VAL_ARR_TYPE (arr);
    bound = PVM_VAL_TYP_A_BOUND (array_type);

    if (PVM_IS_OFF (bound))
      {
        pvm_val oval = PVM_VAL_ARR_ELEM_VALUE (arr, index);
        uint64_t old_size_bits;
        uint64_t new_size_bits;

        PVM_VAL_ARR_ELEM_VALUE (arr, index) = val;

        old_size_bits = (PVM_VAL_INTEGRAL (PVM_VAL_OFF_MAGNITUDE (bound))
                         * PVM_VAL_INTEGRAL (PVM_VAL_OFF_UNIT (bound)));
        new_size_bits = pvm_sizeof (arr);

        if (new_size_bits != old_size_bits)
         {
           PVM_VAL_ARR_ELEM_VALUE (arr, index) = oval;
           PVM_RAISE_DFL (PVM_E_CONV);
         }
      }
   else
      {
        /* Note that pvm_aray_set cannot fail here, due to the check
           on index above.  This is done like this in order to avoid
           checking the bound by size if the index is out of bounds.  */
         pvm_array_set (arr, idx, val);
      }
  end
end

# Instruction: aref
#
# Given an array ARR and an index ULONG, push the element of the array
# occupying that position on the stack.
#
# If the provided index is out of bounds, then raise
# PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( ARR ULONG -- ARR ULONG VAL )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction aref ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val array = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if ((PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_ARR_NELEM (array))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_VAL_ARR_ELEM_VALUE (array,
                                               PVM_VAL_ULONG (index)));
  end
end

# Instruction: arefo
#
# Given an array ARR and an index ULONG, push the offset of the
# element occupying that position in the array.
#
# If the provided index is out of bounds, then raise
# PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( ARR ULONG -- ARR ULONG OFF )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction arefo ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val array = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_ARR_NELEM (array))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_VAL_ARR_ELEM_OFFSET (array,
                                                PVM_VAL_ULONG (index)));
  end
end

# Instruction: asettb
#
# Given an array ARR and a closure BOUND, set the later as the array's
# bounder function.  This is a function that, once executed with no
# arguments, returns the size of the array.
#
# Stack: ( ARR BOUND -- ARR )

instruction asettb () # ( ARR BOUND -- ARR )
  code
    pvm_val type = PVM_VAL_ARR_TYPE (JITTER_UNDER_TOP_STACK ());

    assert (PVM_VAL_TYP_CODE (type) == PVM_TYPE_ARRAY);
    PVM_VAL_TYP_A_BOUND (type) = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
  end
end


## Struct instructions

# Instruction: mksct
#
# Given an offset, a list of fields, a list of methods and a struct
# type, create a struct value and push it on the stack.
#
# Each field is specified as a triplet [OFF STR VAL] where OFF is the
# offset of field, STR the name of the field or PVM_NULL if the field
# is anonymous, and VAL is a value.
#
# Each method is specified as a tuple [STR VAL] where STR is the name
# of the method and VAL is the closure value corresponding to the
# method.
#
# Stack: ( OFF [OFF STR VAL]... [STR VAL]... ULONG ULONG TYP -- SCT )

instruction mksct ()
  code
    size_t e;
    pvm_val nfields, nmethods, sct, type;

    type = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nfields = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nmethods = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    sct = pvm_make_struct (nfields, nmethods, type);

    for (e = 0; e < PVM_VAL_ULONG (nmethods); ++e)
    {
      PVM_VAL_SCT_METHOD_VALUE (sct, PVM_VAL_ULONG (nmethods) - e - 1)
         = JITTER_TOP_STACK ();
      PVM_VAL_SCT_METHOD_NAME (sct, PVM_VAL_ULONG (nmethods) - e - 1)
         = JITTER_UNDER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    for (e = 0; e < PVM_VAL_ULONG (nfields); ++e)
    {
      PVM_VAL_SCT_FIELD_VALUE (sct, PVM_VAL_ULONG (nfields) - e - 1)
          = JITTER_TOP_STACK ();
      PVM_VAL_SCT_FIELD_NAME (sct, PVM_VAL_ULONG (nfields) - e - 1)
          = JITTER_UNDER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();

      PVM_VAL_SCT_FIELD_OFFSET (sct, PVM_VAL_ULONG (nfields) - e -1)
          = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
    }

    PVM_VAL_SCT_OFFSET (sct) = JITTER_TOP_STACK();
    JITTER_DROP_STACK ();

    JITTER_PUSH_STACK (sct);
  end
end

# Instruction: sset
#
# Given a struct, a field name and a value, replace the value of
# the referred struct field with the given value.  If the struct
# does not have a field with the given name, then raise PVM_E_ELEM.
#
# Stack: ( SCT STR VAL -- SCT )
# Exceptions: PVM_E_ELEM

instruction sset ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val val = JITTER_TOP_STACK ();
    pvm_val name = JITTER_UNDER_TOP_STACK ();
    pvm_val sct;

    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();

    sct = JITTER_TOP_STACK ();
    if (!pvm_set_struct (sct, name, val))
       PVM_RAISE_DFL (PVM_E_ELEM);
  end
end

# Instruction: sseti
#
# Given a struct, a field index and a value, replace the value
# of the referred struct field with the given value.  If the
# given index does not refer to a struct field, then raise
# PVM_E_ELEM.
#
# Stack: (SCT IDX VAL -- SCT)
# Exceptions: PVM_E_ELEM

instruction sseti ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val val = JITTER_TOP_STACK ();
    pvm_val idx = JITTER_UNDER_TOP_STACK ();
    size_t field_index = PVM_VAL_ULONG (idx);
    pvm_val sct;

    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();

    sct = JITTER_TOP_STACK ();

    if (field_index >= PVM_VAL_SCT_NFIELDS (sct))
      PVM_RAISE_DFL (PVM_E_ELEM);
    PVM_VAL_SCT_FIELD_VALUE (sct, field_index) = val;
  end
end

# Instruction: sref
#
# Given a struct and a field name, push the value contained in the
# referred struct field on the stack.  If the struct does not have a
# field with the given name, or if the field is absent from the struct
# value then raise PVM_E_ELEM.
#
# Stack: ( SCT STR -- SCT STR VAL )
# Exceptions: PVM_E_ELEM

instruction sref ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val val = pvm_ref_struct (JITTER_UNDER_TOP_STACK (),
                                  JITTER_TOP_STACK ());

    if (val == PVM_NULL)
      PVM_RAISE_DFL (PVM_E_ELEM);
    JITTER_PUSH_STACK (val);
  end
end

# Instruction: srefo
#
# Given a struct and a field name, push the bit-offset of the referred
# field on the stack.  If the struct does not have a field with the given
# name, or if the field is absent from the struct value then raise
# PVM_E_ELEM.
#
# Stack: ( SCT STR -- SCT STR BOFF )
# Exceptions: PVM_E_ELEM

instruction srefo ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val fname = JITTER_TOP_STACK ();
    pvm_val boff = pvm_refo_struct (sct, fname);

    if (boff == PVM_NULL)
      PVM_RAISE_DFL (PVM_E_ELEM);
    JITTER_PUSH_STACK (boff);
  end
end

# Instruction: srefmnt
#
# Given a struct and a method name, push the closure value corresponding
# to that method on the stack.  If the struct does not have a method with
# the given name then push PVM_NULL.
#
# Stack: ( SCT STR - SCT STR CLS )

instruction srefmnt ()
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val name = JITTER_TOP_STACK ();
    pvm_val cls = pvm_get_struct_method (sct, PVM_VAL_STR (name));

    JITTER_PUSH_STACK (cls);
  end
end

# Instruction: srefnt
#
# Given a struct and a field name, push the value contained in the
# struct field on the stack.  If the struct does not have a field with
# the given name, or if the field is absent from the struct value then
# push PVM_NULL.
#
# Stack: ( SCT STR -- SCT STR VAL )

instruction srefnt ()
  code
    pvm_val val = pvm_ref_struct (JITTER_UNDER_TOP_STACK (),
                                  JITTER_TOP_STACK ());

    JITTER_PUSH_STACK (val);
  end
end

# Instruction: srefi
#
# Given a struct and an index, push the value of the field occupying
# the position specified by the index in the given struct.  If the
# struct doesn't have that many fields, raise PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( SCT ULONG -- SCT ULONG VAL )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction srefi ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_SCT_NFIELDS (sct))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_VAL_SCT_FIELD_VALUE (sct,
                                               PVM_VAL_ULONG (index)));
  end
end

# Instruction: srefia
#
# Given a struct and an index, push 1 if the field occupying the
# position specified by the index in the given struct is absent.  Push
# 0 otherwise.  If the struct doesn't have that many fields, raise
# PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( SCT ULONG -- SCT ULONG INT )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction srefia ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();
    int absent_p;

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_SCT_NFIELDS (sct))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    absent_p = PVM_VAL_SCT_FIELD_ABSENT_P (sct, PVM_VAL_ULONG (index));
    JITTER_PUSH_STACK (PVM_MAKE_INT (absent_p, 32));
  end
end

# Instruction: srefio
#
# Given a struct and an index, push the offset of the field occupying
# the position specified by the index in the given struct.  If the
# struct doesn't have that many fields, raise PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( SCT ULONG -- SCT ULONG BOFF )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction srefio ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_SCT_NFIELDS (sct))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_VAL_SCT_FIELD_OFFSET (sct,
                                                 PVM_VAL_ULONG (index)));
  end
end

# Instruction: smodi
#
# Given a struct and an index, push the modified flags of the field
# occupying the position specified by the index in the given struct.
# If the struct doesn't have that many fields, raise
# PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( SCT ULONG -- SCT ULONG BOOL )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction smodi ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_SCT_NFIELDS (sct))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_VAL_SCT_FIELD_MODIFIED (sct,
                                                   PVM_VAL_ULONG (index)));
  end
end


## Offset Instructions

# Instruction: mko
#
# Given an integral magnitude VAL and an unit expressed in an ULONG,
# make an offset value and push it on the stack.
#
# Stack: ( VAL ULONG -- OFF )

instruction mko ()
  code
   pvm_val res = pvm_make_offset (JITTER_UNDER_TOP_STACK (),
                                  JITTER_TOP_STACK ());
   JITTER_DROP_STACK ();
   JITTER_TOP_STACK () = res;
  end
end

# Instruction: ogetm
#
# Given an offset OFF, push its magnitude on the stack.
#
# Stack: ( OFF -- OFF VAL )

instruction ogetm ()
  code
   JITTER_PUSH_STACK (PVM_VAL_OFF_MAGNITUDE (JITTER_TOP_STACK ()));
  end
end

# Instruction: osetm
#
# Given an offset OFF and an integral value VAL, make it the
# offset's magnitude.
#
# Stack: ( OFF VAL -- OFF )

instruction osetm ()
  code
   PVM_VAL_OFF_MAGNITUDE (JITTER_UNDER_TOP_STACK ())
    =  JITTER_TOP_STACK ();
   JITTER_DROP_STACK ();
  end
end

# Instruction: ogetu
#
# Given an offset OFF, push its unit on the stack.
#
# Stack: ( OFF -- OFF ULONG )

instruction ogetu ()
  code
    JITTER_PUSH_STACK (PVM_VAL_OFF_UNIT (JITTER_TOP_STACK ()));
  end
end

# Instruction: ogetbt
#
# Given an offset OFF, push its base type on the stack.
#
# Stack: ( OFF -- OFF TYP )

instruction ogetbt ()
  code
    JITTER_PUSH_STACK (PVM_VAL_OFF_BASE_TYPE (JITTER_TOP_STACK ()));
  end
end


## Instructions to handle mapped values

# Instruction: mm
#
# Given a value, push 1 on the stack if the value is mapped.
# Push 0 otherwise.
#
# Stack: ( VAL -- VAL INT )

instruction mm ()
  code
    pvm_val mapped_p = PVM_MAKE_INT (PVM_VAL_MAPPED_P (JITTER_TOP_STACK ()),
                                     32);
    JITTER_PUSH_STACK (mapped_p);
  end
end

# Instruction: map
#
# Given a value, mark it as as mapped.  If the value can't be
# mapped then PVM_E_INVAL is raised.
#
# Stack: ( VAL -- VAL )
# Exceptions: PVM_E_INVAL

instruction map ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val val = JITTER_TOP_STACK ();

    if (!(PVM_IS_ARR (val) || PVM_IS_SCT (val)))
      PVM_RAISE (PVM_E_INVAL, "not mappable value", PVM_E_INVAL_ESTATUS);

    PVM_VAL_SET_MAPPED_P (JITTER_TOP_STACK (), 1);
  end
end

# Instruction: unmap
#
# Given a value, mark it as as not mapped.  If the value can't be
# mapped then this is a no-operation.
#
# Stack: ( VAL -- VAL )

instruction unmap ()
  code
    pvm_val_unmap (JITTER_TOP_STACK ());
  end
end

# Instruction: reloc
#
# Given a value, a IO space expressed in an ulong, and a bit-offset
# expressed in an ulong, relocate the value to the given bit-offset at
# the given IO space.
#
# If the given value is not map-able then raise PVM_E_INVAL.
#
# Stack: ( VAL ULONG ULONG -- VAL ULONG ULONG )
# Exceptions: PVM_E_INVAL

instruction reloc ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val boffset = JITTER_TOP_STACK ();
    pvm_val ios = JITTER_UNDER_TOP_STACK ();
    pvm_val val;

    JITTER_DROP_STACK ();
    val = JITTER_UNDER_TOP_STACK ();
    JITTER_PUSH_STACK (boffset);

    if (!(PVM_IS_ARR (val) || PVM_IS_SCT (val)))
      PVM_RAISE (PVM_E_INVAL, "not mappable value", PVM_E_INVAL_ESTATUS);

    pvm_val_reloc (val, ios, boffset);
  end
end

# Instruction: ureloc
#
# Given a value, undo the last reloc performed on the value.
#
# If the given value is not map-able then raise PVM_E_INVAL.
#
# Stack: ( VAL -- VAL )
# Exceptions: PVM_E_INVAL

instruction ureloc ()
  branching # because of PVM_RAISE_DIRECT
  code
      pvm_val val = JITTER_TOP_STACK ();

      if (!(PVM_IS_ARR (val) || PVM_IS_SCT (val)))
        PVM_RAISE (PVM_E_INVAL, "not mappable value", PVM_E_INVAL_ESTATUS);

      pvm_val_ureloc (val);
  end
end

# Instruction: mgets
#
# Given a value, push a boolean indicating whether the
# value is strict.  If the given value is not map-able then push
# false, i.e. 0.
#
# Stack: ( VAL -- VAL INT )

instruction mgets ()
  code
    int strict_p = PVM_VAL_STRICT_P (JITTER_TOP_STACK ());
    JITTER_PUSH_STACK (PVM_MAKE_INT (strict_p, 32));
  end
end

# Instruction: msets
#
# Given a value and a boolean, set the strictness of the value
# to the given boolean.  If the value is not map-able this is
# a no-operation.
#
# Stack: ( VAL INT -- VAL )

instruction msets ()
  code
    int strict_p = PVM_VAL_INT (JITTER_TOP_STACK ());

    PVM_VAL_SET_STRICT_P (JITTER_UNDER_TOP_STACK (), strict_p);
    JITTER_DROP_STACK ();
  end
end

# Instruction: mgeto
#
# Given a map-able value, push its bit-offset on the stack as an
# unsigned long.  If the given value is not map-able then push
# PVM_NULL.
#
# Stack: ( VAL -- VAL ULONG )

instruction mgeto ()
  code
    JITTER_PUSH_STACK (PVM_VAL_OFFSET (JITTER_TOP_STACK ()));
  end
end

# Instruction: mseto
#
# Given a map-able value an a bit-offset, set its offset to the value.
# If the given value is not map-able, then the offset is ignored.
#
# Stack: ( VAL ULONG -- VAL )

instruction mseto ()
  code
    PVM_VAL_SET_OFFSET (JITTER_UNDER_TOP_STACK (),
                        JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: mgetios
#
# Given a map-able value, push its associated IO space on the stack.
# If the given value is not map-able, then push PVM_NULL.
#
# Stack: ( VAL -- VAL INT )

instruction mgetios ()
  code
    JITTER_PUSH_STACK (PVM_VAL_IOS (JITTER_TOP_STACK ()));
  end
end

# Instruction: msetios
#
# Given a map-able value and an IOS descriptor, set it as its
# associated IO space.  If the IOS descriptor is PVM_NULL then it uses
# the current IO space.  If the given value is not map-able then the
# IO space is ignored.
#
# Stack: ( VAL INT -- VAL )

instruction msetios ()
  code
    PVM_VAL_SET_IOS (JITTER_UNDER_TOP_STACK (),
                     JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: mgetm
#
# Given a map-able value, push its mapper closure on the stack.  If
# the given value is not map-able, then push PVM_NULL.
#
# Stack: ( VAL -- VAL CLS )

instruction mgetm ()
  code
     JITTER_PUSH_STACK (PVM_VAL_MAPPER (JITTER_TOP_STACK ()));
  end
end

# Instruction: msetm
#
# Given a map-able value and a closure, set it as its mapper.  If the
# given value is not map-able then the closure is ignored.
#
# Stack: ( VAL CLS -- VAL )

instruction msetm ()
  code
    PVM_VAL_SET_MAPPER (JITTER_UNDER_TOP_STACK (), JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: mgetw
#
# Given a map-able value, push its writer closure on the stack.  If
# the given value is not map-able, then push PVM_NULL.
#
# Stack: ( VAL -- VAL CLS )

instruction mgetw ()
  code
     JITTER_PUSH_STACK (PVM_VAL_WRITER (JITTER_TOP_STACK ()));
  end
end

# Instruction: msetw
#
# Given a map-able value and a closure, set it as its writer.  If the
# given value is not map-able then the closure is ignored.
#
# Stack: ( VAL CLS -- VAL )

instruction msetw ()
  code
    PVM_VAL_SET_WRITER (JITTER_UNDER_TOP_STACK (), JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: mgetsel
#
# Given a map-able value in the TOS, push the number of elements to
# which its mapping is bounded to.  If the value is not mapped, or
# if it is not bounded by number of elements, push PVM_NULL.
#
# Note that only array values can have mappings bounded by number of
# elements.
#
# Stack: ( VAL -- VAL ULONG )

instruction mgetsel ()
  code
    JITTER_PUSH_STACK (PVM_VAL_ELEMS_BOUND (JITTER_TOP_STACK ()));
  end
end

# Instruction: msetsel
#
# Given a map-able value and an unsigned long, set it as the mapping
# bound by number of elements.  If the value is not map-able the
# unsigned long is ignored.
#
# Note that only array values can have mappings bounded by number of
# elements.
#
# Stack: ( VAL ULONG -- VAL )

instruction msetsel ()
  code
    PVM_VAL_SET_ELEMS_BOUND (JITTER_UNDER_TOP_STACK (), JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: mgetsiz
#
# Given a map-able value in the TOS, push its mapping size-bound as a
# bit-offset.  If the value is not map-able, or if it is not bounded
# by size, push PVM_NULL.
#
# Note that only array values can have mappings bounded by size.
#
# Stack: ( VAL -- VAL ULONG )

instruction mgetsiz ()
  code
    JITTER_PUSH_STACK (PVM_VAL_SIZE_BOUND (JITTER_TOP_STACK ()));
  end
end

# Instruction: msetsiz
#
# Given a map-able value and a bit-offset, set it as the mapping
# size-bound.  If the value is not map-able, the bit-offset is
# ignored.
#
# Note that only array values can have mappings bounded by size.
#
# Stack: ( VAL ULONG -- VAL )

instruction msetsiz ()
  code
    PVM_VAL_SET_SIZE_BOUND (JITTER_UNDER_TOP_STACK (), JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end


## Type related instructions

# Instruction: isa
#
# Given a value and a type, push 1 on the stack if the value is of the
# given type.  Push 0 otherwise.
#
# Stack: ( VAL TYPE -- TYPE VAL INT )

instruction isa ()
  code
    pvm_val type = JITTER_TOP_STACK ();
    pvm_val val = JITTER_UNDER_TOP_STACK ();
    pvm_val val_type = pvm_typeof (val);

    JITTER_PUSH_STACK (PVM_MAKE_INT (pvm_type_equal_p (type, val_type),
                                     32));
  end
end

# Instruction: typof
#
# Given a value, push its type on the stack.
#
# Stack: ( VAL -- VAL TYPE )

instruction typof ()
  code
    JITTER_PUSH_STACK (pvm_typeof (JITTER_TOP_STACK ()));
  end
end

# Instruction: tyisc
#
# Given a value, push 1 on the stack if it is a closure.  Push 0
# otherwise.
#
# Stack: ( VAL -- VAL INT )

instruction tyisc ()
  code
    JITTER_PUSH_STACK (PVM_MAKE_INT (PVM_IS_CLS (JITTER_TOP_STACK ()), 32));
  end
end

# Instruction: tyissct
#
# Given a value, push 1 on the stack if it is a struct.  Push 0
# otherwise.
#
# Stack: ( VAL -- VAL INT )

instruction tyissct ()
  code
    JITTER_PUSH_STACK (PVM_MAKE_INT (PVM_IS_SCT (JITTER_TOP_STACK ()), 32));
  end
end

# Instruction: mktyv
#
# Build a "void" type and push it on the stack.
#
# Stack: ( -- TYPE )

instruction mktyv ()
  code
    JITTER_PUSH_STACK (pvm_make_void_type ());
  end
end

# Instruction: mktyany
#
# Build an "any" type and push it on the stack.
#
# Stack: ( -- TYPE )

instruction mktyany ()
  code
    JITTER_PUSH_STACK (pvm_make_any_type ());
  end
end

# Instruction: mktyi
#
# Given an unsigned long denoting a bit width, and an unsigned int
# denoting signedness (0 is unsigned, 1 is signed), build a an
# integral type with these features and push it on the stack.
#
# Stack: ( ULONG UINT -- TYPE )

instruction mktyi ()
  code
    pvm_val size = JITTER_UNDER_TOP_STACK ();
    pvm_val signed_p = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    JITTER_TOP_STACK () = pvm_make_integral_type (size, signed_p);
  end
end

# Instruction: mktys
#
# Push a string type on the stack.
#
# Stack: ( -- TYPE )

instruction mktys ()
  code
    JITTER_PUSH_STACK (pvm_make_string_type ());
  end
end

# Instruction: mktyo
#
# Given a base integral type and an integer denoting an offset unit
# (multiple of the base unit) construct an offset type having these
# features, and push it on the stack.
#
# Stack: ( TYPE INT -- TYPE )

instruction mktyo ()
  code
#define F(res, a, b) \
  { res = pvm_make_offset_type (a, b); }
    JITTER_BINARY_STACK(F);
#undef F
  end
end

# Instruction: mktya
#
# Given an elements type and an unsigned long denoting a length, build
# an array type having these features and push it on the stack.  If
# the type array is unbounded then length is PVM_NULL.
#
# Stack: ( TYPE (ULONG|NULL) -- TYPE )

instruction mktya ()
  code
     pvm_val bound = JITTER_TOP_STACK ();
     pvm_val etype = JITTER_UNDER_TOP_STACK ();

     JITTER_DROP_STACK ();
     JITTER_TOP_STACK () = pvm_make_array_type (etype, bound);
  end
end

# Instruction: tyagett
#
# Given an array type, push the type of its elements on the stack.
#
# Stack: ( TYPE -- TYPE TYPE )

instruction tyagett ()
  code
    JITTER_PUSH_STACK (PVM_VAL_TYP_A_ETYPE (JITTER_TOP_STACK ()));
  end
end

# Instruction: tyagetb
#
# Given an array type, push its bound on the stack.
#
# Stack: ( TYPE -- TYPE (ULONG|NULL) )

instruction tyagetb ()
  code
    JITTER_PUSH_STACK (PVM_VAL_TYP_A_BOUND (JITTER_TOP_STACK ()));
  end
end

# Instruction: mktyc
#
# Given a list of argument types, a return type and a number of
# arguments, build a closure type and push it on the stack.
#
# Stack: ( TYPE... TYPE ULONG -- TYPE )

instruction mktyc ()
  code
    size_t i;
    pvm_val nargs, rtype, *atypes;

    nargs = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    rtype = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    pvm_allocate_closure_attrs (nargs, &atypes);

    for (i = 0; i < PVM_VAL_ULONG (nargs); ++i)
    {
      atypes[i] = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (pvm_make_closure_type (rtype,
                                              nargs, atypes));
  end
end

# Instruction: mktysct
#
# Given a list of field descriptors, a number of fields and a struct
# type name, build a struct type and push it on the stack.
#
# Each field descriptor has the form [STRING TYPE] and contains the
# name of the field and its type.
#
# Stack: ( [STRING TYPE]... ULONG STR -- TYPE )

instruction mktysct ()
  code
    size_t i;
    pvm_val nelem, name, *etypes, *enames;

    name = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    pvm_allocate_struct_attrs (nelem, &etypes, &enames);

    for (i = 0; i < PVM_VAL_ULONG (nelem); ++i)
    {
      enames[PVM_VAL_ULONG (nelem) - i - 1] = JITTER_UNDER_TOP_STACK ();
      etypes[PVM_VAL_ULONG (nelem) - i - 1] = JITTER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (pvm_make_struct_type (nelem, name,
                                             enames, etypes));
  end
end

# Instruction: tysctn
#
# Given a struct type, push its name to the stack.  If the struct
# type is not named push PVM_NULL.
#
# Stack: ( SCT -- SCT STR )

instruction tysctn ()
  code
    pvm_val type = JITTER_TOP_STACK ();
    pvm_val type_name = PVM_VAL_TYP_S_NAME (type);

    JITTER_PUSH_STACK (type_name);
  end
end


## IO instructions

# Instruction: write
#
# If the value at the TOS is mapped, then write it to its associated
# IO space.  Otherwise, this is a no-op.
#
# Stack: ( VAL -- VAL )
# Exceptions: PVM_E_IOS_FULL, PVM_E_CONSTRAINT_ERROR

instruction write ()
  caller
  branching # because of PVM_RAISE_DIRECT
  code
     pvm_val val = JITTER_TOP_STACK ();
     pvm_val writer = pvm_val_writer (val);

     if (writer != PVM_NULL)
     {
        JITTER_DUP_STACK ();                      /* VAL VAL */
        JITTER_PUSH_STACK (PVM_VAL_OFFSET (val)); /* VAL VAL OFF */
        PVM_CALL (writer);
      }
  end
end

# Instruction: peeki NENC,ENDIAN,BITS
#
# Given an IOS descriptor and a bit-offset, peek an integer value of
# width BITS bits.  The negative encoding and endianness to be used
# are specified in the instruction arguments.
#
# Stack: ( INT ULONG -- INT )

instruction peeki (?n nenc_printer,?n endian_printer,?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_PEEK (int, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_INT);
  end
end

# Instruction: peekiu ENDIAN,BITS
#
# Given an IOS descriptor and a bit-offset, peek an unsigned integer
# value of width BITS bits.  The endianness to be used is specified in
# the instruction arguments.
#
# Stack: ( INT ULONG -- INT )

instruction peekiu (?n endian_printer,?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
   PVM_PEEK (uint, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_UINT);
  end
end

# Instruction: peekl NENC,ENDIAN,BITS
#
# Given an IOS descriptor and a bit-offset, peek a long value of width
# BITS bits.  The negative encoding and endianness to be used are
# specified in the instruction arguments.
#
# Stack: ( INT ULONG -- LONG )

instruction peekl (?n nenc_printer,?n endian_printer,?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_PEEK (long, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_INT);
  end
end

# Instruction: peeklu ENDIAN,BITS
#
# Given an IOS descriptor and a bit-offset, peek an unsigned long value
# of width BITS bits.  The endianness to be used is specified in the
# instruction arguments.
#
# Stack: ( INT ULONG -- ULONG )

instruction peeklu (?n endian_printer,?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
   PVM_PEEK (ulong, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_UINT);
  end
end

# Instruction: peekdi BITS
#
# Given an IOS descriptor and a bit-offset, peek an integer value of
# width BITS bits.  Use the default endianness and negative encoding.
#
# Stack: ( INT ULONG -- INT )

instruction peekdi (?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_PEEK (int, int, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_INT);
  end
end

# Instruction: peekdiu BITS
#
# Given an IOS descriptor and a bit-offset, peek an unsigned integer
# value of width BITS bits.  Use the default endianness.
#
# Stack: ( INT ULONG -- UINT )

instruction peekdiu (?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_PEEK (uint, uint, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_UINT);
  end
end

# Instruction: peekdl BITS
#
# Given an IOS descriptor and a bit-offset, peek a long value of width
# BITS bits.  Use the default endianness and negative encoding.
#
# Stack: ( INT ULONG -- LONG )

instruction peekdl (?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_PEEK (long, int, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_INT);
  end
end

# Instruction: peekdlu BITS
#
# Given an IOS descriptor and a bit-offset, peek an unsigned long value
# of width BITS bits.  Use the default endianness.
#
# Stack: ( INT ULONG -- ULONG )

instruction peekdlu (?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_PEEK (ulong, uint, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_UINT);
  end
end

# Instruction: pokei NENC,ENDIAN,BITS
#
# Given an IOS descriptor, a bit-offset and an integer value of BITS
# bits, poke it.  Use the negative encoding and endianness specified
# in the instruction arguments.
#
# Stack: ( INT ULONG INT -- )

instruction pokei (?n nenc_printer,?n endian_printer,?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_POKE (INT, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_WRITE_INT);
  end
end

# Instruction: pokeiu ENDIAN,BITS
#
# Given an IOS descriptor, a bit-offset and an unsigned integer value
# of BITS bits, poke it.  Use the endianness specified in the
# instruction arguments.
#
# Stack: ( INT ULONG INT -- )

instruction pokeiu (?n endian_printer,?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
   PVM_POKE (UINT, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_WRITE_UINT);
  end
end

# Instruction: pokel NENC,ENDIAN,BITS
#
# Given an IOS descriptor, a bit-offset and a long value of BITS bits,
# poke it.  Use the negative encoding and endianness specified in the
# instruction arguments.
#
# Stack: ( INT ULONG LONG -- )

instruction pokel (?n nenc_printer,?n endian_printer,?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_POKE (LONG, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_WRITE_INT);
  end
end

# Instruction: pokelu ENDIAN,BITS
#
# Given an IOS descriptor, a bit-offset and an unsigned long value of
# BITS bits, poke it.  Use the endianness specified in the instruction
# arguments.
#
# Stack: ( INT ULONG ULONG -- )

instruction pokelu (?n endian_printer,?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
   PVM_POKE (ULONG, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_WRITE_UINT);
  end
end

# Instruction: pokedi BITS
#
# Given an IOS descriptor, a bit-offset and an integer of BITS bits,
# poke it.  Use the default negative encoding and endianness.
#
# Stack: ( INT ULONG INT -- )

instruction pokedi (?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_POKE (INT, int, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_INT);
  end
end

# Instruction: pokediu BITS
#
# Given an IOS descriptor, a bit-offset and an unsigned integer of BITS
# bits, poke it.  Use the default endianness.
#
# Stack: ( INT ULONG UINT -- )

instruction pokediu (?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_POKE (UINT, uint, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_UINT);
  end
end

# Instruction: pokedl BITS
#
# Given an IOS descriptor, a bit-offset and a long of BITS bits, poke
# it.  Use the default negative encoding and endianness.
#
# Stack: ( INT ULONG LONG -- )

instruction pokedl (?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_POKE (LONG, int, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_INT);
  end
end

# Instruction: pokedlu BITS
#
# Given an IOS descriptor, a bit-offset and an unsigned long of BITS
# bits, poke it.  Use the default endianness.
#
# Stack: ( INT ULONG ULONG -- )

instruction pokedlu (?n bits_printer)
  branching # because of PVM_RAISE_DIRECT
  code
    PVM_POKE (ULONG, uint, jitter_state_runtime.nenc, jitter_state_runtime.endian,
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_UINT);
  end
end

# Instruction: peeks
#
# Given an IOS descriptor and a bit-offset, peek a string.
#
# Stack: ( INT ULONG -- STR )

instruction peeks ()
  branching # because of PVM_RAISE_DIRECT
  code
    ios io;
    ios_off offset;
    char *ios_str;
    int ret;

    offset = PVM_VAL_ULONG (JITTER_TOP_STACK ());
    io = ios_search_by_id (PVM_VAL_INT (JITTER_UNDER_TOP_STACK ()));

    if (io == NULL)
      PVM_RAISE_DFL (PVM_E_NO_IOS);

    JITTER_DROP_STACK ();
    if ((ret = ios_read_string (io, offset, 0 /* flags */, &ios_str)) != IOS_OK)
    {
      if (ret == IOS_EOF)
         PVM_RAISE_DFL (PVM_E_EOF);
      else if (ret == IOS_ENOMEM)
         PVM_RAISE (PVM_E_IO, "out of memory", PVM_E_IO_ESTATUS);
      else if (ret == IOS_EPERM)
         PVM_RAISE_DFL (PVM_E_PERM);
      else
         PVM_RAISE_DFL (PVM_E_IO);
      JITTER_TOP_STACK () = PVM_NULL;
    }
    else
      JITTER_TOP_STACK () = pvm_make_string (ios_str);
  end
end

# Instruction: pokes
#
# Given an IOS descriptor, a bit-offset and a string, poke it.
#
# Stack: ( INT ULONG STR -- )

instruction pokes ()
  branching # because of PVM_RAISE_DIRECT
  code
    ios io;
    ios_off offset;
    char *str;
    int ret;

    str = PVM_VAL_STR (JITTER_TOP_STACK ());
    offset = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();

    io = ios_search_by_id (PVM_VAL_INT (JITTER_TOP_STACK ()));

    if (io == NULL)
      PVM_RAISE_DFL (PVM_E_NO_IOS);

    JITTER_DROP_STACK ();
    if ((ret = ios_write_string (io, offset, 0 /* flags */, str)) != IOS_OK)
    {
      if (ret == IOS_EOF)
         PVM_RAISE_DFL (PVM_E_EOF);
      else if (ret == IOS_EPERM)
         PVM_RAISE_DFL (PVM_E_PERM);
      else
         PVM_RAISE_DFL (PVM_E_IO);
    }
  end
end


## Exceptions handling instructions

# Instruction: pushe LABEL
#
# Given an Exception struct in the stack, push a handler for it on the
# exceptions stack.  An exception code 0 means any exception.
#
# Stack: ( INT -- )
# Exceptions Stack: ( -- EXCEPTION_HANDLER )

instruction pushe (?l)
  code
   struct pvm_exception_handler ehandler;
   pvm_val exception = JITTER_TOP_STACK ();
   pvm_val exception_code = pvm_ref_struct_cstr (exception, "code");

   ehandler.exception = PVM_VAL_INT (exception_code);
   JITTER_DROP_STACK ();
   ehandler.main_stack_height = JITTER_HEIGHT_STACK ();
   ehandler.return_stack_height = JITTER_HEIGHT_RETURNSTACK ();
   ehandler.code = JITTER_ARGP0;
   ehandler.env = jitter_state_runtime.env;

   JITTER_PUSH_EXCEPTIONSTACK (ehandler);
  end
end

# Instruction: pope
#
# Pop an exception handler from the exceptions stack.
#
# Stack: ( -- )
# Exceptions Stack: ( EXCEPTION_HANDLER -- )

instruction pope ()
  code
    JITTER_DROP_EXCEPTIONSTACK ();
  end
end

# Instruction: raise
#
# Raise the given exception.
#
# Stack: ( EXCEPTION -- )
# Exceptions Stack: ( -- )

instruction raise ()
  branching # because of PVM_RAISE_DIRECT

  # XXX change the generated code to jump to raise instructions like this, rather
  # than using PVM_RAISE_* from instruction bodies.  That will dramatically
  # improve code locality and code size, and reduce the number of taken branches.

  # XXX possibly make non-relocatable, for the same reasons.
  code
    pvm_val exception = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
    PVM_RAISE_DIRECT (exception);
  end
end


## Debugging Instructions

# Instruction: strace DEPTH
#
# Print a debugging trace with the elements of the top of the stack.
# The number of elements to print is specified in DEPTH.  A depth of
# zero means to print the whole stack.
#
# Stack: ( -- )

instruction strace (?n)
  non-relocatable
  code
    int i = 0;
    int num_elems = (int) JITTER_ARGN0;
    int num_elems_in_stack;

    assert (PVM_STATE_BACKING_FIELD (canary) != NULL);

    num_elems_in_stack = (pvm_val *)JITTER_HEIGHT_STACK ()
                         - (pvm_val *)PVM_STATE_BACKING_FIELD (canary);
    if (num_elems == 0 || num_elems > num_elems_in_stack)
      num_elems = num_elems_in_stack;

    while (i < num_elems)
      {
        pvm_print_val_with_params (PVM_STATE_BACKING_FIELD (vm),
                                   JITTER_AT_DEPTH_STACK (i),
                                   0 /* depth */,
                                   PVM_PRINT_FLAT,
                                   16 /* base */,
                                   2 /* indent */,
                                   0 /* acutoff */,
                                   PVM_PRINT_F_MAPS);
        pk_puts ("\n");
        i++;
      }
  end
end

# Instruction: disas
#
# Print out the disassembling of the program executed by the
# closure in the top of the stack.
#
# Stack: ( CLS -- CLS )

instruction disas ()
  non-relocatable
  code
    pvm_val cls = JITTER_TOP_STACK ();
    pvm_disassemble_program (PVM_VAL_CLS_PROGRAM (cls));
  end
end

# Instruction: note VALUE
#
# This instruction is intended to be used to insert annotations that
# help to understand disassemblies.  Most of the times VALUE is a
# string.
#
# Semantically, this instruction does nothing.
#
# Stack: ( -- )

instruction note (?n pvm_literal_printer)
  code
  end
end


## System Interaction Instructions

# Instruction: getenv
#
# This instruction gets the name of an environment variable on the
# stack and pushes the value of the corresponding environment
# variable.  If no variable with the given name is defined on the
# environment, then push PVM_NULL.
#
# Stack: ( STR -- STR STR )

instruction getenv ()
  code
    const char *varname = PVM_VAL_STR (JITTER_TOP_STACK ());
    char *value = secure_getenv (varname);

    if (value == NULL)
      JITTER_PUSH_STACK (PVM_NULL);
    else
      JITTER_PUSH_STACK (pvm_make_string (value));
  end
end


## Miscellaneous Instructions

# Instruction: nop
#
# Do nothing.
#
# Stack: ( -- )

instruction nop ()
  code
  end
end

# Instruction: rand
#
# Push a pseudo-random integer to the stack.
#
# If the argument is 0U then it is ignored.  Otherwise it is
# used to set the seed for a new sequence of pseudo-random numbers.
#
# Stack: ( UINT -- INT )

instruction rand ()
  code
    unsigned int seed = PVM_VAL_UINT (JITTER_TOP_STACK ());

    if (seed != 0)
      srandom (seed);
    JITTER_DROP_STACK ();
    JITTER_PUSH_STACK (PVM_MAKE_INT (random (), 32));
  end
end

# Instruction: time
#
# Push the current system time to the stack in the form of
# an array of two long elements containing the number of seconds
# and nanoseconds since the epoch.
#
# Stack: ( -- ARR )

instruction time ()
  code
    struct timespec ts;
    pvm_val arr = pvm_make_array (
      PVM_MAKE_ULONG (2, 64),
      pvm_make_integral_type (PVM_MAKE_ULONG (64, 64), PVM_MAKE_INT (1, 32)));

    gettime (&ts);
    (void) pvm_array_insert (arr, PVM_MAKE_LONG (0, 64),
                             PVM_MAKE_LONG (ts.tv_sec, 64));
    (void) pvm_array_insert (arr, PVM_MAKE_LONG (1, 64),
                             PVM_MAKE_LONG (ts.tv_nsec, 64));

    JITTER_PUSH_STACK (arr);
  end
end

# Instruction: sleep
#
# Sleep for a given number of seconds and nanoseconds.
#
# If the provided number of nanoseconds are not in the range 0 to
# 999999999 or the number of provided seconds is negative, raise
# PVM_E_INVAL.
#
# If there is any other error performing the operation then raise
# PVM_E_GENERIC.
#
# Stack: ( LONG LONG -- LONG LONG )
# Exceptions: PVM_E_INVAL, PVM_E_GENERIC

instruction sleep ()
  branching # because of PVM_RAISE_DIRECT
  code
    struct timespec ts;

    ts.tv_sec = PVM_VAL_LONG (JITTER_UNDER_TOP_STACK ());
    ts.tv_nsec = PVM_VAL_LONG (JITTER_TOP_STACK ());

    if (nanosleep (&ts, NULL) == -1)
    {
      if (errno == EINTR)
        /* This is most likely Ctrl-C.  Do nothing */;
      else if (errno == EINVAL)
        PVM_RAISE_DFL (PVM_E_INVAL);
      else
        PVM_RAISE_DFL (PVM_E_GENERIC);
    }
  end
end

# Instruction: siz
#
# Given a value, push its size as a bit-offset.
#
# Stack: ( VAL -- VAL ULONG )

instruction siz ()
  code
    uint64_t size = pvm_sizeof (JITTER_TOP_STACK ());
    JITTER_PUSH_STACK (PVM_MAKE_ULONG (size, 64));
  end
end

# Instruction: sel
#
# Given a value, push its length as an unsigned long.
#
# The length of an array is the number of values contained in it.
# The lenght of a struct is the number of fields contained in it.
# The lenght of a string is the number of characters contained in it.
# The length of any other value is 1.
#
# Stack: ( VAL -- VAL ULONG )

instruction sel ()
  code
    JITTER_PUSH_STACK (pvm_elemsof (JITTER_TOP_STACK ()));
  end
end

### End of instructions


## Peephole optimizations

rule swap-drop-to-nip rewrite
  swap; drop
into
  nip
end

rule rot-rot-to-nrot rewrite
  rot; rot
into
  nrot
end

rule nip-nip-to-nip2 rewrite
  nip; nip
into
  nip2
end

rule nip2-nip-to-nip3 rewrite
  nip2; nip
into
  nip3
end

rule drop-drop-to-drop2 rewrite
  drop; drop
into
  drop2
end

rule drop2-drop-to-drop3 rewrite
  drop2; drop
into
  drop3
end

rule drop3-drop-to-drop4 rewrite
  drop3; drop
into
  drop4
end

rule swap-over-to-tuck rewrite
  swap; over
into
  tuck
end

rule rot-swap-to-quake rewrite
  rot; swap
into
  quake
end

rule push-drop-to-nop rewrite
  push $a; drop
into
end
